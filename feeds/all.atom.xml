<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/all.atom.xml" rel="self"></link><id>http://particle128.com/</id><updated>2013-10-17T21:30:10+08:00</updated><entry><title>MoreEffectiveC++（1）</title><link href="http://particle128.com/posts/2013/10/MoreEffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-17T21:30:10+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-17:posts/2013/10/MoreEffectiveCpp(1).html</id><summary type="html">&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;没有实现bool类型的编译器，替代方案：&lt;br /&gt;
(1)enum bool{false,true};&lt;br /&gt;
缺点：无法int赋值给bool变量&lt;br /&gt;
(2)typedef int bool;&lt;br /&gt;
const bool false=0;&lt;br /&gt;
const bool true=1;&lt;br /&gt;
缺点：无法重载bool和int参数的函数  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++中内存泄露，不一定只是new出的对象中的数据成员泄露了，还可能在构造函数(ctor)中创建了其他资源，也泄露了。   &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有null reference，所以有时候使用引用可能比使用指针更有效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//使用指针  &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//使用引用  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;const_cast用于改变constnest和valatileness  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reinterpret_cast与编译器息息相关，不具备移植性。最常见用途：转换函数指针  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  
&lt;span class="n"&gt;FuncPtr&lt;/span&gt; &lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要以多态方式处理数组，因为数组对象总是会涉及指针算术运算，而指针位置的移动是按照指针类型的对象大小来算的，而不是指向实际对象大小。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//pb[i]是*(pb+i)的简写，代表pb+i*sizeof(Base)  &lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//同样不行，相当于循环中从后向前调用pb[j].~Base();  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不提供默认构造函数，会有3个限制：&lt;br /&gt;
1.不方便定义数组，以普通方式（&lt;code&gt;X a[N]&lt;/code&gt;）定义的数组调用默认构造函数&lt;br /&gt;
解决：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一个方法，仅用于静态数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)};&lt;/span&gt;   
&lt;span class="c1"&gt;//第二个方法，动态数组，需要额外空间保存指针数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//或 X* pX[3];  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//第三个方法，动态数组，不需要额外空间  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.不适于很多给予模版的容器类(template-based container class)&lt;br /&gt;
因为很多容器类都有单参构造函数，参数是容器的size，所以里面可能调用的&lt;code&gt;data=new T[size];&lt;/code&gt;。&lt;br /&gt;
但是设计良好的模版类，应该不依赖默认构造函数，像vector，可能使用上面3种方法的后两种解决的。&lt;br /&gt;
3.虚基类如果没有默认构造函数，对于派生类来说非常不方便。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果提供默认构造函数，可能产生没有被完全初始化的对象，如果如果不在乎上面的3个限制（不需要面对数组，不需要存入默认容器，不需要做虚基类），就不提供默认构造函数。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模版的实例化参数也是模版类型的话，注意右尖括号中间加空格。&lt;br /&gt;
static_cast&lt;Array&lt;int&gt; &amp;gt;(...)  &lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量不用conversion operator，因为很可能在你没意识到的情况下隐式调用了。&lt;br /&gt;
解决：&lt;br /&gt;
显示定义一个函数，比如&lt;code&gt;double asDouble() const&lt;/code&gt;。这样虽然写起来很麻烦，但是可以防止很多错误。  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;越有经验的C++程序员越会避免使用类型转换操作符，比如string类型没有隐式转换成char *的conversion operator，而是包含&lt;code&gt;c_str()&lt;/code&gt; 函数。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量不要使用conversion constructor，道理同上。&lt;br /&gt;
解决：&lt;br /&gt;
1.explicit  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，就不会出现类似a==b[i]这类错误通过编译了。&lt;br /&gt;
因为，b[i]如果想要转换成Array，首先需要转换成ArraySize。C++不允许两次类类型转换。&lt;br /&gt;
这种技术叫"proxy classes".  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>Linux下使用Github Pages搭建博客</title><link href="http://particle128.com/posts/2013/10/blog-build.html" rel="alternate"></link><updated>2013-10-16T22:05:23+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-16:posts/2013/10/blog-build.html</id><summary type="html">&lt;h2&gt;环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ubuntu12.04LTS(自带python2.7)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;前期准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;a href="https://github.com"&gt;github&lt;/a&gt;，建立一个名为{yourusername}.github.io的repository（不知道咋翻译,数据仓库？）  &lt;/li&gt;
&lt;li&gt;安装pelican和markdown  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install markdown &lt;span class="c"&gt;#linux下的markdown软件  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install markdown &lt;span class="c"&gt;#python的markdown包  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install pelican &lt;span class="c"&gt;#python的pelican包  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果没有安装markdown或python的markdown包，会出现如下错误：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WARNING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Could&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="sr"&gt;/path/to/&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;md&lt;/span&gt;  
&lt;span class="s1"&gt;&amp;#39;bool&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;callable&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;搭建pelican环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具体pelican的操作，可以查看&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;文档&lt;/a&gt;&lt;br /&gt;
搭建命令如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /path/to/blog&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s/container  
&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir blog &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd &lt;/span&gt;blog  
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-quickstart &lt;span class="c"&gt;#进行相应配置  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;output &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone &lt;span class="o"&gt;{&lt;/span&gt;clone URL of your github.io repository&lt;span class="o"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;修改
对MakeFile文件进行如下修改：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;github&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;publish  &lt;/span&gt;
&lt;span class="err"&gt;cd&lt;/span&gt; &lt;span class="err"&gt;OUTPUTDIR&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;add&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt;  &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;commit&lt;/span&gt; &lt;span class="err"&gt;-am&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your comments&amp;#39;&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;push&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次在blog/content里写markdown格式的文档，执行&lt;code&gt;make devserver&lt;/code&gt;，查看http://localhost:8000，并随时修改md文件。确认无误后，执行&lt;code&gt;make github&lt;/code&gt;一键生成网站与上传github。上传成功后，等待up to 10minutes就可以通过http://{yourusername}.github.io访问新修改的博客了。&lt;br /&gt;
markdown语法很简单，不清楚的可以查看&lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;markdown语法&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载pelican主题和插件  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;blog  
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/getpelican/pelican-themes.git &lt;span class="c"&gt;#getpelican提供的好多主题  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/duilio/pelican-octopress-theme.git &lt;span class="c"&gt;#pelican下octopress的主题  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/getpelican/pelican-plugins.git &lt;span class="c"&gt;#getpelican提供的一些插件  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使用插件和主题，需要修改配置文件，见后。&lt;br /&gt;
PS：默认代码高亮部分不太喜欢，所以我进行了如下修改，把灰黑色的背景改成了白色。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sed -i &lt;span class="s1"&gt;&amp;#39;s/002b36/ffffff/g&amp;#39;&lt;/span&gt; pelican-octopress-theme/static/css/main.css
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用disqus评论系统&lt;br /&gt;
注册&lt;a href="https://disqus.com/admin/signup/"&gt;Disqus&lt;/a&gt;，然后在配置文件里添加新注册的Disqus的Site short name，具体配置文件见后面。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Google站长工具，以便能被Google收录&lt;br /&gt;
用谷歌账户登陆&lt;a href="www.google.com/webmasters/"&gt;Google Webmaster Tools&lt;/a&gt;，添加自己的站点，比如particle128.com，然后可以选择提交sitemap，或者替google手动抓取页面。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Baidu站长工具，以便能被Baidu收录&lt;br /&gt;
用百度账户登陆&lt;a href="http://zhanzhang.baidu.com/"&gt;Baidu Webmaster Tools&lt;/a&gt;，添加自己的站点，比如particle128.com。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置文件
配置文件pelicanconf.py的内容  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8 -*- #&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;

&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;particle128&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;particle128&amp;#39;s Blog&amp;quot;&lt;/span&gt;
&lt;span class="c"&gt;# 点击标题进入的页面&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://localhost:8000&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;zh&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# 分页&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="c"&gt;# 默认日期是markdown文件的修改日期&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;# 博文上显示的日期格式&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE_FORMAT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;

&lt;span class="c"&gt;# !!!点击文件标题进入的文件&lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;# 由markdown保存的文件结构&lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_SAVE_AS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;# !!!archives文件的位置&lt;/span&gt;
&lt;span class="n"&gt;ARCHIVES_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;archives.html&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;# 订阅&lt;/span&gt;
&lt;span class="n"&gt;FEED_ALL_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;CATEGORY_FEED_ATOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.rss.xml&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;THEME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/home/mashu/Dropbox/Practice/Blog/pelican-octopress-theme&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Boost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.boost.org/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://python.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt; 
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/particle128&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;#顶部菜单项&lt;/span&gt;
&lt;span class="n"&gt;MENUITEMS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;archives&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/archives.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cpp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/cpp.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linux&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/linux.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/python.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;others&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/others.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;life&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/life.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# disqus评论&lt;/span&gt;
&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;particle128&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;pelican-plugins&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 设置插件路径&lt;/span&gt;
&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;related_posts&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;random_article&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;neighbors&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;sitemap&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c"&gt;# 设置启用的插件&lt;/span&gt;
&lt;span class="c"&gt;# 随机跳转到某日志&lt;/span&gt;
&lt;span class="n"&gt;RANDOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;random.html&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;# 相关文章&lt;/span&gt;
&lt;span class="n"&gt;RELATED_POSTS_MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="c"&gt;# sitemap&lt;/span&gt;
&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置文件publishconf.py内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pelicanconf&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://particle128.com&amp;#39;&lt;/span&gt;
&lt;span class="c"&gt;#顶部菜单项&lt;/span&gt;
&lt;span class="n"&gt;MENUITEMS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;archives&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/archives.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cpp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/cpp.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linux&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/linux.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/python.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;others&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/others.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;life&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/life.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;vim配置&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot; markdown设置&lt;/span&gt;
&lt;span class="s2"&gt;au BufRead,BufNewFile,FileReadPre *.md set filetype=markdown&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;换行、修改&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="err"&gt;字体，添加元数据&lt;/span&gt;
&lt;span class="nx"&gt;au&lt;/span&gt; &lt;span class="nx"&gt;FileType&lt;/span&gt; &lt;span class="nx"&gt;markdown&lt;/span&gt; &lt;span class="kt"&gt;map&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;F12&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/\&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;  &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nb"&gt;Item&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="vi"&gt;#Item&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;ggOtitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;Effective&lt;/span&gt; &lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="err"&gt;学习笔记&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;slug&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;EffectiveCpp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;EffectiveCpp&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;ESC&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到此，环境就算搭建完毕。不明白的地方，还是查看pelican的文档。  &lt;/p&gt;
&lt;h2&gt;独立域名&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;a href="http://www.goyouhuima.com/"&gt;GoDaddy优惠码网站&lt;/a&gt;选择一个链接，进入，购买一年的域名，比如particle128.com，55元左右,可以用支付宝购买。  &lt;/li&gt;
&lt;li&gt;在&lt;a href="https://www.dnspod.cn/"&gt;DNSPOD&lt;/a&gt;上注册，然后建立一条A记录，一条CNAME记录，将购买的域名particle128.com绑定到Github Pages的ip地址（注意不是独立ip），将www.particle128.com重定向到particle128.com&lt;br /&gt;
截图：&lt;br /&gt;
&lt;img alt="dnspod_screenshot" src="http://particle128.com/static/images/DNSPod.png" /&gt;  &lt;/li&gt;
&lt;li&gt;重新登陆GoDaddy，添加DNSPod的name server&lt;br /&gt;
f1g1ns1.dnspod.net&lt;br /&gt;
f1g1ns2.dnspod.net  &lt;/li&gt;
&lt;li&gt;Github Pages使用自定义域名&lt;br /&gt;
参考：https://help.github.com/articles/setting-up-a-custom-domain-with-pages&lt;br /&gt;
执行:  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;blog/output  
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;particle128.com&amp;#39;&lt;/span&gt; &amp;gt; CNAME   
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="pelican"></category><category term="blog"></category></entry><entry><title>Effective C++学习笔记(1)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-15T15:20:21+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/EffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;【补充概念】&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;类型安全&lt;/strong&gt;：&lt;br /&gt;
&lt;em&gt;MSDN上的权威解释&lt;/em&gt;：类型安全，意味着每个变量、函数参数和函数返回值存储到可接受的数据，并且，涉及不同类型的值“的操作有意义”和不导致数据丢失、位组合的解释不正确或内存损坏。&lt;br /&gt;
&lt;em&gt;简单理解&lt;/em&gt;：编译器会帮助程序员检查程序中是否使用了合适的类型，即如果程序员使用了不正确的类型，编译器会报错，而不会把错误留到运行时。&lt;br /&gt;
printf，memcpy，#define 宏定义函数就不是类型安全的。&lt;br /&gt;
(1) printf("The meaning of life is %s",42);  》》》类型安全的cout&lt;br /&gt;
(2) SomeClass a;AnotherClass b;&lt;br /&gt;
   memcpy((void&lt;em&gt;)&amp;amp;a,(void&lt;/em&gt;)&amp;amp;b,sizeof(b)); 》》》类型安全的copy constructor&lt;br /&gt;
(3) #define max(a,b) ((a)&amp;gt;(b)?(a):(b))  &lt;br /&gt;
   max(15,"abc");max(a++,b); 》》》类型安全的template inline函数（同样效率，函数可预料行为，类型安全）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Item 02: Prefer const, enum, and inline to #define&lt;/h2&gt;
&lt;p&gt;1.除非我有一个很好的理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。&lt;br /&gt;
2.头文件里定义字符串常量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//或 char const * const str=&amp;quot;hello&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺第1个const，&lt;code&gt;warning： deprecated conversion from string constant to ‘char*’&lt;/code&gt; 
缺第2个const，如果两个源文件引用该头文件，会&lt;code&gt;multiple definition&lt;/code&gt;的错误&lt;br /&gt;
3.类关键字：&lt;br /&gt;
一般情况，只允许声明处出现一次：explicit,static,virtual,默认实参&lt;br /&gt;
特殊的2个，inline：出现在任一处都行，一般写在定义处；const：两处都要出现。&lt;br /&gt;
4.&lt;code&gt;#define&lt;/code&gt;宏定义完全可以被代替。const代替常量宏，template inline函数代替函数宏。&lt;br /&gt;
此外，static const可以定义类属常量，这是#define做不到的。&lt;br /&gt;
5.static const类属常量，如果是整数类型（char，short，int，bool等），可以在声明时直接赋值，只要不取地址都可以直接使用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果非整数类型（如double），如果需要取地址，如果编译器比较旧，需要在源文件中定义，给初值。&lt;br /&gt;
如果非要在编译时使用，编译器还不允许，可以使用enum hack的方法  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.需要一组常量的时候，可以使用枚举，用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;March&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;April&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//枚举类型可以被枚举值赋值&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Third&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//整数类型也可以被枚举值赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 03: Use const whenever possible&lt;/h2&gt;
&lt;p&gt;1.const可作用于任何作用域范围的对象、函数参数、函数返回类型、成员函数本身。&lt;br /&gt;
2.函数返回类型+const的意义，限制返回值再被赋值：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;防止  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过编译&lt;br /&gt;
3.将const作用于成员函数，保证该成员函数可以被const对象调用。&lt;br /&gt;
4.const成员函数可以"重载"非const成员函数。虽然const成员函数也可以被non-const对象调用，但是重载后，定义const和non-const对象，调用的同一个函数原型，效果就不一样了。如果返回引用类型或非内置类型，一个可以被赋值，一个不可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原理：&lt;br /&gt;
重载函数的确定，先找到candidate函数（名字相同），再找到viable函数（参数列表符合），再确定best match。&lt;br /&gt;
const成员函数内隐藏的this指针是&lt;code&gt;const type *&lt;/code&gt; 类型，而非const成员函数的则是&lt;code&gt;type *&lt;/code&gt; 。因此，const重载的实质是参数类型不同。&lt;br /&gt;
所以，非const对象优先调用非const函数（最佳匹配），没有的时候才调用const函数。&lt;br /&gt;
5.函数返回内置类型，不能做左值；函数返回自定义类型，或引用类型（内置或自定义），可以做左值。&lt;br /&gt;
6.被mutable声明的变量，即使在const成员函数内，也可以修改。这样可以实现概念上的const函数，而不是bitwise上的const函数。&lt;br /&gt;
举例：类里保存cache缓冲区的指针。每次调用length()函数读取cache缓冲区大小的时候，都要重新计算一下。
7.重复代码：编译时间、维护、代码臃肿问题。&lt;br /&gt;
在operator[]函数里调用const operator[]函数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;                      &lt;span class="c1"&gt;//C++中仅有这一种方式  &lt;/span&gt;
     &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;//也可以用const_cast代替,不转换成const对象会无限递归调用自己，段错误~  &lt;/span&gt;
     &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 04: Make sure that objects are initialized before they're used.&lt;/h2&gt;
&lt;p&gt;1.类成员变量中的自定义类型，在构造函数语句执行之前，已经调用过默认构造函数初始化自身了。所以，为了效率，应该使用初始化列表，然后构造函数语句体为空。代价（默认构造函数+赋值操作）&amp;gt;代价（1个构造函数）。&lt;br /&gt;
类成员变量中的内置类型，构造函数语句执行之前一般不会初始化，而且初始化和赋值效率相同，所以放在哪里一样。代价（1次初始化）=代价（1次赋值）。&lt;br /&gt;
2.内置类型为const或引用，必须初始化，不能赋值。&lt;br /&gt;
3.static对象，包括global对象，namespace作用域内对象，类内静态对象，函数内静态对象（local static对象）。&lt;br /&gt;
寿命：从运行中被构造出来，直到main()结束自动调用析构。&lt;br /&gt;
4.&lt;br /&gt;
原理：C++对定义于不同编译单元内的non-local static对象的初始化相对次序，没有明确定义。&lt;br /&gt;
导致的问题：先构造的对象，在构造函数中引用了后构造的对象，此时该对象还没有初始化。&lt;br /&gt;
解决：以函数调用（返回local static对象的引用），替代直接访问non-local static对象。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;getobj&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;C1&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++保证，函数内local static 对象会在该函数被调用期间，首次遇上该对象的定义式时被初始化。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>两个类定义相互转换时的二义性</title><link href="http://particle128.com/posts/2013/10/inter-convert.html" rel="alternate"></link><updated>2013-10-15T15:16:41+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/inter-convert.html</id><summary type="html">&lt;p&gt;两个类，分别定义了到对方的转换，隐式使用这种转换的时候，一般会出现二义性。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;converting constructor&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;conversion function&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据C++Primer P460的讲解，很显然这段代码在编译时会报二义性（ambiguous）的错误。原因在于：conversion constructor和conversion operator并没有高下之分，所以在Y类型转换成X类型的时候，出现了二义。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果X的构造函数和Y的转换操作符变成如下声明形式：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认operator X()是最佳匹配。原因在于：如果要调用X的构造函数，那么需要首先进行标准转换（Y-&amp;gt;const Y）；而如果调用operator X则免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果声明式改成：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认X(Y&amp;amp;)是最佳匹配。原因在于：const函数的this指针是const Y &lt;em&gt;const，因此首先需要一个标准转换（Y &lt;/em&gt;-&amp;gt;const Y *）；而如果调用前者，免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;诡异的事情来了，如果声明式是：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们按照前面的推理过程，应该的得这是一个二义性的代码，因为都需要一个标准转换在调用类类型转换之前。但是g++神奇的没有报错就选择了X(const Y&amp;amp;)这个函数作为转换函数。百撕不得骑姐，甚至怀疑刚才我的推理都错了，终于在stackoverflow上找到了解答，&lt;a href="http://stackoverflow.com/questions/1384007/conversion-constructor-vs-conversion-operator-precedence"&gt;链接&lt;/a&gt; &lt;br /&gt;
这应该是g++不符合C++标准的地方，是它的一个策略：在这个都需要const转换的"二义性"情况下，默默吞掉二义性而选择conversion constructor作为最佳匹配。如果想看到二义性错误，只要使用&lt;code&gt;g++ -pedantic&lt;/code&gt;命令，pedantic的意思是迂腐的,学究式的。  &lt;/p&gt;
&lt;h3&gt;之前讨论的是隐式转换，如果是强制类型转换呢？&lt;/h3&gt;
&lt;p&gt;在测试的时候发现：如果既有构造函数，又有转换操作符，使A类对象转化为B类对象，如下3种强制类型转换方法都偏向于构造函数，除非构造函数不存在的时候，才调用转换操作符进行转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B(A)&lt;/li&gt;
&lt;li&gt;(B)A&lt;/li&gt;
&lt;li&gt;static_cast&lt;B&gt;(A)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：强制类型转换不看最佳匹配，所以即使构造函数的代价比转换操作符代价大，比如const constructor和non-const operator，也是如此。&lt;/p&gt;
&lt;p&gt;花了好久才涨了这点姿势，不过得出一个结论：&lt;strong&gt;纸上得来终觉浅，绝知此事要躬行&lt;/strong&gt;。  &lt;/p&gt;</summary><category term="conversion"></category><category term="cpp"></category></entry><entry><title>Headache</title><link href="http://particle128.com/posts/2013/10/headache.html" rel="alternate"></link><updated>2013-10-15T14:18:14+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/headache.html</id><summary type="html">&lt;p&gt;Today I encountered bad headache again. Although I had made up mind to overcome this disaster without the help of any medicine, I failed. After taking two cold capsules, hurt is fading away.&lt;br /&gt;
Headache is not a big deal, but it troubles me a lot. So, I'm going to make a list of &lt;em&gt;the cause&lt;/em&gt;, &lt;em&gt;how to avoid &lt;/em&gt;and &lt;em&gt;what to do if it has already happened&lt;/em&gt;.  &lt;/p&gt;
&lt;h3&gt;The Cause:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;excessive drink  &lt;/li&gt;
&lt;li&gt;afternoon nap not on time  &lt;/li&gt;
&lt;li&gt;have a cold  &lt;/li&gt;
&lt;li&gt;two many handjobs&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How to Avoid:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Don't drink unless it is a must. Learn to say no when others propose you a toast. &lt;strong&gt;Remember that a true hero is not evaluated according to his behavior on the table&lt;/strong&gt;.  &lt;/li&gt;
&lt;li&gt;Never destroy the routine whatever happens.  &lt;/li&gt;
&lt;li&gt;Hard to avoid.  &lt;/li&gt;
&lt;li&gt;Minimize the frequency of it.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What to do if it has already happened:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If it is serious, don't hesitate to take some pills and go to bed for a rest. Don't &lt;strong&gt;bite the bullet&lt;/strong&gt; in this case.  &lt;/li&gt;
&lt;li&gt;If not, just return to normal and watch the situation. When the situation keeps the same or turns bad, take some medicine.  &lt;/li&gt;
&lt;li&gt;Last but not least, don't waste too much time under the circumstance. Although it's uncomfortable, it's not such unbearable.  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="headache"></category><category term="health"></category></entry><entry><title>core dump相关</title><link href="http://particle128.com/posts/2013/10/core-dump.html" rel="alternate"></link><updated>2013-10-15T14:01:14+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/core-dump.html</id><summary type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;当程序异常退出（接受到内核或其他程序的某种信号，比如SIGTERM，SIGKILL等）的时候，一般会将出错时候的内存状况保存到core file中，以帮助开发者了解程序崩溃的原因。&lt;br /&gt;
即core memory（内存最开始使用线圈做的），其实就是内存。core dump就是内存倾倒的意思。  &lt;/p&gt;
&lt;h3&gt;ubuntu下使能core dump功能&lt;/h3&gt;
&lt;p&gt;ubuntu下默认core文件的大小限制是0（执行ulimit -c查看），即不允许core文件产生。&lt;br /&gt;
解除限制：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited &lt;span class="c"&gt;#设置core file的限制  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -a &lt;span class="c"&gt;#查看所有限制（包括栈大小、cpu时间、虚拟内存、文件大小等）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;core文件的默认位置&lt;/h3&gt;
&lt;p&gt;查看core文件存储格式，以及ubuntu下输出结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat /proc/sys/kernel/core_pattern   
|/usr/share/apport/apport %p %s %c  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;意思是：core file文件通过管道，变做apport程序的输入。&lt;br /&gt;
后面的参数解释如下（man core）：&lt;br /&gt;
%p - insert pid into filename 添加pid&lt;br /&gt;
%u - insert current uid into filename 添加当前uid&lt;br /&gt;
%g - insert current gid into filename 添加当前gid&lt;br /&gt;
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号&lt;br /&gt;
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间&lt;br /&gt;
%h - insert hostname where the coredump happened into filename 添加主机名&lt;br /&gt;
%e - insert coredumping executable name into filename 添加命令名&lt;br /&gt;
%c - core  file  size soft resource limit of crashing process 添加core文件大小限制  &lt;/p&gt;
&lt;h3&gt;apport&lt;/h3&gt;
&lt;p&gt;介绍它的页面：&lt;a href="https://wiki.ubuntu.com/Apport"&gt;link&lt;/a&gt;&lt;br /&gt;
需要注意的地方：&lt;br /&gt;
1. apport把core file保存在 /var/crash/ 目录下&lt;br /&gt;
2. ubuntu12.04之后，apport才默认开启。之前的版本都需要设置 /etc/default/apport 文件&lt;br /&gt;
3. apport的日志文件保存在 /var/log/apport.log 一般日志文件都放置于此，例如syslog，redis&lt;br /&gt;
4. 自己的程序，只有打包成.deb文件，并被安装之后，apport才会保存其core file到/var/crash。否则不生成core file，log文件里会报错如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;executable does not belong to a package, ignoring  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重定向core file&lt;/h3&gt;
&lt;p&gt;既然apport只能处理ubuntu下的包程序，那么我们就不让apport干涉core file的产生了。&lt;br /&gt;
执行如下命令：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited  
&lt;span class="c"&gt;# echo &amp;quot;core.%e.%p&amp;quot; &amp;gt; /proc/sys/kernel/core_pattern  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，每次core file都会在当前目录下保存了。  &lt;/p&gt;
&lt;h3&gt;gdb定位错误位置&lt;/h3&gt;
&lt;p&gt;产生core file之后（姑且命名为core.a.out.11111），直接vi查看其内容会一头雾水。&lt;br /&gt;
执行如下命令，定位程序崩溃的位置：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;gdb -c core.a.out.11111  
&lt;span class="o"&gt;(&lt;/span&gt;gdb&lt;span class="o"&gt;)&lt;/span&gt; where  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;程序中捕捉崩溃事件&lt;/h3&gt;
&lt;p&gt;sigaction()函数指定信号的处理函数（比如SIGSEGV），然后在处理函数中打log，发送错误报告之类的。  &lt;/p&gt;</summary><category term="core dump"></category></entry><entry><title>DNS相关</title><link href="http://particle128.com/posts/2013/10/dns.html" rel="alternate"></link><updated>2013-10-15T14:00:41+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/dns.html</id><summary type="html">&lt;p&gt;信息来源：谢希仁-计算机网络(第5版)，wikipedia，unp，tcp/ip详解。  &lt;/p&gt;
&lt;h3&gt;Domain Name System&lt;/h3&gt;
&lt;p&gt;host name &amp;lt; - &amp;gt; ip address&lt;br /&gt;
主机名可以是不完全域名，比如solaris；也可以是FQDN(fully-qualified domain name)，以点号结尾的域名，如solaris.unpbook.com. 。另：如果不完全域名中包含2个或以上的点号，则认为是完全限定域名。&lt;br /&gt;
如果主机名使用不完全域名，需要在/etc/resolv.conf文件里配置search unpbook.com或domain unpbook.com，以便帮助完成全限定域名的补全。  &lt;/p&gt;
&lt;h3&gt;名字/域名服务器层次结构：&lt;/h3&gt;
&lt;p&gt;root name server 根域名服务器（无名）&lt;br /&gt;
TLD(tol-level-domain) name server 顶级域名服务器（包括特殊域arpa，普通域com等，和国家域cn等）&lt;br /&gt;
authoritative name server 授权域名服务器&lt;br /&gt;
local name server 本地域名服务器  &lt;/p&gt;
&lt;h3&gt;DNS查询过程：&lt;/h3&gt;
&lt;p&gt;本地主机高速缓存里有记录的话，不用查找了。&lt;br /&gt;
本地主机缓存里记录过期或没有，以递归方式查找local。&lt;br /&gt;
local没有记录的话，一般以迭代方式分别查找root,TLD,authoritative，直到找到，返回给local。&lt;br /&gt;
以本地主机的视角，就看到查找local并得到local的回应了，local的查找过程时透明的。  &lt;/p&gt;
&lt;h3&gt;解析器的配置文件/etc/resolv.conf：&lt;/h3&gt;
&lt;p&gt;格式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lan&lt;/span&gt;  
&lt;span class="n"&gt;nameserver&lt;/span&gt; &lt;span class="mf"&gt;172.16.1.254&lt;/span&gt;  
&lt;span class="n"&gt;nameserver&lt;/span&gt; &lt;span class="mf"&gt;172.16.2.254&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;资源记录（resource record）&lt;/h3&gt;
&lt;p&gt;都可以简略理解成&amp;lt;域名，数据&amp;gt;对，数据有时候是ip地址，有时候是域名。PTR也不例外。&lt;br /&gt;
DNS中的常用RR：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A（address）：host name-&amp;gt;ipv4&lt;br /&gt;
AAAA：host name-&amp;gt;ipv6&lt;br /&gt;
PTR(pointer)：ipv4/ipv6-&amp;gt;hostname&lt;br /&gt;
MX(mail exchanger)：host name-&amp;gt;its mail exchanger&lt;br /&gt;
CNAME(canonical name):server name-&amp;gt; host name&lt;br /&gt;
NS（name server）:domain-&amp;gt;authoritive name server of this domain  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;指针查询&lt;/h3&gt;
&lt;p&gt;一个组织申请一个域名的时候，同时给其分配一个in-addr.arpa下的域名。&lt;br /&gt;
比如申请210.30.97.139的域名为www.mashu.com，那么名字服务器上会增加两条记录：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;                   &lt;span class="n"&gt;A&lt;/span&gt;      &lt;span class="mf"&gt;210.30.97.139&lt;/span&gt;  
&lt;span class="mf"&gt;139.97.30.210&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arpa&lt;/span&gt; &lt;span class="n"&gt;PTR&lt;/span&gt; &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，ip地址反向查找域名就直接找PTR记录即可，而不用遍历所有A记录了。&lt;br /&gt;
注：我理解的逆序有一定好处是，一个区域的ip地址高字节都是相同的，比如都是210.30，区分每一台主机的主要是低位的字节，所以把低字节排在前面，查找更迅速。&lt;br /&gt;
设想学校的local：逆序，第一个字节符合要求的就1个记录；正序，第一个字节所有记录都匹配。  &lt;/p&gt;
&lt;h3&gt;传输层协议：&lt;/h3&gt;
&lt;p&gt;DNS请求一般是解析器（resolver）发出的，解析器是应用程序的一部分（以模块的形式加入应用程序），而不是内核的一部分。&lt;br /&gt;
DNS一般都使用UDP数据报，只有2个特例：&lt;br /&gt;
1）DNS响应报文超过UDP的上限512B，解析器就会用TCP重发原来的请求。&lt;br /&gt;
2）一个域的辅助名字服务器从主名字服务器上拉取数据的时候，区域传送使用TCP。  &lt;/p&gt;
&lt;h3&gt;备份&lt;/h3&gt;
&lt;p&gt;除了本地名字服务器，网上有OpenDNS和googleDNS服务器的ip地址，应该是被墙了，现在访问不到。所以一旦学校的本地名字服务器崩了，就没办法通过主机名访问外网了。&lt;br /&gt;
常用网站ip地址：&lt;br /&gt;
google : 74.125.31.106  173.194.45.20 &lt;br /&gt;
yinxiang : 119.254.30.32/Home.action&lt;br /&gt;
youdao dict : 121.195.178.201  &lt;/p&gt;
&lt;h3&gt;查看DNS解析的linux工具：&lt;/h3&gt;
&lt;p&gt;[1] host&lt;br /&gt;
格式：$ host [-t type]{name} [server]&lt;br /&gt;
说明：&lt;br /&gt;
DNS解析工具。&lt;br /&gt;
name如果是一个主机名，就解析出其ip地址；name如果是ip地址，就反解析出其主机名。&lt;br /&gt;
server可选参数。默认从/etc/resolv.conf读取名字服务器（nameserver），加上该参数（ip地址或主机名形式均可）后，就采用该名字服务器。&lt;br /&gt;
-t后面接类型，比如cname，a等&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$host&lt;/span&gt; google.com    
&lt;span class="nv"&gt;$host&lt;/span&gt; google.com 202.118.66.6    
&lt;span class="nv"&gt;$host&lt;/span&gt; 127.0.0.1  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[2] nslookup&lt;br /&gt;
格式：$ nslookup [name] [server]&lt;br /&gt;
说明：交互式(interactve)DNS解析工具，输入nslookup之后出现交互式操作提示符“&amp;gt;”，之后就可以多次输入需要解析的host name。给出的解析结果相对host详细一些。  &lt;/p&gt;
&lt;p&gt;[3] dig(domain information groper)&lt;br /&gt;
格式： $ dig [server] {name} [type]&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com （默认只寻找资源类型A）  
&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com ANY  
&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com MX  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="dns"></category></entry><entry><title>Python学习笔记-ConfigParser模块</title><link href="http://particle128.com/posts/2013/10/python-configparser.html" rel="alternate"></link><updated>2013-10-15T13:55:39+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/python-configparser.html</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;配置文件可以有很多种格式，windows下常用ini格式，网络上常用xml和json格式，分别可以调用的python模块如下：&lt;br /&gt;
ini——ConfigParser模块&lt;br /&gt;
xml——xml.etree.ElementTree模块&lt;br /&gt;
json——json模块  &lt;/p&gt;
&lt;h3&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/2/library/configparser.html"&gt;link&lt;/a&gt;&lt;br /&gt;
点评：&lt;br /&gt;
前面的文字讲的很晕，没有上下文的情况下就各种说，还不如直接来几个例子。不过我还是硬着头皮看完了。  &lt;/p&gt;
&lt;h3&gt;ini文档的格式&lt;/h3&gt;
&lt;p&gt;1.注释的开始标记是semicolon 和 number sign。semicolon开头的注释可以嵌入在ini文件的行内（和其他文本用一个空白符隔开），number sign开头的注释只能用在单独的一行中。&lt;br /&gt;
2.[section]中可以使用option=value或option: value&lt;br /&gt;
3.可以在value中包含格式化字符串，来自同section，或DEFAULT section，或初始化的时候传入的内容。&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;[My&lt;/span&gt; &lt;span class="err"&gt;Section]&lt;/span&gt;  
&lt;span class="err"&gt;foodir:&lt;/span&gt; &lt;span class="err"&gt;%(dir)s/whatever&lt;/span&gt;  
&lt;span class="na"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;frob  &lt;/span&gt;
&lt;span class="err"&gt;long:&lt;/span&gt; &lt;span class="err"&gt;this&lt;/span&gt; &lt;span class="err"&gt;value&lt;/span&gt; &lt;span class="err"&gt;continues&lt;/span&gt;  
   &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;the&lt;/span&gt; &lt;span class="err"&gt;next&lt;/span&gt; &lt;span class="err"&gt;line&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类层次关系&lt;/h3&gt;
&lt;p&gt;import ConfigParser&lt;br /&gt;
class ConfigParser.RawConfigParser([defaults[, dict_type[, allow_no_value]]])&lt;br /&gt;
——》ConfigParser （增加value中格式化字符串）&lt;br /&gt;
——》 SafeConfigParser（更加健全的格式化字符串）&lt;br /&gt;
符号——》表示派生出。  &lt;/p&gt;
&lt;h3&gt;成员方法&lt;/h3&gt;
&lt;p&gt;示例： config=ConfigParser.SafeConfigParser()&lt;br /&gt;
读写配置文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expanduser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;~/.myapp.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt; &lt;span class="c"&gt;#打开多个文件，忽略打开失败的文件，返回打开成功的文件列表  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readfp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="c"&gt;# 判断配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 读取配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;MySection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;带类型判断的变种，类型不对会抛出异常：&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getfloat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getboolean&lt;/span&gt;  
&lt;span class="n"&gt;sections&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#返回section列表  &lt;/span&gt;
&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回option列表  &lt;/span&gt;
&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回(option，value)列表  &lt;/span&gt;
&lt;span class="c"&gt;# 修改配置文件内容：  &lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;frob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;遇到的问题&lt;/h3&gt;
&lt;p&gt;问题：&lt;br /&gt;
配置文件中有一行 XL=10101。但是，get函数返回的option总是xl&lt;br /&gt;
原因：&lt;br /&gt;
&lt;a href="http://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser.optionxform"&gt;link&lt;/a&gt;&lt;br /&gt;
RawConfigParser有一个成员方法：optionxform(option)&lt;br /&gt;
Transforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures.The default implementation returns a lower-case version of option.&lt;br /&gt;
意思是，ConfigParser会自动调用optionxform函数，处理输入文件中的选项字段，或输出时指定的选项字段，默认是将其转变成小写。&lt;br /&gt;
文档中的解决方案是  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cfgparser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="o"&gt;...&lt;/span&gt;  
&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optionxform&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="c"&gt;#直接改成str，意味着不区分大小写。但是这对于含有中文option的配置文件并不合适。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#调用的时候转换成小写  &lt;/span&gt;
&lt;span class="n"&gt;new_url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;originUrl&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;?q=0|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TYPE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()],&lt;/span&gt;&lt;span class="n"&gt;EMPTY&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SORT&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="ConfigParser"></category><category term="python"></category></entry><entry><title>Python学习笔记-subprocess模块</title><link href="http://particle128.com/posts/2013/10/py-subprocess.html" rel="alternate"></link><updated>2013-10-15T13:52:20+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/py-subprocess.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;subprocess是python的一个内置模块，用来产生子进程，和子进程通过pipe通信。&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;3个便捷函数&lt;/h3&gt;
&lt;p&gt;如果仅仅想要调用一个子进程完成一个任务，不需要父进程与其通信，并且等待子进程退出的话，选择便捷函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 返回returncode，0成功，非0出错。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。不同于`check_all`的唯一一点是，异常的output属性是子进程的输出，`check_all`引发的异常的output属性则是None。因为子进程的output被放到异常对象的output里，所以参数没有stdout。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;args是调用的命令和参数，可以是字符串，或字符串列表（带参数）。  &lt;/li&gt;
&lt;li&gt;是省略的一些关键字参数，不常用。  &lt;/li&gt;
&lt;li&gt;stdin,stdout,stderr是标准io，默认不重定向，可以给他们重定向到subprocess.PIPE，或文件对象（open函数的返回），或文件描述符。&lt;br /&gt;
注意：需要和子进程进行PIPE通信，不要用这三个函数。因为父进程在调用这三个函数的时候会阻塞，所以没法去都去PIPE里的信息或向管道传递信息。  &lt;/li&gt;
&lt;li&gt;shell设置为True的话，args指定的字符串将作为shell的参数，调用shell。  &lt;/li&gt;
&lt;li&gt;universal_newlines如果设置为True，那么stdout和stderr都会使用统一的换行符\n，而不区分操作系统。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Popen类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;preexec_fn&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_fds&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;startupinfo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;creationflags&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：&lt;br /&gt;
bufsize设置缓冲区大小，默认是0表示无缓冲，即每次write都直接执行io操作，而不是先放到缓冲区里，等待某个时机（换行符，或缓冲区满时才执行真正的io）&lt;br /&gt;
方法： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 检查进程是否中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 等待进程中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 和进程交互，发送数据到stdin，在stdout和stderr接收数据。前提是构造函数中对应io设置成PIPE  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# returns a tuple (stdoutdata, stderrdata)  &lt;/span&gt;
&lt;span class="c"&gt;# 发送信号给进程  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此外还有terminate（），kill（）函数&lt;br /&gt;
stdin，stdout，stderr，pid，returncode属性  &lt;/p&gt;</summary><category term="python"></category><category term="subprocess"></category></entry><entry><title>程序员的自我修养 笔记</title><link href="http://particle128.com/posts/2013/10/ziwoxiuyang.html" rel="alternate"></link><updated>2013-10-14T11:11:55+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/ziwoxiuyang.html</id><summary type="html">&lt;h2&gt;Chapter 2&lt;/h2&gt;
&lt;p&gt;所谓“编译”（gcc 1.cpp），实际上包括预处理，编译，汇编，链接。&lt;br /&gt;
gcc命令实际是后台程序的包装，包装了cc1预处理，as汇编，ld链接器&lt;br /&gt;
[1]预处理   主要处理预处理指令（#开头的），主要工作如下：&lt;br /&gt;
宏展开; 头文件插入 ; 删除注释 ； 添加行号和文件标识 。 &lt;br /&gt;
gcc -E 1.cpp -o 1.i             阅读.i文件，可以查看宏展开是否正确&lt;br /&gt;
[2]编译  把源文件生成汇编代码 (调用cc1)&lt;br /&gt;
gcc -S 1.i -o 1.s   或直接gcc -S 1.cpp -o 1.s&lt;br /&gt;
[3]汇编   把汇编代码转化成机器指令，即目标文件 (调用as)&lt;br /&gt;
gcc -c 1.s -o 1.o  或直接 gcc -c 1.cpp -o 1.o&lt;br /&gt;
[4]链接  把目标文件、库链接起来，生成可执行文件（调用ld）&lt;br /&gt;
gcc 1.o -o 1  或直接 gcc 1.cpp -o 1&lt;br /&gt;
简记：ESc   iso  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程&lt;/strong&gt;：&lt;br /&gt;
前端：跟机器无关&lt;br /&gt;
词法分析、语法分析、语义分析（给语法树的节点添加类型，主要工作是：声明和类型的匹配，类型的转换）、中间语言生成（包含优化，比如生成三地址码）&lt;br /&gt;
后端：跟机器有关&lt;br /&gt;
目标代码生成、优化  &lt;/p&gt;
&lt;h2&gt;Chapter 3       目标文件（统称）&lt;/h2&gt;
&lt;p&gt;[1] linux下目标文件和可执行文件的格式均为ELF格式。具体分类：&lt;br /&gt;
relocatable file：目标文件（.o）、静态链接库（.a）&lt;br /&gt;
executable file：可执行文件（无后缀）&lt;br /&gt;
shared object file：动态链接库（.so）&lt;br /&gt;
[2] ELF文件中数据和指令分别存放在不同的段里。原因如下：&lt;br /&gt;
（1）程序被装载后，数据和指令被映射到两个不同的虚存区域（一个可读写，一个只读），这样可以防止修改指令。&lt;br /&gt;
（2）现代cpu的cache分为指令缓存和数据缓存，提高cpu缓存命中率。&lt;br /&gt;
（3）系统中运行同一个程序的多个副本时，可以共享指令部分，但是数据部分必须一个副本拥有一份。&lt;br /&gt;
[3] 程序的指令部分放在.text段中，初始化的全局数据和局部i静态数据放在.data段中，未初始化的全局数据和局部静态数据放在.bss段中（虚拟的，不占用空间）。&lt;br /&gt;
[4] 查看目标文件中各种信息的方式：&lt;br /&gt;
objdump -h  显示各个段的基本信息&lt;br /&gt;
objdump -x  显示各个段的基本信息，显示符号表、重定位表的信息&lt;br /&gt;
objdump -s  将段的内容以16进制打印，   -d  显示指令段反汇编之后的汇编代码&lt;br /&gt;
readelf -h  查看ELF文件头 &lt;br /&gt;
readelf -S  查看段表（section header）&lt;br /&gt;
readelf -s  查看符号表&lt;br /&gt;
[5] 文件头&lt;br /&gt;
包含段表地址（相对于文件头）、段表大小、段表字符串表的索引（所有段从0开始编辑索引）&lt;br /&gt;
[5] 符号表&lt;br /&gt;
在链接中，函数和变量统称为符号（symbol），函数名和变量名就是符号名。&lt;br /&gt;
符号表中存在 定义在本目标文件中的全局符号(&lt;code&gt;global_var&lt;/code&gt;)，以及，在本目标文件中引用的全局符号(printf,&lt;code&gt;extern_var&lt;/code&gt;)。&lt;br /&gt;
[6] 字符串表（包括字符串表strtab和段表字符串表shstrtab）&lt;br /&gt;
表中就是一个接一个的存放字符串（以\0结尾），在符号表和段表中的某些需要用字符串来表示的信息（比如符号名、段名），是通过字符串在字符串表中的偏移来引用的。&lt;br /&gt;
[7] C++支持函数重载，即相同函数名的函数，可以根据参数列表（个数、类型）来区分。C++支持命名空间（类也属于），在不同命名空间可以有同样名字的符号。为了支持这一点，C++中的符号名（函数、全局变量）需要进行“名称修饰”，修饰后的名称叫“修饰后名称”（Decorated Name）。目标文件中的符号名即为修饰后名称。&lt;br /&gt;
&lt;code&gt;int N::C::func(int)&lt;/code&gt; 在gcc下的修饰后名称为&lt;code&gt;_ZN1N1C4funcEi&lt;/code&gt;，&lt;code&gt;_Z&lt;/code&gt;开头，N和E标识命名空间开始和结尾，i是参数&lt;br /&gt;
断开方式为：&lt;code&gt;_Z N 1N 1C 4func E i&lt;/code&gt;。数字标识后面的命名空间有几个字符。&lt;br /&gt;
在VC++下的修饰后名称为&lt;code&gt;?func@C@N@@AAEHH@Z&lt;/code&gt;。&lt;br /&gt;
函数返回的变量类型，并没有加入符号的修饰后名称中，所以，不能通过函数返回类型进行重载。&lt;br /&gt;
[8] C中没有名称修饰（name mangling）的概念，所有符号定义的名称（func）即为目标文件中的符号名称（func）。&lt;br /&gt;
C++中为了兼容使用C的库，头文件需要添加&lt;code&gt;extern "C" { void *memset(void*, int , size_t); }&lt;/code&gt;。&lt;br /&gt;
该关键字表明，后面的符号不使用“名称修饰”。这样，在C++中调用C的库memset可以正常使用，否则修饰后的名称和C语言库中未修饰的名称不一致，会提示链接错误。&lt;br /&gt;
[9] 强符号：函数、初始化的全局变量                 弱符号：未初始化的全局变量、用&lt;code&gt;__attribute__((weak))&lt;/code&gt;修饰的变量/函数&lt;br /&gt;
选择多次定义的全局符号    规则如下：&lt;br /&gt;
（1）不允许强符号多次定义&lt;br /&gt;
（2）多个文件中只有一个强符号，则选择强符号&lt;br /&gt;
（3）都是弱符号，选择空间最大的&lt;br /&gt;
[10] 强引用：默认             弱引用：用&lt;code&gt;__attribute__((weakref))&lt;/code&gt;修饰的引用&lt;br /&gt;
强引用的符号，链接时找不到，报链接错误;&lt;br /&gt;
弱引用的则不报错，使用地址0给那个未找到的符号赋值，运行时调用的话会出错。&lt;br /&gt;
[11] 调试信息在目标文件中占的空间（多了需要.debug开头的段），往往比代码和数据大的多，发布之前去除：strip  a.out  &lt;/p&gt;
&lt;h2&gt;Chapter4     静态链接&lt;/h2&gt;
&lt;p&gt;[1] .bss段在可执行文件中不占用空间，但是在装载后，要占用虚拟地址空间。&lt;br /&gt;
.bss段内的数据起初都是0,所以文件不必分配空间，但是运行中可能赋值，所以内存中需要空间。&lt;br /&gt;
[2] &lt;code&gt;ld a.o b.o -e main -o ab&lt;/code&gt;，-e参数表明main函数作为程序入口，否则ld链接器默认&lt;code&gt;_start&lt;/code&gt;作为入口。&lt;br /&gt;
[3] 链接两步：1.空间与地址的分配（合并目标文件[比如符号表合并成全局符号表]，分配虚拟地址）  2.符号解析与重定位（符号表中的und类型的符号在全局符号表中查找，修正代码中的地址）&lt;br /&gt;
第一步：链接之后，段表中各个段的属性VMA（Virtual Memory Address）被分配了虚拟内存地址。链接之前该属性均为0.链接之后，符号表中符号的value值变为虚拟内存地址。链接之前为想对于段的偏移。&lt;br /&gt;
第二步：链接之后，代码中的地址（外部函数和变量的引用）由默认值（0之类的）修正为实际的虚拟内存地址。&lt;br /&gt;
[4] 静态库，即目标文件的打包。ar -t libc.a可以查看包含的目标文件&lt;br /&gt;
链接库的过程：搜索库（xx.a）中所有目标文件（xx.o）的符号表，把被引用的符号存在的那个目标文件包含进可执行文件。如果被引用目标文件，还引用了其他目标文件的符号，再递归包含其他目标文件。&lt;br /&gt;
[5] 静态运行库libc.a里面一个目标文件只包含一个函数，比如printf.o，strlen.o等。&lt;br /&gt;
原因：链接器在链接静态库的时候，是以目标文件为单位的，引用了哪些目标文件中的符号（当然包括间接引用的符号），就链接哪些目标文件，库中其余的目标文件都丢弃。函数独立成目标文件，有利于减少目标文件的大小。  &lt;/p&gt;
&lt;h2&gt;Chapter7     动态链接&lt;/h2&gt;
&lt;p&gt;[1] dl好处：节省磁盘和内存空间（多个可执行文件都引用同一个模块的话，内存和磁盘上只需要保留一份）; 使软件更新之后发布更加方便（只下载并覆盖更新了的模块，而不是整个软件）。&lt;br /&gt;
[2] 动态链接，是把链接的过程推迟到了程序装载的时候，但是性能的损失不大，利远大于弊。&lt;br /&gt;
[3] &lt;code&gt;gcc -fPIC -shared -o xxx.so xxx.c&lt;/code&gt;  其中-shared表示共享对象，-fPIC（position independent code）表示地址无关代码，这是动态链接中的一种机制。&lt;br /&gt;
[4] &lt;code&gt;gcc -o -L/path/to/libyyy.so Program Program1.c ./xxx.so -lyyy&lt;/code&gt; &lt;br /&gt;
注意，动态链接库xxx.so，libyyy.so也要作为输入文件之一。这样链接器对Program1.c中引用的外部符号，就可以进行特殊处理，使它成为一个对动态符号的引用。否则ld会报错：未定义的引用。&lt;br /&gt;
gcc或ld，如果显示加上-static参数，-lyyy会查找libyyy.a，属于静态链接。ld如果使用-dynamic-linker参数（默认），-lyyy会查找最新版本的libyyy.so.x.y.z，属于动态链接。（静、动态链接查找目录包括：标准库目录，-L参数指定的目录，&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录）&lt;br /&gt;
注意：：但是编译动态库的时候，可以不加它所依赖的共享库，因为动态库不会直接执行。但是所有调用该动态库的程序，在编译的时候都要加上动态库所依赖的库。最标准的做法是，编译动态库的时候，也加上它所依赖的库。&lt;br /&gt;
[6] ldd xxx.so  查看共享对象的依赖&lt;br /&gt;
[7] 显式运行时链接，即调用动态链接器提供的api在程序中进行链接装载。好处是，减少程序的启动时间，支持插件的动态加载、删除和更新等。&lt;br /&gt;
api：dlopen（可以通过参数设置延迟绑定，当通过dlsym加载的函数第一次被使用时才进行绑定，而不是当模块被加载时就完成所有函数的绑定）,dlsym,dlclose,dlerror  &lt;/p&gt;
&lt;h2&gt;Chapter8    linux共享库的组织&lt;/h2&gt;
&lt;p&gt;[1] 共享库，动态链接库，共享对象，可以看作是同一个概念&lt;br /&gt;
[2] 版本命名：libname.so.x.y.z。&lt;br /&gt;
主版本号x表示库的重大升级，不同主版本号的库之间不兼容。&lt;br /&gt;
次版本号y表示库的增量升级，增加一些新的接口符号，但是原符号保持不变，向后兼容。&lt;br /&gt;
发布版本号z表示库的一些错误修正和性能改进，接口符号完全保持不变，互相兼容。&lt;br /&gt;
[3] Linux和Solaris系统中，采用SO-NAME的命名机制。每个共享库都对应一个SO-NAME，即共享库名去掉次版本和发表版本号之后的名字（xx.2.1.12 -&amp;gt; xx.2）。&lt;br /&gt;
共享库管理程序ldconfig，会自动在标准库目录（/usr/lib,/lib）和/etc/ld.so.conf配置文件中制定的目录（包括/usr/local/lib）下搜索，建立以"SO-NAME"为名的软链接，指向目录中主版本号相同、其他版本号最新的共享库。&lt;br /&gt;
当系统中安装或更新一个共享库时，需要运行ldconfig一下，以便更新"SO-NAME"的软链接，指向最新版本的共享库。&lt;br /&gt;
[4] 动态链接的模块所依赖的模块的路径保存在.dynamic段里面（编译的时候写入的，所以编译需要把共享库也作为输入文件）。.dynamic里如果保存的模块路径是绝对路径，动态链接器直接去加载即可。如果保存的是相对路径，依次搜索下面几个目录：&lt;br /&gt;
0)  传递给ld的参数-rpath指定的目录&lt;br /&gt;
1）&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录  &lt;br /&gt;
2）/etc/ld.so.cache指定的库路径（ldconfig执行的时候，除了建立SO-NAME软链接外，还在ld.so.cache中保存这些软链接的信息，方便动态链接器查找共享库）。（包括/usr/local/lib目录下的库）&lt;br /&gt;
3）/usr/lib，/lib。&lt;br /&gt;
[5] 环境变量&lt;code&gt;LD_PRELOAD&lt;/code&gt;里指定的文件会在动态链接器按照固定规则搜索共享库之前装载，无论程序是否依赖他们。由于“全局符号介入”机制，这里面的库中定义的符号，会让后来再加载的库中定义的同名符号失效。&lt;br /&gt;
[6] &lt;code&gt;gcc -W1,-soname,my_soname&lt;/code&gt;，-W1参数表示将指定参数传递给链接器。-soname参数指定共享库的SO-NAME，否则建立的共享库没有SO-NAME，ldconfig不会理睬这个库。  &lt;/p&gt;</summary><category term="link"></category><category term="load"></category></entry><entry><title>C++提供的数据封装，只是访问控制，而不是信息隐藏</title><link href="http://particle128.com/posts/2013/10/cpp-encapsulation.html" rel="alternate"></link><updated>2013-10-14T09:25:05+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/cpp-encapsulation.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;C++通过private，protected和public提供的encapsulation并不是information hiding，而是access specifier。因为C++中类的定义比如放在头文件中，所有private数据类型也都暴露在用户下了。  &lt;/li&gt;
&lt;li&gt;C#，Java中类的定义（private数据成员）在源文件里，因此用户如果要访问这个类，using 对应的namespace，只能接触到public成员，private里有什么根本无从知晓。&lt;br /&gt;
甚至C语言的struct，如果把实现放在源文件，也让结构体访问者无法得知其实现，只能通过一些API来访问。例子来自wiki百科&lt;a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)"&gt;Encapsulation词条&lt;/a&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Header file &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Opaque structure with hidden members  &lt;/span&gt;
&lt;span class="c1"&gt;// API functions that operate on &amp;#39;Entity&amp;#39; objects  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  



&lt;span class="c1"&gt;// Implementation file &amp;quot;api.c&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ent_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// ID number  &lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ent_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Name  &lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;// API function implementations  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category><category term="encapsulation"></category></entry><entry><title>Effective C++学习笔记(8)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html" rel="alternate"></link><updated>2013-10-13T20:15:25+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(8).html</id><summary type="html">&lt;h2&gt;Item 30: Understand the ins and outs of inlining.&lt;/h2&gt;
&lt;p&gt;1.inline（函数体代替函数调用）的好处：&lt;br /&gt;
（1）没有函数调用的开销，速度快。&lt;br /&gt;
（2）使编译器能对起进行outlined的函数所不具备的优化，因为上下文更明显了。&lt;br /&gt;
坏处：&lt;br /&gt;
（1）可能导致代码膨胀，如果inline函数内语句比较多的话。&lt;br /&gt;
（2）如果inline函数是程序库的一部分，对它的改动，需要使用者重新编译。（outline的话，直接链接即可，动态链接的话，使用者甚至不知道函数库的修改）&lt;br /&gt;
（3）大部分调试器不能调试inline函数。&lt;br /&gt;
2.inline是对编译器的申请，不是强制。&lt;br /&gt;
如下情况编译器”可能“拒绝inline（gcc -Winline会发出不能inline的警告，但是我尝试了递归和循环，没有发出警告）：&lt;br /&gt;
（1）函数太过复杂（包含递归或循环）。&lt;br /&gt;
（2）函数中调用virtual函数，因为多态是运行期行为，而inline是编译期行为。&lt;br /&gt;
如下情况提供outline版本：&lt;br /&gt;
（1）通过函数指针调用inline函数。因为如果inline函数没有outline版本的话，就没有函数地址了。&lt;br /&gt;
3.除了显示inline，类成员函数和右元函数定义与class内，也是inline函数&lt;br /&gt;
4.inline函数的函数体，通常应定义于头文件内，保证编译时可以用函数体替换函数调用。因为大多数C++编译器实现中，inling行为是编译行为。&lt;br /&gt;
5.构造和析构不适合inline。因为里面有编译器加入的代码（比如构造数据成员，出错就析构之前构造的成员），往往代码量不小，导致代码膨胀。  &lt;/p&gt;
&lt;h2&gt;Item 31: Minimize compilation dependencies between files.&lt;/h2&gt;
&lt;p&gt;1.降低文件间的编译依赖性（低耦合）的好处：&lt;br /&gt;
实现有所改变的时候，如果接口（类的public成员）没有改变，那么客户代码不用重新编译。&lt;br /&gt;
2.C++中类的定义，并没有“将接口从实现中分离”做的很好。因为类定义中，私有成员也会出现在头文件中。&lt;br /&gt;
类定义的头文件中仅仅包括前置声明（class Date;），然后在源文件中定义（Date Person::theBirthDate;）是行不通的。因为编译时，需要知道一个类型占据多大的内存，而编译器不会去查看源文件中的具体实现，仅仅查看头文件的类定义，所以必须在类定义中出现。&lt;br /&gt;
3.编译依赖性比较大的例子：&lt;br /&gt;
（0）具象类（concrete class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Date.h&amp;quot; &lt;/span&gt;&lt;span class="c1"&gt;//引入类型定义式  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Address.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;theName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;theBirthDate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="n"&gt;theAddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：Date或Address的修改，Person需要重新编译，继而Person的客户也要重新编译。Person实现的修改（比如增加或减少了成员变量），Person客户要重新编译，即使接口没有改变。&lt;br /&gt;
两种解决办法：&lt;br /&gt;
（1）句柄类（handle class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：大部分都是前置声明  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//实现细节隔离到了PersonImpl中，所以PersonImpl的实现改变后，不影响Person的客户  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//类型声明式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//使用对象的指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：需要引入一些头文件中的类型定义  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Person.h&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;PersonImpl&amp;quot;   &lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)){}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只靠"类型声明式"(class Date)就可以定义该类型的引用或指针；必须提供"类型定义式"(#include "Date.h")才可以定义该类型的对象。  &lt;/li&gt;
&lt;li&gt;声明一个函数，如果函数的参数或返回值是某自定义类型的（比如Date），只包含其类型声明式即可（class Date）。  &lt;/li&gt;
&lt;li&gt;程序库作者应该提供两种头文件：类型声明式(datefwd.h)和类型定义式(Date.h)。客户在声明包含该类型的函数时，只需包含datefwd.h即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）接口类（interface class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//抽象类   &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//全部是纯虚函数  &lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//工厂函数，返回智能指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;RealPerson.h&amp;quot;  &lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RealPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较（个人观点）：&lt;br /&gt;
（1）易用性&lt;br /&gt;
handle class更易用： Person p1(...); string name=p1.getName()&lt;br /&gt;
interface class不好用：std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(...)); string name=pp-&amp;gt;getName();&lt;br /&gt;
（2）扩展性&lt;br /&gt;
handle class没法扩展。&lt;br /&gt;
interface class方便扩展，基类可以有多个相同接口的派生类。比如create中增加一个参数，可以选择create哪个派生类。&lt;br /&gt;
4.句柄和接口类，会速度降低、内存消耗增大，但是的确可以带来松耦合的好处。&lt;br /&gt;
原则：开发过程中，用句柄和接口类；当它们导致的性能损失比较严重时，改成具象类。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(12)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html" rel="alternate"></link><updated>2013-10-13T20:09:29+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(12).html</id><summary type="html">&lt;p&gt;关于new和delete的东西，笔记不够详尽，因为新知识比较多，不太方便记录笔记。发现相关知识漏洞的时候，再去查看Cpp Primer和Effective Cpp相关章节。  &lt;/p&gt;
&lt;h2&gt;Item 49: Understand the behavior of the new-handler&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;std::set_new_handler()&lt;/code&gt;可以绑定一个&lt;code&gt;new_handler&lt;/code&gt;（类型为&lt;code&gt;void (*)()&lt;/code&gt;），即new获取不到所需内存时调用的客户定制函数。如果不设置函数，或设置null，直接抛出异常&lt;code&gt;std::bad_alloc&lt;/code&gt;。&lt;br /&gt;
2.获取&lt;code&gt;new_handler&lt;/code&gt;函数的方式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.new_handler应该具备以下一种功能：&lt;br /&gt;
（1）让更多内存可被使用。否则::operator new会无限循环调用非空的new_handler。例如程序开始分配一个内存池，动态分配不到资源的时候释放一些资源出来。&lt;br /&gt;
（2）安装另一个可以释放更多内存的new_handler函数。&lt;br /&gt;
（3）卸除new_handler，这样::operator new就会直接throw std::bad_alloc()异常了。&lt;br /&gt;
（4）抛出bad_alloc异常。不等operator new抛，自己就抛了。&lt;br /&gt;
（5）调用exit或abort直接退出程序。  &lt;/p&gt;
&lt;h2&gt;Item 50: Understand when it makes sense to replace new and delete&lt;/h2&gt;
&lt;p&gt;重写operator new和operator delete的原因：&lt;br /&gt;
（1）检查所分配内存上的运用错误：每次new的时候，在要分配空间的前后多分配一段内存，存放签名。delete的时候检查签名是否正确。如果前面的签名错了，发生了underrun（数据写到分配内存的前面了）；如果后面的签名错了，发生了overrun（ditto）。&lt;br /&gt;
（2）收集动态分配内存的使用情况：每次new的时候都要统计一些信息，比如分配了多少，等等&lt;br /&gt;
（3）加快速度：定制版本处理的情况比通用版本少，所以速度往往更快。&lt;br /&gt;
（4）降低空间开销：通用版本往往会分配额外一些内存来保存一些信息。小型对象分配器：Boost的Pool&lt;br /&gt;
（5）弥补缺省allocator非最佳齐位（alignment）：好多编译器上的new都声称保证16bit齐位，double变量需要32bit齐位，才能获得最佳的访问速度。&lt;br /&gt;
（6）获得非传统的行为：比如delete释放的时候，空间覆盖为0.  &lt;/p&gt;
&lt;h2&gt;Item 51:Adhere to convention when writing new and deletes(固守常规)&lt;/h2&gt;
&lt;p&gt;1.自定义operator new的时候，需要注意的几点&lt;br /&gt;
（1）尽量和::operator new行为一致，即while(true)下循环尝试分配内存，如果new_handle非0就调用，否则bad_alloc&lt;br /&gt;
（2）用户分配大小为0的空间  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator new的参数  &lt;/span&gt;
     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）基类的operator new，需要首先执行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//如果new派生类的话，使用全局版本的operator new  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.自定义operator delete的时候，需要注意的几点&lt;br /&gt;
（1）用户delete一个空指针  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//ptr是operator delete的参数  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）基类的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator delete的第二个参数  &lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 52: Write placement delete if you write placement new.&lt;/h2&gt;
&lt;p&gt;1.placement new，C++ Primer上翻译为定位new，理解为：特定位置（第二个参数指定的指针位置）上的new比较好。&lt;br /&gt;
2.编写placement new的时候，也要编写对应版本的placement delete。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则，可能内存泄露。&lt;br /&gt;
因为，new表达式执行中，如果第一步operator new分配内存成功，但是构造函数抛出异常，C++运行期系统需要保证内存不发生泄露，就会自动调用&lt;strong&gt;对应版本&lt;/strong&gt;的operator delete释放内存。如果找不到对应版本的operator delete，就会造成内存泄露。&lt;br /&gt;
3.global作用域定义了3种形式的operator new和对应3种形式的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;nothrow_t&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应delete版本就是第一个参数换成void*，全部不抛出异常。&lt;br /&gt;
4.定义于类内的operator new，不管是placement还是非placement，都会掩盖全局的3个版本。如果需要使用，重写这6个函数：函数体只是调用全局作用域的版本。&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：&lt;strong&gt;不能在类内简单的using ::operator new，否则报错using-declaration for non-member at class scope。&lt;/strong&gt;只能using基类的被覆盖的名字，不能using全局的，但是可以用作用域限定符(::)调用全局的函数。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(11)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html" rel="alternate"></link><updated>2013-10-13T20:06:53+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(11).html</id><summary type="html">&lt;h2&gt;Item 44: Factor parameter-independent code out of templates&lt;/h2&gt;
&lt;p&gt;1.类模版成员函数函数，只有被使用时才被具现化。类似类的合成版本的构造/复制构造/赋值操作符/析构函数。&lt;br /&gt;
2.模版的时候减少了源代码量，但是可能导致目标代码增加，因为每具现化一个版本，就多一份目标码。&lt;br /&gt;
策略：把与模版参数（类型参数或非类型参数）无关的代码，剥离出模版类。&lt;br /&gt;
（1）非类型参数&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SquareMatrix&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//方形矩阵  &lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化一次invert  &lt;/span&gt;
&lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化第二次invert，内容和第一次的代码重复了（只是把10换成5）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义一个不含有非类型参数的基类SquareMatrixBase，含有invert函数。SquareMatrix只要调用基类invert即可。这样上面的例子就会只有1个版本的invert（基类的invert函数）。&lt;br /&gt;
（2）类型参数&lt;br /&gt;
例如：大多数平台，所有指针类型都有相同的二进制表述，模版的类型参数是指针类型的（比如vector&lt;char*&gt;，vector&lt;Date*&gt;），其成员函数应该调用唯一一份底层实现（操作void*指针的函数）。  &lt;/p&gt;
&lt;h2&gt;Item 45: Use member function templates to accept all compatible types&lt;/h2&gt;
&lt;p&gt;1.以TR1::shared_ptr为例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//由“内置指针类型”构造，但是不能隐式转换，只能通过C-style类型转换或reinterpret_cast转换（尚未验证？？？）  &lt;/span&gt;
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
          &lt;span class="p"&gt;{...}&lt;/span&gt; &lt;span class="c1"&gt;//由“任意兼容类型的shared_ptr指针”构造，可以隐式转换。如果Y和U不兼容，成员初始化列表会报错  &lt;/span&gt;
         &lt;span class="c1"&gt;//赋值操作符也要定义成员函数模版，略  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本，而不是调用上面的构造函数模版  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本。  &lt;/span&gt;
         &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 46: Define non-member functions inside templates when type conversions are desired&lt;/h2&gt;
&lt;p&gt;1.希望函数所有实参接受隐式类型转换，需要定义成非成员函数；希望模版函数被自动具现化，需要声明在类内。所以需要友元函数，且定义在类内。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//需要实现这个  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="c1"&gt;//如果定义在类外的话，不能通过编译。因为“模版实参推导过程中不进行隐式类型转换”，所以int不会通过non-explicit构造函数，隐式转换成Ratioanl&amp;lt;int&amp;gt;，使模版函数operator*以int为实参具现出来。函数在类内则不同：oneHalf的定义，以int具现出来一个Rational类，编译器产生了该友元函数的声明，且该函数不是模版函数，所以接受隐式类型转换。  &lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//在类模版内，可以把Rational&amp;lt;T&amp;gt;（模版名+参数名）简写成Rational（模版名）   &lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;//如果实现在外面的话，会链接错误。  &lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.很多编译期强迫把所有模版的定义式放进头文件里，比如模版函数的实现。  &lt;/p&gt;
&lt;h2&gt;Item 47: Use traits classes for information about types&lt;/h2&gt;
&lt;p&gt;1.STL迭代器分类&lt;br /&gt;
（1）input：istream_iterator&lt;br /&gt;
（2）output：ostream_iterator&lt;br /&gt;
（3）forward：slist（单链表，STL不包含该结构）&lt;br /&gt;
（4）bidirectional：set，multiset，map，multimap，list（双向链表）&lt;br /&gt;
（5）random_access：vector，deque，string&lt;br /&gt;
2.typeid确定一个变量的类型是运行期行为，“重载函数的最佳匹配”相当于编译期的类型确定，而且有if-else功能。&lt;br /&gt;
3.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//定义类型  &lt;/span&gt;
     &lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//引用T定义的类型  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//对指针的特化版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//随即访问指针的重载版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数不需要形参，因为没有用到  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数传入一个未命名对象，类型后跟一对括号  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 48: Be aware of template metaprogramming&lt;/h2&gt;
&lt;p&gt;1.TMP的主要意义：（1）完成一些其他方法没法实现的功能（2）将运行期的工作转移到编译期，可以提高程序执行效率。&lt;br /&gt;
2.##Item47中提到的do_advance方法，就是模版元编程里的if-else用法。用typeid没法实现（非random access iterator 没法编译通过iter+=d这句话）。&lt;br /&gt;
3.循环的用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//变量在enum里，递归调用自身  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//循环结束条件：特化模版  &lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//使用：  &lt;/span&gt;
&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(10)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html" rel="alternate"></link><updated>2013-10-13T20:05:09+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(10).html</id><summary type="html">&lt;h2&gt;Item 39: Use private inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.私有继承和复合(composition)意义相同：根据某物实现出（is-implemented-in-terms-of）。&lt;br /&gt;
2.除非必要，尽量用复合实现这种语义。&lt;br /&gt;
3.可以考虑使用private继承的情况：&lt;br /&gt;
（1）需要需要访问protected成员&lt;br /&gt;
（2）需要重写virtual函数。（替代策略:可以派生一个类，重写virtual函数。然后包含这个类的对象）&lt;br /&gt;
（3）如果需要包含的是一个空类对象，用private继承，节省空间。&lt;br /&gt;
Empty Class是指，只包含typedef，enum，statice成员变量和non-virtual函数的类。因为不含非静态成员变量和虚函数，所以一般不需要内存空间。&lt;br /&gt;
注：&lt;br /&gt;
1)类中包含一个空类对象的时候，大多数编译器至少需要1个字节的内存空间。&lt;br /&gt;
2)继承自空类对象，不需要任何内存空间。&lt;br /&gt;
4.尽量复用已有代码，所以平时注意积累自己的工具箱，设计的越通用越好，随时可以拿来复用。  &lt;/p&gt;
&lt;h2&gt;Item 40: Use multiple inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.多重继承尽量不用，因为它比单一继承复杂，比如引起二义性（ambiguity），还有可能需要虚继承（虚基类）&lt;br /&gt;
合理用途：&lt;br /&gt;
public继承一个接口类，private继承一个协助实现的类（需要复用它的一些成员，但是需要重写virtual）。&lt;br /&gt;
2.二义性例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base1:public&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base2:private&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="c1"&gt;//using Base1::checkOut;  //解决二义性的方法1  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

     &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
      &lt;span class="c1"&gt;//d.Base1::checkOut();  //解决二义性的方法2  &lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++首选确定对调用而言的最佳匹配（此处两个checkOut都是最佳匹配），之后才检查其可取用性。&lt;br /&gt;
所以，虽然private明显不能用，编译器还是返回错误：request for member 'checkOut' is ambigous。&lt;br /&gt;
解决：见程序注释。&lt;br /&gt;
3.钻石型多重继承，如果不希望最上层基类的成员在下层派生类中有多个副本，需要使用虚继承。&lt;br /&gt;
虚基类：所有派生自基类的类都采用virtual继承，该基类就被成为virtual base class&lt;br /&gt;
例子：STL中basic_ios ——&amp;gt;basic_istrem，basic_ostrem——&amp;gt;basic_iostrem&lt;br /&gt;
4.虚基类的初始化责任由继承体系的最底层（most derived）类负责。这样才可以避免虚基类被初始化多次。&lt;br /&gt;
5.虚继承有代价，所以一般不要用：虚继承的派生类占内存多，虚基类访问速度慢。&lt;br /&gt;
6.如果非要使用虚基类，尽量不要在里面放置数据，做一个接口类。类似与C#和Java中的Interfaces。  &lt;/p&gt;
&lt;h2&gt;Item 41: Understand implicit interfaces and compile-time-polymorphism&lt;/h2&gt;
&lt;p&gt;1.OOP的世界，显式接口（类的public接口，函数原型）和运行期多态 （virtual调用）。&lt;br /&gt;
Generic Programming，除了上面两者之外，还有隐式接口（typename需要支持的操作），和编译期多态（具现化）。&lt;br /&gt;
2.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;someWidget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;隐式接口是：w.size()&amp;gt;10 &amp;amp;&amp;amp; w!=someWidget返回bool类型。&lt;br /&gt;
可能w.size()返回数值型，或w有operator&amp;gt;成员，或opeartor&amp;gt;函数第一个参数接受T类型（或隐式转化成T类型），&lt;br /&gt;
可能operator&amp;amp;&amp;amp;被重载，返回一个bool类型。。。  &lt;/p&gt;
&lt;h2&gt;Item 42: Understand the two meaning of typename.&lt;/h2&gt;
&lt;p&gt;1.嵌套从属类型名称(nested dependent type name)需要在前面加typename，以表明它是类型名，否则编译器会假设它不是类型，而是一个变量。&lt;br /&gt;
举例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译期默认const_iterator是T中的静态变量，x可能全局变量之类的，它们做相乘。。。&lt;br /&gt;
声明其为类型：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//函数模版  &lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;Nested&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//类模版  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.两个特例不能加typename：&lt;br /&gt;
（1）继承的基类列表（base class list）&lt;br /&gt;
（2）构造函数成员初始化列表（member initialization list）  &lt;/p&gt;
&lt;h2&gt;Item 43: Know how to access names in templatized base classes&lt;/h2&gt;
&lt;p&gt;1.跟模版没关的一个话题：&lt;br /&gt;
当需要在派生类定义一个函数，是对基类函数的扩充，但是基类函数是non-virtual函数，这时候就用一个不同的名字。比如Base::sendClear()，Derived::sendClearMsg()&lt;br /&gt;
2.模版派生类，调用模版基类的函数时，不能不加任何修饰符的调用，因为编译期拒绝向模版基类的定义中寻找这个函数的声明。否则会在编译期"解析该模版类的定义式"时就报错。&lt;br /&gt;
原因：模版基类（templatized base class）可能存在特化版本，而这个特化版本中没有定义模版派生类要调用的那个函数。编译期在检查模版定义式的时候，没法确定具体是什么类型来具现化这个模版派生类。&lt;br /&gt;
解决：&lt;br /&gt;
（1）this-&amp;gt;修饰函数&lt;br /&gt;
（2）using Base&lt;T&gt;:: 引入相应名字&lt;br /&gt;
（3）Base&lt;T&gt;::修饰函数（最差的解决方法，因为会关闭virtual绑定行为）&lt;br /&gt;
3.编译器诊断模版相关的东西，分两个阶段&lt;br /&gt;
（1）解析模版的定义式。如上一条所列，可能报错。&lt;br /&gt;
（2）用实参具现化模版。如果this引入了基类的函数，但是基类相应特化版本的确不含有那个函数，这时候报错。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(9)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html" rel="alternate"></link><updated>2013-10-13T20:03:58+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(9).html</id><summary type="html">&lt;h2&gt;Item 32: Make sure public inheritance models "is-a"&lt;/h2&gt;
&lt;p&gt;1.C++OOP最重要的规则是：公有继承模型，建模的是‘is-a’关系，基类有的特性派生类一定具有。&lt;br /&gt;
2.没有通用的设计，有些地方看似很合理的设计，在一些情形下却不能使用：&lt;br /&gt;
企鹅是鸟，但是鸟可以飞；正方形是矩形，但是矩形可以在不改变宽的情况下修改高&lt;br /&gt;
3.修改”企鹅-&amp;gt;鸟“设计：&lt;br /&gt;
（1）class Bird; class Penguin :public Bird; class FlyingBird: public Bird; //在Bird里不定义fly()，在FlyingBird里定义&lt;br /&gt;
（2）class Bird; class Penguin :public Bird; //在Bird里定义fly()，但是在Penguin里实现fly()中导出一个错误。&lt;br /&gt;
比较：前者更优，编译期错误。  &lt;/p&gt;
&lt;h2&gt;Item 33: Avoid hiding inherited names.&lt;/h2&gt;
&lt;p&gt;1.派生类中的名字，会掩盖基类中的名字。即使派生类中的函数和基类的函数参数列表不同，不论函数是non-virtual或virtual或pure-virtual的，派生类对象也无法调用基类被掩盖的函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//错误！！！  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的目的，是防止派生类从遥远的基类中继承它并不清楚的同名重载函数。&lt;br /&gt;
2.一般公有继承，都要继承父类的所有成员，所以采取两种办法可以解决掩盖，实现重载：&lt;br /&gt;
（1）using声明式  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//引入base的所有func的名字，如果func函数包括多个重载版本，都引入派生类作用域  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）forwarding function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//之所以private inheritance，是因为公有继承的设计原则就是派生类拥有基类的一切特征  &lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;  
         &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt; &lt;span class="c1"&gt;//只引入base中的一个版本的func(int)，一般设计成inline，毕竟就一句。  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 34: Differentiate between inheritance of interface and inheritance of implementation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;class设计者，将接口函数设计成不同类型，就会限制派生类的行为：&lt;br /&gt;
（1）纯虚函数——&amp;gt;接口继承，希望只继承其接口。&lt;br /&gt;
注：纯虚函数也可以实现（在源文件中），除非要提供默认的行为供子类调用(Base::fly();)，否则一般不实现。&lt;br /&gt;
（2）虚函数——&amp;gt;接口和实现继承，提供默认实现，允许覆盖继承的实现。&lt;br /&gt;
派生类不重新定义，就默认使用的基类的版本；派生类重新定义，就可以实现多态。&lt;br /&gt;
（3）非虚函数——&amp;gt;接口和实现继承，不希望被覆盖。&lt;br /&gt;
非虚函数，应该在派生类和基类中有一致的行为，所以不应该被覆盖（名字掩盖的话，就using进来基类的名字）。&lt;br /&gt;
如果想覆盖基类，就把基类的函数定义成virtual。&lt;br /&gt;
2.任何类如果打算作为基类，都要拥有若干virtual函数（至少析构函数）。&lt;br /&gt;
3.任何函数如果不变性（invariant）大于特异性（specialization），就应该被定义成基类的非虚函数，不让子类覆盖（虽然遵守与否看子类守不守规矩）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 35: Consider alternatives to virtual functions.&lt;/h2&gt;
&lt;p&gt;正如上一个item所讲，虚函数的目的：提供默认实现，允许派生类覆盖。&lt;br /&gt;
public virtual的可选替代方案如下，实现了上面的两个目的：&lt;br /&gt;
（1）Template Method模式：NVI（non-virtual interface）手法&lt;br /&gt;
基类定义non-virtual函数healthValue()，调用private/protected virtual函数doHealthValue（每个派生类可以包含各自的实现）。&lt;br /&gt;
因为healthValue()有隐式this指针参数，所以根据调用对象的类型，可以执行不同类中定义的doHealthValue。&lt;br /&gt;
优点：避免代码重复。&lt;br /&gt;
healthValue函数，在调用doHealthValue的前面做一些准备工作（锁），在后面做一些清理工作。如果用public virtual的方法，每个派生类的函数都要有重复的准备和清理代码。&lt;br /&gt;
缺点：增加一个函数调用的开销。&lt;br /&gt;
（2）Strategy模式：非成员函数指针&lt;br /&gt;
基类有函数指针成员（healthFunc），构造函数中传入函数指针，比如int (*)(const GameCharacter&amp;amp;)，默认实参是一个缺省函数的指针。&lt;br /&gt;
优点：同一类型不同对象，可以有不同health函数；同一对象的行为也可以在运行时改变（提供setHealth函数）&lt;br /&gt;
缺点：非成员函数只能访问public成员，除非降低封装性，将其定义为友元函数，或private成员提供public访问方法。 &lt;br /&gt;
（3）Strategy模式：tr1::function&lt;br /&gt;
typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;&lt;br /&gt;
同上，但是支持函数指针、函数对象，和成员函数，且不需要函数完全匹配，兼容（参数和返回类型可以隐式转换）即可。&lt;br /&gt;
（4）Strategy模式：对象指针&lt;br /&gt;
类中包含，指向另一个继承体系的对象（包含一个healthFunc的函数）的指针，构造的时候传入。  &lt;/p&gt;
&lt;h2&gt;Item37: Never redefine a function's inherited default parameter values.&lt;/h2&gt;
&lt;p&gt;1.虚函数是dynamically bound，而默认参数statically bound。所以通过基类指针或引用访问派生类对象的成员函数，使用的基类的默认参数，和派生类的具体实现。&lt;br /&gt;
2.仅仅改变默认实参，不够成重载&lt;br /&gt;
3.派生类和基类中声明同样的默认参数，遵循默认参数不变的原则。但是代码重复，且有相依性（with dependencies），意味着一处修改就要多处修改。PS：貌似重复的代码大多都有相依性，所以杜绝复制粘贴，避免重复。&lt;br /&gt;
解决办法：NVI，仅在 base's non-virtual function上声明默认参数。  &lt;/p&gt;
&lt;h2&gt;Item 38: Model 'has-a' or 'is-implemented-in-terms-of' through composition.&lt;/h2&gt;
&lt;p&gt;1.复合(composition)还有一些同义词（synonym）：内含（containment），聚合（aggregation），内嵌（embedding）&lt;br /&gt;
2.复合，即对象包含在对象里面的情况。塑模两种情况&lt;br /&gt;
（1）has-a（包含）关系：应用域，比如人包含名字、地址&lt;br /&gt;
（2）is-implemented-in-terms-of（根据某物实现出）关系：实现域，比如set是根据linked list实现出的。&lt;br /&gt;
3.区分is-a和is-implemented-in-terms-of：&lt;br /&gt;
is-a的话，对基类为真的每一件事，对派生类也为真。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(7)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html" rel="alternate"></link><updated>2013-10-13T20:00:59+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 26: Postpone variable definitions as long as possible.&lt;/h2&gt;
&lt;p&gt;1.延后变量定义的意义是，有可能变量定义后，出现异常导致变量用不到，这样变量的构造和析构函数就白费了。所以，只在使用这个变量的代码之前定义它。&lt;br /&gt;
2.循环内变量的使用，是个特殊情况。但是仍然鼓励在循环内，变量使用前才定义变量。除非满足下面两点&lt;br /&gt;
(1)赋值成本比构造+析构成本低 (2)该段代码是效率敏感（performance-sensitive）的部分&lt;br /&gt;
因为：缩小变量的作用域，对于程序的可理解性和易维护性好。  &lt;/p&gt;
&lt;h2&gt;Item 27:Minimizing casting&lt;/h2&gt;
&lt;p&gt;1.C++风格类型转换中，&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;(expr)&lt;/code&gt;是唯一一个无法用旧式语达（C风格，函数风格）执行的动作，用来将基类的指针或引用转化为子类的指针或引用。&lt;br /&gt;
2.能用C++风格转型，就不用旧式语法。因为它们容易在代码中被辨识出来，因为简化了"找出类型系统在哪个地点被破坏"的过程。&lt;br /&gt;
3.显示构造：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//func的调用方式，包括3种强制类型转换的方式：  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle函数式类型转换，也理解为构造一个临时的Widget对象&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle标准类型转换  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//C++style类型转换  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.单一对象可能有一个以上的地址。Base&lt;em&gt;指向它和Derived&lt;/em&gt;指向它时的地址可能不同，这依赖于编译器将C++的对象如何布局。&lt;br /&gt;
而且，一旦多重继承，多个基类的指针指向同一个对象，地址一定是不一样的。&lt;br /&gt;
5.以上例子表明，类型转换并不仅仅是让编译器把某种类型视为另一种类型，其他什么也没做。&lt;br /&gt;
6.派生类虚函数中调用基类的版本，错误做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用onResize的不是this的base部分，而是强制类型转换所建立的临时对象  &lt;/span&gt;
&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//因为是虚函数，且是基类的引用，会调用自己，无穷递归。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WIndow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.应该尽量避免dynamic_cast，因为很多实现版本效率很低（比如调用多个strcmp，逐层比较class name）。&lt;br /&gt;
办法是，让父类定义空virtual函数，运用多态自动调用派生类的相应函数。&lt;br /&gt;
8.来自Cpp Primer：&lt;br /&gt;
dynamic_cast（成功返回相应指针或引用，失败返回NULL或抛出异常）：处理含有virtual函数的基类引用或指针，返回动态类型。&lt;br /&gt;
typeid（返回type_info对象，支持相等比较运算和name()方法）：处理含有virtual函数的基类，返回动态类型。  &lt;/p&gt;
&lt;h2&gt;Item 28:Avoid returning handles to object internals&lt;/h2&gt;
&lt;p&gt;1.以下句子编译可以通过，但是是错误的，因为这样的话外部就可以修改内部数据了，与const矛盾了。这是因为const成员函数实现的是bitwise const，而不是logical const  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="c1"&gt;//修改成：  &lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.引用、指针和迭代器都是所谓的handle，返回一个指向内部数据的handle，降低封装性，而且可能导致悬垂handle（即handle所指向的对象被销毁了，因为handle生存期可能比对象长）。&lt;br /&gt;
因此，尽量避免返回指向内部对象的handle，除非像string和vector的operator[]方法，不得不做的时候。  &lt;/p&gt;
&lt;h2&gt;Item 29: Strive for exception-safe code.&lt;/h2&gt;
&lt;p&gt;错误例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1.“异常安全”两个条件：&lt;br /&gt;
（1）不泄露任何资源&lt;br /&gt;
（2）不允许数据败坏&lt;br /&gt;
例子中，如果new出错（时刻注意，new分配内存的时候可能因为内存不足而抛出异常），mutex资源泄露，bgImage指针悬空。&lt;br /&gt;
“异常安全的函数”满足两个条件后，还分3个等级：&lt;br /&gt;
（1）基本承诺，即保证：任何事物在有效状态下，只是调用者不确切知道处于哪种状态。&lt;br /&gt;
（2）强烈保证，即保证：函数成功就完全成功；失败，就回到调用前的状态。&lt;br /&gt;
（3）不抛异常保证，即保证：只成功不失败，不抛出异常。&lt;br /&gt;
2.不抛出异常：只能靠程序保证。如下声明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只是告诉调用者，不打算抛出异常。但是“完全可能”抛出异常，那时候会有一个函数被调用（std::set_unexcepted函数的参数绑定的异常处理函数，该函数会在抛出非声明的类型的异常时执行）。&lt;br /&gt;
3.强烈保证：&lt;br /&gt;
变换语句顺序有时候可以做到；copy-and-swap一般可以做到。&lt;br /&gt;
（1）变换语句顺序：delete 和 ++放到new后面。当然用对象管理资源更安全和简洁  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;ml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//reset的过程中，原image会delete  &lt;/span&gt;
     &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c1"&gt;//函数退出后，Lock析构会释放mutex  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）copy-and-swap：把打算修改的对象复制一份，然后修改副本，再把副本和原对象交换。&lt;br /&gt;
4.尽量让函数等级更高，但是不抛出异常很难保证，因为很多库函数都可能抛出异常；强烈保证可能耗费很大的代价，比如copy and swap方法，复制构造和赋值操作的代价。&lt;br /&gt;
权衡的过程：tradeoff。&lt;br /&gt;
但是，要在文档上说明清楚可能抛出的异常等，以及为什么没有实现安全级别更高的代码。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(6)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(6).html" rel="alternate"></link><updated>2013-10-13T19:53:49+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(6).html</id><summary type="html">&lt;h2&gt;Item 22: Declare data members private&lt;/h2&gt;
&lt;p&gt;1.把变量声明成private，然后通过public函数访问。好处：&lt;br /&gt;
（1）语法一致性。public里都是函数，不用考虑是否需要加括号。&lt;br /&gt;
（2）更精确的访问控制。可以通过get和set设置变量的可都写属性。&lt;br /&gt;
（3）封装。对底层的机制提供很大的弹性，成员变量的修改，不影响客户的使用。（比如averageSoFar()函数，可以返回average变量，也可以直接计算平均值再返回。一个占空间，一个费时间，在不同环境可以选择不同的实现）&lt;br /&gt;
2.只有private有封装性，protected和public都没有封装性。&lt;br /&gt;
因为封装性与“当其内容改变时可能造成的代码破坏量”成反比，内容改变可以理解成把它从class中移除。&lt;br /&gt;
（1）public变量移除，所有使用它的客户代码都会破坏。&lt;br /&gt;
（2）protected变量移除，所有继承自该类的派生类都会破坏。  &lt;/p&gt;
&lt;h2&gt;Item 23: Prefer non-member non-friend functions to member functions.&lt;/h2&gt;
&lt;p&gt;1.正如上一个条款所述，越多代码可以访问一个数据，数据的封装性就越差。因为越多代码访问它，它改变时造成的破坏越大，导致数据的实现弹性变小。&lt;br /&gt;
2.成员函数，友元函数可以访问类内的private成员，enum和typedef等，而非成员函数都不能访问。所以，使用非成员函数，类内私有数据的封装性更好。&lt;br /&gt;
所以，对于只"调用一个类的public成员的函数"，让其在该类的同名命名空间（可以同该类的定义不在一个文件内）下，作为非成员函数较好。&lt;br /&gt;
3.标准库STL的组织方式：namespace std跨越多个文件，需要使用的机能只要添加相应的头文件（比如#include &lt;vector&gt;）即可。  &lt;/p&gt;
&lt;h2&gt;Item 24: Declare non-member functions when type conversions should apply to all parameters&lt;/h2&gt;
&lt;p&gt;隐式类型转换，只能作用在参数上，所以成员函数的调用者（*this）作为调用者不能转换。&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//支持以下操作：  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//explicit构造函数不具备的  &lt;/span&gt;
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt; &lt;span class="c1"&gt;//operator*作为成员函数不具备的  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 25: Consider support for a non-throwing swap.&lt;/h2&gt;
&lt;p&gt;1.关于修改std：&lt;br /&gt;
不能修改std命令空间内的任何东西，也不能添加新的函数、类或模版等新的东西到std内，std的内容由C++标准委员会决定。&lt;br /&gt;
虽然添加东西进std仍可以编译和执行，但是行为没有明确定义。所以要杜绝。&lt;br /&gt;
可以在std内特化std命名空间下已存在的模版。&lt;br /&gt;
2.类模版可以偏特化(partially specialize)或全特化(totally specialize)；函数模版只能全特化。&lt;br /&gt;
偏特化指的是只特化一部分模版参数，而不是全部。&lt;br /&gt;
3.std内有一个swap模版函数，实现如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用1次拷贝构造，两次赋值操作符。&lt;br /&gt;
对于一种类型的对象而言，这个swap函数代价太大：对象内含指针，指针指向真正存放数据的对象。&lt;br /&gt;
因为对这类对象而言，交换指针即可。但是其实现必须保证复制构造和赋值操作符都是深复制（当然也可以用智能指针代替，这里不考虑），所以直接在Widget上调用swap会非常低效。&lt;br /&gt;
例如：&lt;br /&gt;
WidgetImpl类：int a,b,c; double d1,d2;&lt;br /&gt;
Widget类：WidgetImpl *pImpl;&lt;br /&gt;
解决，两步：&lt;br /&gt;
【1】Widget内提供成员函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//之所以using std::swap而不是，直接在下面的句子调用std::swap(...)是因为，这样给编译器一个选择的余地，它会在Widget所在命名空间，全局作用域和std命名空间寻找可行的swap。然后调用最合适的swap版本。最合适的版本是依据转换代价最小来确定的，而跟位于哪个作用域没有关系。  &lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//在这里是调用了stl中的swap，因为另外两个作用域内没有swap。  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【2】 std内特化swap  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.下面来自CppPrimer的内容(第4中文版：P232和P571)：&lt;br /&gt;
重载函数中既有普通函数，又有函数模版，确定具体哪个函数被调用的过程：&lt;br /&gt;
(1)确定候选函数（candidate functions），即调用点声明可见的同名普通函数，和可实例化模板函数。&lt;br /&gt;
(2)确定可行函数（viable functions），排除普通函数中没法匹配的函数。&lt;br /&gt;
(3)寻找实参和形参的最佳匹配，即转换代价最小的匹配。&lt;br /&gt;
(4)如果上面寻找到的最佳匹配有二义，去掉模版函数再寻找最佳匹配。&lt;br /&gt;
转换代价由低到高：&lt;br /&gt;
(1)exact match精确匹配（类型一致，比如形参和实参都是int）&lt;br /&gt;
(2)promotion类型提升（形参类型可表示范围涵盖实参类型可表示范围，比如int转化成double）&lt;br /&gt;
(3)standard conversion标准转换（除类型提升外的隐式转换，比如bool转化成int）&lt;br /&gt;
(4)class-type conversion类类型转换（含有one-parameter-non-explicit构造函数的类，用构造函数参数类型转化成类类型）  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(5)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html" rel="alternate"></link><updated>2013-10-11T16:34:30+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-11:posts/2013/10/EffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item18:  Make interfaces easy to use correctly and hard to use incorrectly&lt;/h2&gt;
&lt;p&gt;1.促进接口被正确使用：&lt;br /&gt;
（1）接口一致性：stl中所有容器都具有size() 函数，而不像Java和.Net。&lt;br /&gt;
（2）与内置类型行为兼容：想想和int类比。&lt;br /&gt;
2.阻止接口被误用（！！！不正确的行为，编译都不能通过）：&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）建立新类型，防止调用顺序错乱，比如(2013,1,10)。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//定义Month,Day,Year类型（struct，只含一个val变量和一个explicit单个参数构造函数即可）  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）束缚对象值，防止无意义的值，比如(Month(13),Day(1),Year(2013))。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Date类中私有化构造函数。  &lt;/span&gt;
&lt;span class="c1"&gt;//只提供一系列静态函数供调用。static Month Jan() {return Month(1);}  &lt;/span&gt;
&lt;span class="c1"&gt;//不能定义static Month Jan(1);因为 非局部静态对象的初始化顺序未定义，万一d是全局的对象，构造时可能Jan对象尚未初始化。  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）消除对象的资源管理责任，防止忘记释放资源。&lt;br /&gt;
//提供智能指针对象，而不是原始资源&lt;br /&gt;
总结：C++中为了保证接口不被误用，可能会增加很多C语言程序员看起来感觉冗余的代码，比如增加Month，Day，Year 3个类，比如定义Month::Jan()等静态函数。但是的确起到了C语言没法起到的作用：&lt;br /&gt;
（1）没法，只能认真看接口原型。&lt;br /&gt;
（2）可以通过函数内语句判断合法性，但是就将错误推迟到了运行时。&lt;br /&gt;
（3）没法，只能提醒自己释放。  &lt;/p&gt;
&lt;h2&gt;Item19: Treat class design as type design&lt;/h2&gt;
&lt;p&gt;1.应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研究class的设计。&lt;br /&gt;
2.允许T1类型被隐式转换成T2类型：&lt;br /&gt;
（1）T1类内定义operator T2()函数。&lt;br /&gt;
（2）T2含有非explicit的构造函数，且函数参数只有一个T1类型的对象。&lt;br /&gt;
3.设计类时遵循的准则略，需要设计类时查阅该书。  &lt;/p&gt;
&lt;h2&gt;Item20: Prefer pass-by-reference-to-const to pass-by-value&lt;/h2&gt;
&lt;p&gt;1.传递对象的引用，好处：&lt;br /&gt;
（1）效率高。值传递会调用参数的复制构造函数（同时调用其基类和成员变量的复制构造函数），函数退出时还要调用它们的析构函数。&lt;br /&gt;
（2）易于优化。常量引用的实现是指针，编译器通常更愿意将其放入缓存器。即使class尽含有一个double变量，编译器也不视其为内置类型，拒绝将其放入缓存器。&lt;br /&gt;
2.传递“常量”引用，好处：&lt;br /&gt;
（1）调用者不必担心传入的实参被改变。&lt;br /&gt;
（2）const或non-const对象都可以传入，适用范围更广。&lt;br /&gt;
3.小型自定义类型也不要值传递，原因：&lt;br /&gt;
（1）复制构造函数不一定小型（比如可能要deep-copy）。&lt;br /&gt;
（2）不易于被编译器优化，放入缓存器。&lt;br /&gt;
（3）该自定义类型可能在之后的更新中，体积变大。&lt;br /&gt;
4.不适合引用传递的情况：&lt;br /&gt;
（1）内置类型：效率更高，见下图&lt;br /&gt;
&lt;img alt="ec5" src="http://particle128.com/static/images/ec5.png" /&gt;
（2）STL迭代器：类似指针，STL会保证其复制构造效率高，习惯值传递&lt;br /&gt;
（3）函数对象：实质是指针  &lt;/p&gt;
&lt;h2&gt;Item21: Don't try to return a reference when you must return an object.&lt;/h2&gt;
&lt;p&gt;函数返回对象的时候，也会执行一次构造和析构函数。为了减少这次的构造和析构，可能考虑返回引用。问题：&lt;br /&gt;
（1）指向局部变量：显而易见不行。&lt;br /&gt;
（2）指向动态分配的堆上的对象：内存泄露。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//两个new出来的对象都没有办法释放，因为接触不到new出的指针。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）指向静态变量：多线程问题，还有语义上瑕疵。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;//总是返回true，因为返回的都是同一个static对象  &lt;/span&gt;
&lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>一些反思</title><link href="http://particle128.com/posts/2013/10/some-thought.html" rel="alternate"></link><updated>2013-10-11T13:37:35+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-11:posts/2013/10/some-thought.html</id><summary type="html">&lt;p&gt;来实验室的路上，总结自己过去比较失败的地方，发现了这几点：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标不具体    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有具体的目标，只有空泛的目标，比如要好好锻炼身体，要加强技术。这些空洞的、口号性质的目标往往让我坚持不了几天。但是如果采用更加具体的目标，比如要找一个漂亮的女朋友（所以要让自己强壮起来），要去某某公司（所以要加强哪几个方面的技术），就容易让我坚持下来，而且更加有针对性，不会出现走很多弯路的情况。容易坚持的原因，我觉得是有憧憬，想放弃的时候想到佳人在旁或Offer在手的情形，会让我又鼓起斗志。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;花了很多时间在做重要但不紧急的事情，但是收效甚微。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最主要的原因是我没有坚持下来，比如每天记单词啦，健身啦，什么的，都尝试过一段时间，但是都半途而废了。  &lt;br /&gt;
&lt;strong&gt;要么不做一件事，节省下来时间做其他事；要么坚持做一件事。&lt;/strong&gt;做一件事，没有坚持下来的话，会浪费很多时间，最后还相当于零。没有明确目标的做一件事，就容易半途而废。就像《高效能人士的七个习惯》中说的，绝大多数情况下不是自制力差，而是制定目标的能力差。这个我也有些许感触：别靠自制力，靠目标和纪律来约束自己。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方向选择上走了很多弯路。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然走弯路也有意义，但是会推迟成功到来的时间。比如当初做鞍山项目的时候选择的技术，让我用了前前后后半年多的时间花在一个不热门的技术上，浪费了很多宝贵的时间，本来可以用在更加有前景的技术上。又比如大四花了不少时间背英语口语，很久不练习也没有对我产生什么积极的帮助。  &lt;br /&gt;
总之，在做选择之前，多考虑考虑这件事对我实现目标（先明确的东西）到底有多大意义，如果一两年都没啥意义，而又比较好突击的话，现在就不要做。还有就是多看看前人在做什么，借鉴经验。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总结下来就是，第一个因素决定了后面两个因素。反思过去走过的弯路，供以后借鉴。    &lt;/p&gt;</summary><category term="thought"></category><category term="goal"></category></entry><entry><title>Effective C++学习笔记(4)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html" rel="alternate"></link><updated>2013-10-04T19:33:09+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(4).html</id><summary type="html">&lt;h2&gt;Item 13: Use objects to manage resources&lt;/h2&gt;
&lt;p&gt;1.资源是指，使用完之后需要归还系统的东西。比如动态分配的内存，文件描述符，互斥锁，数据库连接，sockets。&lt;br /&gt;
2.尽管可以手动释放资源（比如delete），但是程序的修改（delete之前返回了），或客户的忘记，可能导致资源释放不了。&lt;br /&gt;
解决办法：用对象管理资源，利用对象在作用域范围之外会自动调用析构函数的机制，释放资源。&lt;br /&gt;
对于heap-based资源（资源new出来的，通过指针访问），有如下两种智能指针可用：&lt;br /&gt;
（1）std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &lt;br /&gt;
缺点：指向同一对象的auto_ptr，进行赋值或拷贝构造，会导致原ptr变成null。这样的目的，释放多次同一个资源。&lt;br /&gt;
（2）std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&lt;br /&gt;
注意：不存在上面的问题，因为是RCSP(引用计数智能指针)。&lt;br /&gt;
3.以上两种指针，都是在析构函数中使用delete，动态数组元素放入上面两个智能指针中，会导致释放不完全。&lt;br /&gt;
解决：&lt;br /&gt;
（1）使用vector代替动态数组。&lt;br /&gt;
（2）仍然使用动态数组，那么使用&lt;code&gt;boost::scoped_array&lt;/code&gt;，&lt;code&gt;boost::shared_array&lt;/code&gt;。  &lt;/p&gt;
&lt;h2&gt;Item 14: Think carefully about copying behavior in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.不是heap-based的资源，需要自己建立资源管理类。然后将需要管理的资源类放在一个大括号内，退出大括号析构函数负责释放资源。&lt;br /&gt;
2.资源管理类的复制行为：&lt;br /&gt;
（1）不希望复制：&lt;br /&gt;
private继承Uncopyable&lt;br /&gt;
（2）资源一个副本，引用计数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mutexPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第二个参数是删除器，引用计数为0时调用的函数。不带此参数默认行为是delete  &lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutext&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）资源多个副本：&lt;br /&gt;
每次复制资源都深拷贝。&lt;br /&gt;
（4）转移资源拥有权：&lt;br /&gt;
使用std::auto_ptr。  &lt;/p&gt;
&lt;h2&gt;Item 15: Provide access to raw resources in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.API往往访问原始资源，所以资源管理类要提供取得原始资源的办法。&lt;br /&gt;
2.标准库中两个智能指针的做法：&lt;br /&gt;
（1）显式访问：get()&lt;br /&gt;
（2）隐式访问：成员访问操作符 -&amp;gt; 和 .可以访问到原始资源的成员&lt;br /&gt;
3.自定义资源管理类的做法：&lt;br /&gt;
（1）显式访问：定义get() ，更安全&lt;br /&gt;
&lt;code&gt;FontHandle get() const {return f;}&lt;/code&gt;&lt;br /&gt;
（2）隐式访问：定义隐式转换函数 ，更方便&lt;br /&gt;
&lt;code&gt;operator FontHandle() const {return f;}&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item16: Use the same form in corresponding uses of new and delete&lt;/h2&gt;
&lt;p&gt;1.new执行过程：通过名为operator new的函数分配内存；在该块内存有一个或多个（new string[4]）构造函数被调用。&lt;br /&gt;
delete执行过程：在该内存有一个或多个（delete [] arr）析构函数被调用；通过名为operator delete的函数释放内存。&lt;br /&gt;
2.delete []一个对象，和delete一个数组，结果都未定义。因为数组在内存的布局可能是：起始地址放置数组大小（4B），之后是数组内容。&lt;br /&gt;
3.注意typedef定义的数组类型的释放:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非常容易引起混淆，所以最好不好定义数组类型，vector代替。  &lt;/p&gt;
&lt;h2&gt;Item17: Store newed object in smart pointers in standalone statements(standalone 独立的)&lt;/h2&gt;
&lt;p&gt;1.例子：&lt;br /&gt;
&lt;code&gt;processWidget(std::tr1::shared_ptr&amp;lt;Widget&amp;gt;(new Widget),priority());&lt;/code&gt; &lt;br /&gt;
问题：编译器的优化可能导致这种顺序的调用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;  
&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//如果抛出异常，new的资源就泄露了，因为没有指针指向它，没法释放  std::tr1::shared_ptr&amp;lt;Widget&amp;gt;构造函数  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决办法：独立语句中将动态分配的对象存入智能指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;tr1&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="nx"&gt;processWidget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(3)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html" rel="alternate"></link><updated>2013-10-04T19:28:25+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(3).html</id><summary type="html">&lt;h2&gt;Item 09: Never call virtual functions in constructions and destructions&lt;/h2&gt;
&lt;p&gt;1.derived class对象构造时，base class构造函数先被调用，在其中调用/间接调用的虚函数是是父类的版本。原因有二：&lt;br /&gt;
（1）父类构造时，子类成员变量尚未初始化，处于未定义状态，C++不允许调用子类virtual函数（几乎必然会访问成员变量）&lt;br /&gt;
（2）父类构造函数执行时，动态类型是父类。&lt;br /&gt;
同理，析构函数。&lt;br /&gt;
2.替代策略：对于每个子类都要调用的函数，不声明virtual&lt;br /&gt;
（1）每个子类构造函数分别调用相应函数。例如logTransaction()&lt;br /&gt;
（2）子类构造函数显示调用父类构造函数，传递参数上去。例如&lt;code&gt;BaseClass(createLogString(para))&lt;/code&gt;，其中createLogString是static成员，保证不会访问子类对象的成员变量。  &lt;/p&gt;
&lt;h2&gt;Item 11: Handle assignment to self in operator=&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
         &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
         &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：自我赋值安全性，异常安全性。&lt;br /&gt;
解决：&lt;br /&gt;
（1）证同测试 identity test  -》解决了自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;==&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  &lt;span class="c1"&gt;//测试是否是自我赋值  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//异常可能发生，比如内存不足，复制构造函数有异常抛出。如果外面捕获了该异常，并继续执行程序，那么pb将指向被释放了的空间，之后任何操作都会引起未定义行为。  &lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）调整语句顺序 -》解决异常安全性，同时解决自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//先构造，后删除  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）copy and swap -》解决异常安全性，同时解决自我赋值安全性&lt;br /&gt;
思想就是用参数构造一个临时对象，然后和类内对象交换。具体代码略。  &lt;/p&gt;
&lt;h2&gt;Item 12： Copy all parts of an object&lt;/h2&gt;
&lt;p&gt;1.如果类中新增了一个成员变量，一定记得同时修改构造函数、复制构造函数和赋值操作符，确保新成员变量被合理的初始化和赋值。&lt;br /&gt;
2.派生类定义的复制构造函数，和赋值操作符，需要调用基类的相应函数，否则前者隐式调用基类的默认构造函数，后者则不会调用基类的赋值操作符。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;),...&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//也可以使用if(this==&amp;amp;rhs)包裹函数体，跳过自我赋值。这需要权衡自我赋值的次数，以及增加这一条判断语句的代价。一般可以不加这句话。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：编译器合成的版本，会自动调用基类的复制构造和赋值操作，就像上面实现的一样。&lt;br /&gt;
3.重复代码放到私有函数init里，不要复制构造调用赋值操作符，或反过来。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(2)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html" rel="alternate"></link><updated>2013-10-03T22:42:12+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-03:posts/2013/10/EffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item 05: Know what functions C++ silently writes and calls&lt;/h2&gt;
&lt;p&gt;1.默认生成的4种函数，都是public+inline类型的。  &lt;br /&gt;
2.复制构造函数原型：&lt;code&gt;Empty(const Empty&amp;amp;);&lt;/code&gt; 赋值操作符原型：&lt;code&gt;Empty&amp;amp; operator=(const Empty&amp;amp;);&lt;/code&gt; 为了和内置类型的赋值操作意义相同，返回左值的引用  &lt;br /&gt;
3.唯有这4个函数被调用时，才被产生出来。  &lt;br /&gt;
4.默认产生的析构函数是non-virtual的，除非base class是virtual的。  &lt;br /&gt;
5.3种情况下，赋值操作符不会自动生成：含有const成员，含有ref成员，base class的赋值操作符号是private（这时候，子类无法调用父类的赋值操作符）。    &lt;/p&gt;
&lt;h2&gt;Item 06: Explicitly disallow the use of compiler-generated functions you do not want&lt;/h2&gt;
&lt;p&gt;1.使拷贝构造函数和赋值操作符不可用，两种方式：&lt;br /&gt;
(1)声明为private，且不给予实现。 不论类外（编译错误），还是类内或友元（链接错误），都不能访问这些函数。&lt;br /&gt;
注：此方法可以让任何类成员函数，不能被访问。如果是构造函数，则不能构造对象。&lt;br /&gt;
(2)父类的成员函数是private的。  不论什么继承方式，都在子类中不可见。而拷贝构造和赋值操作都需要调用父类的同类方法，此时编译器无能为力只能不自动生成。访问这些函数将导致编译错误。&lt;br /&gt;
注：同上一item的第5点  &lt;/p&gt;
&lt;h2&gt;Item 07： Declare destructors virtual in polymorphic base classes&lt;/h2&gt;
&lt;p&gt;1.delete父类指针或引用的时候，如果不是virtual析构函数，结果是未定义的。很可能的结果是，只调用了父类的析构函数，对象局部销毁，会造成内存泄露。&lt;br /&gt;
因此，多态基类，一定要定义虚析构函数。&lt;br /&gt;
2.不用于多态基类时，最好不要加上virtual属性，否则会增加一个指针的大小。&lt;br /&gt;
为实现virtual机制，对象需要携带一个vptr(虚表指针)，指向vtbl（虚表，函数指针的数组），用来在运行期间动态确定哪个virtual函数被真正调用。&lt;br /&gt;
3.C++不提供“禁止继承”的机制，Java中final class，或C#中sealed class提供此机制。&lt;br /&gt;
4.尽量不要继承STL容器等包含non-virtual析构函数的类，因为一旦使用多态机制，结果未定义或内存泄露。&lt;br /&gt;
5.需要抽象基类，并且手头没有纯虚函数时，定义纯虚析构函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//声明  &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//定义  &lt;/span&gt;
&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt; &lt;span class="c1"&gt;//之所以需要这个，是因为子类析构时需要调用父类析构函数，不定义会链接错误  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 08: Prevent exceptions from leaving destructors&lt;/h2&gt;
&lt;p&gt;1.析构函数抛出异常，可能导致程序终止，或未定义行为，因为用户无法捕获析构函数里抛出的异常，所以一定不要让析构函数抛出异常。&lt;br /&gt;
2.正确的做法：提供用户调用可能抛出异常的函数，同时在析构函数里调用该函数，但是捕获其异常。这样用户不仅可以自己捕获异常，也能享受万一忘记调用close，析构函数帮助其close的好处。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;  
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
          &lt;span class="n"&gt;try&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
          &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*记录该事件；要么结束程序要么吞下异常*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Python学习笔记-字符串</title><link href="http://particle128.com/posts/2013/09/python-str.html" rel="alternate"></link><updated>2013-09-22T17:52:45+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-22:posts/2013/09/python-str.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;注意：tr支持的操作，基本上unicode也支持。此外unicode还多两个函数unicode.isnumeric() unicode.isdecimal()&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;（一） 具备的操作&lt;/h3&gt;
&lt;p&gt;str作为序列元素，包含其他序列共同的操作：&lt;br /&gt;
1. “hello” [not] in "hello world"&lt;br /&gt;
2. "hello" + " world"&lt;br /&gt;
3. 5&lt;em&gt;"hello" 或 “hello”&lt;/em&gt;5&lt;br /&gt;
4. "hello"[3]  "hello"[1:2]  "hello"[1:2:2]&lt;br /&gt;
5. len("hello")  min("hello")  max("hello")&lt;br /&gt;
6. "hello".index('o')   "hello".count('l')  &lt;/p&gt;
&lt;h3&gt;（二） 不具备的操作&lt;/h3&gt;
&lt;p&gt;str同tuple一样，属于不可变序列。可变序列包括list和bytearray。因此str不具备可变序列的操作：&lt;br /&gt;
1. s[i] = x    s[i:j] = t 【t是任何可迭代对象】 s[i:j:k] = t 【t需要和s[i:j:k]有相同数量的元素】&lt;br /&gt;
2. del s[i:j]    del s[i:j:k]   s.remove(x) =&amp;gt; del s[x]&lt;br /&gt;
3. s.insert(i, x)  s.append(x)  s.extend(t) 【t是任何可迭代对象】&lt;br /&gt;
4. s.index(x[, i[, j]]) 【匹配x的最小索引，可以给定一个范围i&amp;lt;=idx&lt;j】  s.count(x)&lt;br /&gt;5. .reverse()    s.sort([cmp[, key[, reverse]]])&lt;br /&gt;6. s.pop([i]) =&gt; x = s[i]; del s[i]; return x  &lt;/p&gt;
&lt;h3&gt;（三） 字符串方法&lt;/h3&gt;
&lt;p&gt;str.capitalize()第一个字母大写 str.title() 每一个单词首字母大写&lt;br /&gt;
str.count(sub[, start[, end]])&lt;br /&gt;
str.endswith(suffix[, start[, end]])返回True或False 同理str.startswith&lt;br /&gt;
str.find(sub[, start[, end]]) 找不到返回-1 同理str.rfind&lt;br /&gt;
str.index(sub[, start[, end]])找不到raise ValueError 同理str.rindex&lt;br /&gt;
str.format(&lt;em&gt;args, &lt;/em&gt;*kwargs) 同格式化字符串&lt;br /&gt;
islower isupper isspace isdigit isalpha isalnum&lt;br /&gt;
str.ljust(width[, fillchar])左对齐，可以选择填充字节，默认空格。 同理str.rjust，str.zfill(width)相当于str.rjust(width,'0')&lt;br /&gt;
str.lower() str.upper() str.swapcase()交换大小写&lt;br /&gt;
str.partition(sep) 划分 'what the fuck'.partition('the') =&amp;gt; ('what ','the',' fuck') 同理rpartition&lt;br /&gt;
str.join(iterable) 把可迭代对象（比如序列）拼接成字符串，用str隔开每一个可迭代对象中的元素&lt;br /&gt;
str.translate(string.maketrans(from,to) [,deletechars]) 要么进行字母的替换，要么进行字母的删除（第一个参数为None），要么同时进行&lt;br /&gt;
str.strip([chars]) 默认去掉whitespace 同理str.lstrip str.rstrip &lt;br /&gt;
str.split([sep]) 默认whitespace作为分隔符  &lt;/p&gt;
&lt;h3&gt;（四） string方法&lt;/h3&gt;
&lt;p&gt;string.maketrans(from,to) 返回translation table（from中的字符被to中同一位置的字符替换），from和to长度要相同&lt;br /&gt;
string.capwords(s[,sep]) 比titile更加准确的首字母大写函数。先split([sep])，再capitalize()，再join()  &lt;/p&gt;
&lt;h3&gt;（五） 格式化字符串&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%(language)s&lt;/span&gt;&lt;span class="s"&gt; has &lt;/span&gt;&lt;span class="si"&gt;%(number)03d&lt;/span&gt;&lt;span class="s"&gt; quote types.&amp;quot;&lt;/span&gt;  &lt;span class="o"&gt;%&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;（六）字符串常量&lt;/h3&gt;
&lt;p&gt;string.digits&lt;br /&gt;
string.hexdigits&lt;br /&gt;
string.octdigits&lt;br /&gt;
string.lowercase&lt;br /&gt;
string.uppercase&lt;br /&gt;
string.whitespace&lt;br /&gt;
string.punctuation&lt;br /&gt;
string.printable  &lt;/p&gt;</summary><category term="python"></category><category term="str"></category></entry><entry><title>Python学习笔记-logging模块</title><link href="http://particle128.com/posts/2013/09/python-logging.html" rel="alternate"></link><updated>2013-09-08T10:10:19+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/python-logging.html</id><summary type="html">&lt;h4&gt;Logging is a means of tracking events that happen when some software runs.&lt;/h4&gt;
&lt;h3&gt;1、各种消息机制的使用场合&lt;/h3&gt;
&lt;p&gt;终端输出来显示一些信息：print()&lt;br /&gt;
报告软件常规运行中出现的一些事件，比如状态变化或错误调查：logging.info()，&lt;br /&gt;
logging.debug()用来诊断错误&lt;br /&gt;
发布一个警告：logging.warning()或warnings.warn()&lt;br /&gt;
报告一个错误：raise an exception&lt;br /&gt;
不抛出异常的出错：logging.error(), logging.exception(), logging.critical()  &lt;/p&gt;
&lt;p&gt;logging有一个属性叫level或severity，只有不低于它的事件才会被捕捉。&lt;/p&gt;
&lt;p&gt;level由低到高依次是：&lt;br /&gt;
DEBUG，INFO，WARNING（默认等级），ERROR，CRITICAL  &lt;/p&gt;
&lt;h3&gt;2、基础用法&lt;/h3&gt;
&lt;p&gt;默认日志消息会输出到终端（sys.stderr），用法为：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;  
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; before you &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Look&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;leap!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一次性配置日志消息，用法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;example.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;filemode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(levelname)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;something happends.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;basicConfig参数：
filename指明日志消息输出到指定的文件中，默认输出到终端&lt;br /&gt;
filemode指明文件打开方式是只写，每次输出日志都会把原来的日志覆盖。默认是追加('a')&lt;br /&gt;
level指明追踪(track)的日志等级&lt;br /&gt;
format指明日志格式，里面的字典参数依次是：日期、等级名、日志消息。format里不支持：和\n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; basicConfig只能在调用logging.debug()等任意函数之前调用，否则无效。调用之后，所有的logging行为都按照配置，再次执行basicConfig也不能进一步修改配置。所以称之为one-off（一次性的）。&lt;/p&gt;
&lt;h3&gt;3、高级用法&lt;/h3&gt;
&lt;p&gt;比较好的习惯是logger=logging.getLogger(__name__) ，这样每个模块里logger的名字都是以自己模块的名字来命名的，从日志中可以看出是哪里导出的日志。&lt;/p&gt;
&lt;p&gt;logger=logging.getLogger()相当于获取根logger，即名字为root的logger  &lt;/p&gt;
&lt;p&gt;Logger常用方法：&lt;br /&gt;
setLevel()，addHandler()，removeHandler()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;Handler常用方法：&lt;br /&gt;
setLevel()，setFormatter()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;myFilter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;#其实可以不用继承，只要含有filter方法的类都可以&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;# record是LogRecord对象&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#使用msg属性或getMessage()方法都可以&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# zero for not logging&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# non-zero for logging&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;main.a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# main.a是该logger的name，即所有者，用点来分割命名空间。如果是main.a则是main的子类，继承关系影响level、handler，如果不设置level就按照父类的level进行设置，如果不设置handler，就由父类的handler捕获。&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 过滤该level以下的日志消息&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c"&gt;# 比level更细力度的过滤功能&lt;/span&gt;

&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/home/mashu/log.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StreamHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 文件level是INFO&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 终端level是DEBUG&lt;/span&gt;
&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)-15s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(name)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(levelname)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 设置日志消息的格式&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;first: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;second:test log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;third: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="logging"></category></entry><entry><title>Linux权限小结</title><link href="http://particle128.com/posts/2013/09/authority.html" rel="alternate"></link><updated>2013-09-08T10:01:27+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/authority.html</id><summary type="html">&lt;h4&gt;1、文件权限：针对文件的实际数据（data block中的内容）&lt;/h4&gt;
&lt;p&gt;r：可以查看文件内容&lt;br /&gt;
w：可以修改文件内容&lt;br /&gt;
x：可以执行文件内容  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; &lt;br /&gt;
一个文件可以仅有r权限，修改需要强制写入，比如vim下:w!，然后再:q。&lt;/p&gt;
&lt;h4&gt;2、目录权限：针对目录的结构，实际也是目录的实际数据（data block里存的就是目录里的文件列表&amp;lt;文件名，inode号&amp;gt;）&lt;/h4&gt;
&lt;p&gt;r：可以查看目录结构（ls）&lt;br /&gt;
w：可以修改目录结构（如touch新文件，rm文件，其他无出其右：mv重命名是先删再增）&lt;br /&gt;
x：可以把目录当作工作目录（cd。即使不cd进去，在目录下进行各种操作比如读、修改文件也要有目录的x权限）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
一个目录开放浏览，需要r+x权限。&lt;br /&gt;
有r没x，ls可以看到文件名，不能cd进入，ls -l看到其他属性都是问号；&lt;br /&gt;
有x没r，可以cd进去，不能ls查看内容。【所谓不能，是指执行该操作会返回“Permission denied”】&lt;br /&gt;
仅有w，无法修改目录结构，因为命令进入不进去这个目录，需要x权限配合w才能完成修改目录的作用。&lt;/p&gt;
&lt;h4&gt;3、umask：初始权限中需要屏蔽的部分，ubuntu12.04下默认是0002，去掉其他用户的写权限。&lt;/h4&gt;
&lt;p&gt;文件初始权限：-rw-rw-rw- （0666）&lt;br /&gt;
文件默认权限：初始-umask。0666-0002=0664，即-rw-rw-r--&lt;br /&gt;
文件夹初始权限：drwxrwxrwx（0777）&lt;br /&gt;
文件夹默认权限：初始-umask。0777-0002=0775，即drwxrwxr-x  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
所有者和同组用户权限相同，其他用户剥夺写权限。&lt;br /&gt;
命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="mo"&gt;022&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;修改&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;默认值&lt;/span&gt;
&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;以字符的形式显示&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;之后的效果，&lt;/span&gt;&lt;span class="mo"&gt;0002&lt;/span&gt;&lt;span class="err"&gt;对应&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rx&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4、三个特殊权限：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SUID（SetUID）&lt;/strong&gt;：ls-l显示所有者权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/passwd。普通用户可以执行passwd修改自己的密码，执行该程序后默认UID变为root（passwd的所有者），因此可以修改仅仅root可读的/etc/shadow&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGID（SetGID）&lt;/strong&gt;：ls-l显示组权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/locate。普通用户执行locate定位文件，执行该程序后默认GID变为slocate（locate的所属用户组），因此可以查询仅仅mlocate组内用户可以访问的mlocate.db&lt;br /&gt;
另：作用于目录时，相当于用户cd进该目录后有效用户组就变成该目录的用户组了，影响此后新建的文件的所属用户组。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SBIT（Sticky Bit）&lt;/strong&gt;：ls-l显示其他权限x-&amp;gt;t&lt;br /&gt;
例子：/tmp。用户进入/tmp下新建的文件，只有root和文件所有者可以删除，其他用户即使对/tmp有w权限也没用。&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Linux下的用户和用户组小结</title><link href="http://particle128.com/posts/2013/09/linux_user.html" rel="alternate"></link><updated>2013-09-08T08:32:29+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/linux_user.html</id><summary type="html">&lt;h3&gt;1. 修改文件的相应属性&lt;/h3&gt;
&lt;h4&gt;chown 修改文件所有者&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chown mashu:mashu aa.txt &lt;span class="c"&gt;# 或chown mashu.mashu aa.txt 同时修改所有者和组&lt;/span&gt;
chown mashu aa.txt &lt;span class="c"&gt;# 修改所有者&lt;/span&gt;
chown .mashu aa.txt &lt;span class="c"&gt;# 修改组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chgrp 修改文件所属用户组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chgrp mashu aa.txt 修改组
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chmod 修改权限&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod 777 aa.txt   
chmod a+r aa.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 3个重要文件&lt;/h3&gt;
&lt;h4&gt;/etc/passwd&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的UID，初始用户组GID，说明，home dir，shell  &lt;/p&gt;
&lt;h4&gt;/etc/shadow&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的密码（加密后）  &lt;/p&gt;
&lt;h4&gt;/etc/group&lt;/h4&gt;
&lt;p&gt;记录 组名 对应的GID，组内用户（不包括初始用户组是该组的用户，因为/etc/passwd里有了）&lt;/p&gt;
&lt;h3&gt;3. 概念区分&lt;/h3&gt;
&lt;h4&gt;初始用户组：&lt;/h4&gt;
&lt;p&gt;useradd或usermod，-g参数后的组名。保存在/etc/passwd中。&lt;br /&gt;
实际意义是，/etc/group里少写一个用户名。。。  &lt;/p&gt;
&lt;h4&gt;有效用户组：&lt;/h4&gt;
&lt;p&gt;groups显示的第一用户组。可以通过newgrp重设。具体哪个文件保存不详。&lt;br /&gt;
实际意义是，用户新建文件时文件的所属用户组，就是有效用户组。&lt;/p&gt;
&lt;h3&gt;4. 用户分类&lt;/h3&gt;
&lt;p&gt;ubuntu12.04下，根据/etc/login.defs&lt;br /&gt;
UID=0  系统管理员&lt;br /&gt;
UID in {100,999} 系统用户  (SYS_UID_MIN - SYS_UID_MAX)&lt;br /&gt;
UID in {1000,60000} 可登录用户  (UID_MIN - UID_MAX)  &lt;/p&gt;
&lt;h3&gt;5. linux命令&lt;/h3&gt;
&lt;h4&gt;1) useradd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;useradd -u &lt;span class="o"&gt;[&lt;/span&gt;UID&lt;span class="o"&gt;]&lt;/span&gt; -g &lt;span class="o"&gt;[&lt;/span&gt;initial group name&lt;span class="o"&gt;]&lt;/span&gt; -G &lt;span class="o"&gt;[&lt;/span&gt;other group name&lt;span class="o"&gt;]&lt;/span&gt; -d &lt;span class="o"&gt;[&lt;/span&gt;home dir&lt;span class="o"&gt;]&lt;/span&gt; -s &lt;span class="o"&gt;[&lt;/span&gt;shell&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;没有参数，默认是可登录用户（有shell，有home dir），同名初始用户组。&lt;br /&gt;
-r 建立系统用户（不能登录，没有shell，默认没有home dir，除非修改/etc/login.defs文件）&lt;/p&gt;
&lt;h4&gt;2) usermod&lt;/h4&gt;
&lt;p&gt;同useradd&lt;/p&gt;
&lt;h4&gt;3) passwd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;passwd &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt; 
passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无参数修改自己的密码&lt;/p&gt;
&lt;h4&gt;4) userdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;userdel -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加上-r，连同主文件夹也一同删除&lt;/p&gt;
&lt;h4&gt;5) groupadd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupadd -g &lt;span class="o"&gt;[&lt;/span&gt;GID&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-g 指定GID，-r 创建系统组&lt;/p&gt;
&lt;h4&gt;6) groupdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupdel &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category><category term="user"></category></entry></feed>