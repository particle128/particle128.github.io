<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/cpp.rss.xml" rel="self"></link><id>http://particle128.com/</id><updated>2013-11-05T08:50:42+08:00</updated><entry><title>C++中名字查找</title><link href="http://particle128.com/posts/2013/11/name-lookup.html" rel="alternate"></link><updated>2013-11-05T08:50:42+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-05:posts/2013/11/name-lookup.html</id><summary type="html">&lt;p&gt;今天被C++的名字查找和using语句折磨了一天，记录下来最终的理解，还有一些未解的问题，以后有时间再研究。  &lt;/p&gt;
&lt;h2&gt;名字查找&lt;/h2&gt;
&lt;p&gt;这个&lt;a href="http://blog.csdn.net/xtyyumi301/article/details/662639"&gt;链接&lt;/a&gt;对我帮助很大，此外还参考了一些SO上的解答，和&lt;a href="http://en.wikipedia.org/wiki/Argument-dependent_name_lookup"&gt;wiki&lt;/a&gt;&lt;br /&gt;
C++的名字查找(name lookup)，作为重载确定(overload resolution)的第一步，具有举足轻重的作用。很可能存在一个合适的函数，因为被内层作用域的同名变量或函数屏蔽，而不能被调用。但这仅仅是名字查找的一方面，因为名字查找包括两个方面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规查找（normal lookup）  &lt;/li&gt;
&lt;li&gt;实参决定的查找（argument-dependent lookup）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有函数调用，都会进行常规查找；只有函数的实参包括 类类型对象 或 指向类类型对象的指针/引用 的时候，才会进行实参确定的查找。&lt;br /&gt;
分别解释如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normal lookup&lt;br /&gt;
从函数被调用的局部作用域开始，逐渐向上层寻找被调用的名字，一旦找到就停止向上寻找。此外，using语句可以将其他作用域的名字引用到当前作用域。  &lt;/li&gt;
&lt;li&gt;argument-dependent lookup(ADL)&lt;br /&gt;
从第一个类类型参数开始，依次遍历所有类类型参数。&lt;br /&gt;
对于每一个参数，进入其类型定义所在的作用域（类内友元函数也包括在内），并依次进入其基类、间接基类……定义所在的作用域，查找同名函数。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;:在继承体系中上升的过程中，不会因为找到同名函数就停止上升。这不同于normal lookup  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码，&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;就是调用&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;，ADL根据第一个参数std::cout（std::ostream类型）去std命名空间寻找&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;函数，最后匹配到&lt;code&gt;std::ostream&amp;amp; std::operator&amp;lt;&amp;lt;(std::ostream&amp;amp;, const char*)&lt;/code&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include&amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello World, where did operator&amp;lt;&amp;lt;() come from?&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例代码帮助理解，注意其中的注释：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//1  &lt;/span&gt;
&lt;span class="c1"&gt;//第一个实参所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="c1"&gt;//友元函数定义在T内，但是在T外层的作用域中可见，即Name1中  &lt;/span&gt;
        &lt;span class="c1"&gt;//using Name1::func的话，不会引入T内友元  &lt;/span&gt;
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//2  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="c1"&gt;//不能和T内的friend函数有相同的参数列表，否则重定义错误  &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//3  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//实参的间接父类所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//4  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//5  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//实参父类所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name0&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Name00&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//6  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//7  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//第二个实参所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Name0&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T0&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//8  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//9  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Name1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Name2&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="c1"&gt;//9个函数全是候选函数  &lt;/span&gt;
    &lt;span class="c1"&gt;//第1个函数是normal lookup找到的  &lt;/span&gt;
    &lt;span class="c1"&gt;//后8个函数全是argument-dependent lookup找到的  &lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;using语句&lt;/h2&gt;
&lt;p&gt;using语句包括两种：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using directive&lt;br /&gt;
语法格式为：using namespace XXX;&lt;br /&gt;
没看懂C++标准里写的这一块，但是测试发现，使用这种方法不能将XXX中的func加入重载函数的候选函数，如果当前作用域找不到func，normal lookup会继续向上层寻找。  &lt;/li&gt;
&lt;li&gt;using declaration&lt;br /&gt;
语法格式为：using XXX::func;&lt;br /&gt;
可以使用该方法将func函数加入候选函数集合，且这种方法会阻止normal lookup向外层作用域寻找func。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="name-lookup"></category></entry><entry><title>Effective C++学习笔记(6)</title><link href="http://particle128.com/posts/2013/11/EffectiveCpp(6).html" rel="alternate"></link><updated>2013-11-04T21:06:31+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-04:posts/2013/11/EffectiveCpp(6).html</id><summary type="html">&lt;h2&gt;Item 22: Declare data members private&lt;/h2&gt;
&lt;p&gt;1.把变量声明成private，然后通过public函数访问。好处：&lt;br /&gt;
（1）语法一致性。public里都是函数，不用考虑是否需要加括号。&lt;br /&gt;
（2）更精确的访问控制。可以通过get和set设置变量的可都写属性。&lt;br /&gt;
（3）封装。对底层的机制提供很大的弹性，成员变量的修改，不影响客户的使用。（比如averageSoFar()函数，可以返回average变量，也可以直接计算平均值再返回。一个占空间，一个费时间，在不同环境可以选择不同的实现）&lt;br /&gt;
2.只有private有封装性，protected和public都没有封装性。&lt;br /&gt;
因为封装性与“当其内容改变时可能造成的代码破坏量”成反比，内容改变可以理解成把它从class中移除。&lt;br /&gt;
（1）public变量移除，所有使用它的客户代码都会破坏。&lt;br /&gt;
（2）protected变量移除，所有继承自该类的派生类都会破坏。  &lt;/p&gt;
&lt;h2&gt;Item 23: Prefer non-member non-friend functions to member functions.&lt;/h2&gt;
&lt;p&gt;1.正如上一个条款所述，越多代码可以访问一个数据，数据的封装性就越差。因为越多代码访问它，它改变时造成的破坏越大，导致数据的实现弹性变小。&lt;br /&gt;
2.成员函数，友元函数可以访问类内的private成员，enum和typedef等，而非成员函数都不能访问。所以，使用非成员函数，类内私有数据的封装性更好。&lt;br /&gt;
所以，对于只"调用一个类的public成员的函数"，让其在该类的同名命名空间（可以同该类的定义不在一个文件内）下，作为非成员函数较好。&lt;br /&gt;
3.标准库STL的组织方式：namespace std跨越多个文件，需要使用的机能只要添加相应的头文件（比如#include &lt;vector&gt;）即可。  &lt;/p&gt;
&lt;h2&gt;Item 24: Declare non-member functions when type conversions should apply to all parameters&lt;/h2&gt;
&lt;p&gt;隐式类型转换，只能作用在参数上，所以成员函数的调用者（*this）作为调用者不能转换。&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//支持以下操作：  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//explicit构造函数不具备的  &lt;/span&gt;
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt; &lt;span class="c1"&gt;//operator*作为成员函数不具备的  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 25: Consider support for a non-throwing swap.&lt;/h2&gt;
&lt;p&gt;1.关于修改std：&lt;br /&gt;
不能修改std命令空间内的任何东西，也不能添加新的函数、类或模版等新的东西到std内，std的内容由C++标准委员会决定。&lt;br /&gt;
虽然添加东西进std仍可以编译和执行，但是行为没有明确定义。所以要杜绝。&lt;br /&gt;
唯一可以在std内做的事情是:全特化std命名空间下已存在的模版。不能偏特化，因为偏特化相当于在std内增加模版。&lt;br /&gt;
2.类模版可以偏特化(partially specialize)或全特化(totally specialize)；函数模版只能全特化。&lt;br /&gt;
偏特化指的是只特化一部分模版参数，而不是全部。&lt;br /&gt;
3.std内有一个swap模版函数，实现如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用1次拷贝构造，两次赋值操作符。&lt;br /&gt;
对于一种类型的对象而言，这个swap函数代价太大：对象内含指针，指针指向真正存放数据的对象(pimpl技术)。&lt;br /&gt;
因为对这类对象而言，交换指针即可。但是其实现必须保证复制构造和赋值操作符都是深复制（当然也可以用智能指针代替，这里不考虑），所以直接在Widget上调用swap会非常低效。&lt;br /&gt;
例如：&lt;br /&gt;
WidgetImpl类：int a,b,c; double d1,d2;&lt;br /&gt;
Widget类：WidgetImpl *pImpl;&lt;br /&gt;
解决，两步：&lt;br /&gt;
【1】Widget内提供成员函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//使用using std::swap,而不是直接在下面的句子调用std::swap(...)&lt;/span&gt;
    &lt;span class="c1"&gt;//这样给编译器一个选择的余地，它会在WidgetImpl类所在命名空间(argument-dependent lookup)，&lt;/span&gt;
    &lt;span class="c1"&gt;//和当前命名空间或上层(normal lookup)，上分别进行名字查找来确定候选函数。&lt;/span&gt;
    &lt;span class="c1"&gt;//然后调用最合适的swap版本。最合适的版本是依据转换代价最小来确定的，而跟位于哪个作用域没有关系。  &lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//在这里是调用了stl中的swap（normal lookup的结果），因为WidgetImpl所在命名空间内没有&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【2】 std内特化swap  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:如果Widget是模版类，不能在std空间下定义swap，因为不支持偏特化函数，即使支持也不能添加到std里。这时候，在Widget定义所在的命名空间内定义一个模版swap函数&lt;code&gt;template&amp;lt;typename T&amp;gt;void swap(Widget&amp;lt;T&amp;gt;&amp;amp;a,Widget&amp;lt;T&amp;gt;&amp;amp;b){...}&lt;/code&gt;，可以保证在使用swap(w1,w2)的时候，至少候选函数中会包含这个版本，这得益于argument-dependent lookup。
4.下面来自CppPrimer的内容(第4中文版：P232和P571)：&lt;br /&gt;
重载函数中既有普通函数，又有函数模版，确定具体哪个函数被调用的过程：&lt;br /&gt;
(1)确定候选函数（candidate functions），即调用点声明可见的同名普通函数，和可实例化模板函数。&lt;br /&gt;
(2)确定可行函数（viable functions），排除普通函数中没法匹配的函数。&lt;br /&gt;
(3)寻找实参和形参的最佳匹配，即转换代价最小的匹配。&lt;br /&gt;
(4)如果上面寻找到的最佳匹配有二义，去掉模版函数再寻找最佳匹配。&lt;br /&gt;
转换代价由低到高：&lt;br /&gt;
(1)exact match精确匹配（类型一致，比如形参和实参都是int）&lt;br /&gt;
(2)promotion整型提升（比如short转化成int）&lt;br /&gt;
(3)standard conversion标准转换（除类型提升外的隐式转换，比如bool转化成int，short转换成long）&lt;br /&gt;
(4)class-type conversion类类型转换（含有one-parameter-non-explicit构造函数的类，用构造函数参数类型转化成类类型）  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>继承层次中的重载、重写的函数调用和this指针的关系</title><link href="http://particle128.com/posts/2013/11/Overwrite-Overload.html" rel="alternate"></link><updated>2013-11-02T11:21:27+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-02:posts/2013/11/Overwrite-Overload.html</id><summary type="html">&lt;p&gt;例子如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="c1"&gt;//Base中函数的重写  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="c1"&gt;//Base中函数的重载  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Derived  &lt;/span&gt;
    &lt;span class="c1"&gt;//解释：重写的情况形参列表相同，考虑this指针，最佳匹配是Derived中的func  &lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Base  &lt;/span&gt;
    &lt;span class="c1"&gt;//解释：重载的情况，不考虑this指针，最佳匹配是Base中func1  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：上面的解释，是我根据实验结果的推测，翻阅了几本C++的书籍也没找到合理的答案。如果之后遇到合理的解释，我会再更新在这里  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;加上virtual函数后，可能更容易混淆。C++继承层次中确定函数调用的步骤:&lt;br /&gt;
1.确定调用者的静态类型（指针、引用或对象本身）&lt;br /&gt;
2.在其类的作用域中查找名字（只看名字），如果找不到就沿着继承链向上找。找不到名字就报错。&lt;br /&gt;
3.找到名字后，确定函数参数是否匹配，并寻找最佳匹配。找不到最佳匹配就报错。&lt;br /&gt;
4.如果最佳匹配是虚函数，查看调用者的动态类型(引用、指针的情况)，确定应该调用的函数位于哪个类的作用域中，并调用之；否则，直接调用该最佳匹配的函数。&lt;br /&gt;
例子如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;non-virtual Base int&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;virtual Base double&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived double&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived int&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;12.5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Derived double&lt;/span&gt;
    &lt;span class="c1"&gt;//解释：静态类型获得最佳匹配是virtual函数，所以第4步根据动态类型调用派生类的虚函数&lt;/span&gt;
    &lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出non-virtual Base int&lt;/span&gt;
    &lt;span class="c1"&gt;//解释：静态类型最佳匹配是non-virtual函数，所以直接调用&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category></entry><entry><title>MoreEffectiveC++(4)</title><link href="http://particle128.com/posts/2013/11/MoreEffectiveCpp(4).html" rel="alternate"></link><updated>2013-11-01T11:22:57+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-01:posts/2013/11/MoreEffectiveCpp(4).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;技术Techniques,Idioms,Patterns&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item25 构造函数、非成员函数的虚化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这一条目所指的“虚化”，并不是C++语法意义上的虚化，而是“动态调用”的意思。  &lt;/li&gt;
&lt;li&gt;3种语义上的虚化：&lt;br /&gt;
1.虚构造函数&lt;br /&gt;
根据输入（磁盘、网络、终端），可产生不同类型的对象，保存于&lt;code&gt;list&amp;lt;Base*&amp;gt;&lt;/code&gt;中&lt;br /&gt;
2.虚拷贝构造函数&lt;br /&gt;
定义虚函数clone，返回一个指针，指向调用者副本（&lt;code&gt;return new TextBlock(*this);&lt;/code&gt;），复制构造函数通过基类指针调用不同的clone&lt;br /&gt;
3.虚非成员函数&lt;br /&gt;
定义虚函数print，参数和返回值都是ostream&amp;amp;，定义非成员函数&lt;code&gt;inline ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s,const Base&amp;amp; c){return c.print(s);}&lt;/code&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item26 限制一个类所能产生的对象数量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;杂类知识：&lt;br /&gt;
1.不能在类成员变量里定义自身类型的对象，否则编译器报错&lt;code&gt;incomplete type&lt;/code&gt;。但是可以在类成员函数（包括inline构造函数）中定义该类类型的对象。&lt;br /&gt;
2.希望该类不能实例化对象，声明protected ctor；希望该类不能被继承和实例化对象，声明private ctor。&lt;br /&gt;
3.基类指针、引用指向派生类对象，必须是public继承，private和protected继承都会报错&lt;code&gt;'Base' is an inaccessible base of 'Derived'&lt;/code&gt;。一般允许当作基类的类都要定义virtual dtor，但是如果该基类只被private或protected继承的话，不需要定义虚析构函数。  &lt;/li&gt;
&lt;li&gt;限制对象数量，方法如下：&lt;br /&gt;
(1)声明private ctor，友元/静态成员函数定义如下  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;thePrinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Printer&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;评价：仅限于只允许一个对象的情况&lt;br /&gt;
(2)类中定义静态数据成员count，定义一个异常类TooManyObject，构造函数计算count并抛出异常&lt;br /&gt;
评价：允许多个对象；但是，继承或包含该类的类的定义，也会造成count累积抛出异常。&lt;br /&gt;
(3)同上，另外构造函数私有化，提供友元/静态成员函数&lt;code&gt;makePrinter(){return new Printer()}&lt;/code&gt;。&lt;br /&gt;
评价：允许多个对象，不会出现上述问题，因为直接就不让继承该类或定义该类的对象了；但是，只能产生heap上的对象，需要手动delete或放到智能指针里。&lt;br /&gt;
(4)定义计数类模版  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;//每个class类型有一个计数器（maxObjects），所以定义成模版  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;  
&lt;span class="nl"&gt;protected:&lt;/span&gt;  
    &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//protected构造函数，防止实例化  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;maxObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//不定义maxObjects，让用户自己定义，比如const size_t Counted&amp;lt;Printer&amp;gt;::maxObjects=10;  &lt;/span&gt;
&lt;span class="c1"&gt;//私有继承，语义上是：implemented in terms of；功能上是：防止基类指针/引用访问派生类对象  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item27 要求，或禁止对象产生于堆上&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为什么需要对象产生于堆上：&lt;br /&gt;
需要一种对象，可以在作用域离开之前撤销自己，即&lt;code&gt;delete this&lt;/code&gt;的功能。  &lt;/li&gt;
&lt;li&gt;为什么需要对象禁止在堆上产生：&lt;br /&gt;
嵌入式系统中堆上的资源比较有限  &lt;/li&gt;
&lt;li&gt;要求对象产生于堆上：&lt;br /&gt;
1.private/protected dtor,public ctors&lt;br /&gt;
2.定义&lt;code&gt;public void destory const(){delete this;}&lt;/code&gt;&lt;br /&gt;
这样，只能通过Obj* po=new Obj;调用，只能通过po-&amp;gt;destory()释放。因为定义类的对象（Obj o;）的时候会检查ctor和dtor的可访问性，有一个不可访问就会编译出错。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：&lt;br /&gt;
1.private ctors也可以限制构造对象，但是构造函数比较多，都需要一一定义为private，不如析构函数方便&lt;br /&gt;
2.如果需要保证继承，将dtor定义为protected.  &lt;/li&gt;
&lt;li&gt;禁止对象产生于堆上：&lt;br /&gt;
定义private限定的operator new，operator delete，operator new[]，operator delete[]&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;:基类的operator new私有化，那么派生类如果不在public里重新定义operator new，调用Derived *pd=new Derived;就会出错。只要Derived类中存在operator new，即使不可访问（private或protected），new操作符也不会转而调用全局作用域的operator new。  &lt;/li&gt;
&lt;li&gt;没有具备移植性的正确的办法，可以判断一个对象位于堆内。&lt;br /&gt;
1.定义类内static bool isOnHeap，类内operator new设置isOnHeap，构造函数判断isOnHeap的值，并在最后恢复isOnHeap为false&lt;br /&gt;
缺点：线程不安全；new一个数组会出错，即使定义了operator new&lt;a href="分配一次，构造多次，第二个构造中isOnHeap为false"&gt;&lt;/a&gt;&lt;br /&gt;
2.根据进程在内存中的布局（栈位于最高地址，向下增长；静态存储区位于最低地址，向上增长；堆位于静态存储区上，向上增长）  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//栈顶，最低地址  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//只有堆地址或静态存储区才小于栈地址  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺点：布局依赖操作系统实现，不具备移植性；无法区分静态和堆上的对象  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法明确确定位于堆上，但是可以比较容易的判断是否可以delete&lt;br /&gt;
1.定义全局operator new，分配空间的同时，保存这个地址在一个全局list里。全局operator delete判断全局list里是否存在该地址&lt;br /&gt;
缺点：污染其他代码；效率；Base1* pb=new Derived()，多重继承下基类地址可能不同于派生类对象地址，造成判断错误&lt;br /&gt;
2.定义abstract mixin base class（抽象混合式基类），把operator new,operator delete，list都保存于其中  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;HeapTrack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//解决上述第3个问题，把基类this指针转换成派生类对象地址  &lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rawAddr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="cm"&gt;/*判断list中是否包含rawAddr*/&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：派生类中的基类函数，参数this的类型为指向基类类型的指针常量。否则一个类被多个类继承，该类的所有函数就要有多份重载的代码。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(1)</title><link href="http://particle128.com/posts/2013/10/MoreEffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-29T10:05:01+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-29:posts/2013/10/MoreEffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有实现bool类型的编译器，替代方案：&lt;br /&gt;
(1)enum bool{false,true};&lt;br /&gt;
缺点：无法int赋值给bool变量&lt;br /&gt;
(2)typedef int bool;&lt;br /&gt;
const bool false=0;&lt;br /&gt;
const bool true=1;&lt;br /&gt;
缺点：无法重载bool和int参数的函数  &lt;/li&gt;
&lt;li&gt;C++中内存泄露，不一定只是new出的对象中的数据成员泄露了，还可能在构造函数(ctor)中创建了其他资源，也泄露了。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基础议题Basics&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有null reference，所以有时候使用引用可能比使用指针更有效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//使用指针  &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//使用引用  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;const_cast用于改变constnest和valatileness  &lt;/li&gt;
&lt;li&gt;reinterpret_cast与编译器息息相关，不具备移植性。最常见用途：转换函数指针  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  
&lt;span class="n"&gt;FuncPtr&lt;/span&gt; &lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;经典语录&lt;blockquote&gt;
&lt;p&gt;让转型动作既丑陋又不易键入，或许未尝不是件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要以多态方式处理数组，因为数组对象总是会涉及指针算术运算，而指针位置的移动是按照指针类型的对象大小来算的，而不是指向实际对象大小。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//pb[i]是*(pb+i)的简写，代表pb+i*sizeof(Base)  &lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//同样不行，相当于循环中从后向前调用pb[j].~Base();  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不提供默认构造函数，会有3个限制：&lt;br /&gt;
1.不方便定义数组，以普通方式（&lt;code&gt;X a[N]&lt;/code&gt;）定义的数组调用默认构造函数&lt;br /&gt;
解决：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一个方法，仅用于静态数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)};&lt;/span&gt;   
&lt;span class="c1"&gt;//第二个方法，动态数组，需要额外空间保存指针数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//或 X* pX[3];  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//第三个方法，动态数组，不需要额外空间  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.不适于很多给予模版的容器类(template-based container class)&lt;br /&gt;
因为很多容器类都有单参构造函数，参数是容器的size，所以里面可能调用的&lt;code&gt;data=new T[size];&lt;/code&gt;。&lt;br /&gt;
但是设计良好的模版类，应该不依赖默认构造函数，像vector，可能使用上面3种方法的后两种解决的。&lt;br /&gt;
3.虚基类如果没有默认构造函数，对于派生类来说非常不方便。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果提供默认构造函数，可能产生没有被完全初始化的对象，如果如果不在乎上面的3个限制（不需要面对数组，不需要存入默认容器，不需要做虚基类），就不提供默认构造函数。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作符operators&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;模版的实例化参数也是模版类型的话，注意右尖括号中间加空格。&lt;br /&gt;
static_cast&lt;Array&lt;int&gt; &amp;gt;(...)  &lt;/li&gt;
&lt;li&gt;尽量不用conversion operator，因为很可能在你没意识到的情况下隐式调用了。&lt;br /&gt;
解决：&lt;br /&gt;
显示定义一个函数，比如&lt;code&gt;double asDouble() const&lt;/code&gt;。这样虽然写起来很麻烦，但是可以防止很多错误。  &lt;blockquote&gt;
&lt;p&gt;越有经验的C++程序员越会避免使用类型转换操作符，比如string类型没有隐式转换成char *的conversion operator，而是包含&lt;code&gt;c_str()&lt;/code&gt; 函数。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;尽量不要使用conversion constructor，道理同上。&lt;br /&gt;
解决：&lt;br /&gt;
1.explicit&lt;br /&gt;
2.例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，就不会出现类似a==b[i]这类错误通过编译了。&lt;br /&gt;
因为，b[i]如果想要转换成Array，首先需要转换成ArraySize。C++不允许两次类类型转换。&lt;br /&gt;
这种技术叫"proxy classes".  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(2)</title><link href="http://particle128.com/posts/2013/10/MoreEffectiveCpp(2).html" rel="alternate"></link><updated>2013-10-29T10:03:05+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-29:posts/2013/10/MoreEffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自增自减操作符，两原则：&lt;br /&gt;
1.postfix increment和decrement操作符，应该返回const对象，理由是：不允许进行两次后置++，防止用户把比较操作符写成赋值操作符而通过编译。  &lt;blockquote&gt;
&lt;p&gt;设计类的一条无上宝典就是：一旦有疑虑，试看int行为如何并遵循之。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.后自增和自减应该调用前自增和自减，而不是自己写函数，这样只需要维护前自增。  &lt;/p&gt;
&lt;h2&gt;Item7&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要重载&amp;amp;&amp;amp;，||和，操作符，因为无论定义成员或非成员函数，都无法模拟C++中这3个操作符的行为模式（短路，求值顺序）。  &lt;/li&gt;
&lt;li&gt;for语句头包括3个部分，第1部分是语句，所以可以定义多个变量。第3部分是表达式，所以只能用逗号隔开多个表达式，而不能使用语句（比如调用函数或定义变量）。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item8&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;placement new类似于new，首先调用operator new，然后调用对象构造函数，然后返回内存指针。&lt;br /&gt;
不同点，是placement new调用的operator new的原型和实现如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//第一个参数不提供名字，防止编译器警告。  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;placement new构造的对象，最好不要调用delete来释放，否则未定义。因为delete析构对象之后调用operator delete释放内存，而这段内存不一定是operator new(size_t)分配的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异常Exception&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item9&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;利用析构函数(smart pointer处理单个对象，vector处理对象数组)避免资源泄露，绝不使用操纵局部资源的指针。&lt;br /&gt;
因为即使加了try和catch语句块包裹可能出现异常的代码，也会把代码变得支离破碎，而且delete会出现两边（正常执行序列的最后，catch中throw到上一层之前）  &lt;/li&gt;
&lt;li&gt;C++加入异常的概念，意义：&lt;br /&gt;
保证错误的发生绝不会被忽略，而C语言中置errno或返回错误代码的方法，都可能因为调用者的不检查而使错误不被发现。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item10 在构造函数中阻止资源泄露(resource leak)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对象未构造完全(构造函数中抛出异常)，不会调用其析构函数，但是对象的成员变量会保证释放（如果是类类型，自动调用其析构）。在ctor中动态分配资源可能因为异常的出现，泄露了。&lt;br /&gt;
原因：&lt;br /&gt;
析构函数如果需要在构造不完全的对象上自动执行，就得记录构造函数执行到的位置，代价太大。  &lt;/li&gt;
&lt;li&gt;构造函数动态分配资源的情况下，防止资源泄露的解决办法&lt;br /&gt;
1.构造函数中try+catch&lt;br /&gt;
2.类中使用auto_ptr成员代替指针成员  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item11 禁止异常流出dtor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;析构函数调用时机&lt;br /&gt;
1.退出作用域&lt;br /&gt;
2.stack unwinding时&lt;br /&gt;
3.delete&lt;br /&gt;
4.手动调用  &lt;/li&gt;
&lt;li&gt;禁止异常流出的原因：&lt;br /&gt;
1.避免在stack unwinding时，析构函数抛出的异常导致terminate函数执行，中止程序。&lt;br /&gt;
考虑上线的软件，因为1个异常就down机了，这绝不是人们想看到的。&lt;br /&gt;
2.协助确保dtor完成了所有事情。&lt;br /&gt;
考虑析构函数有多条语句，第一条语句执行中抛出异常，后面的语句没法执行，但是可能很重要，比如释放对象资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item12 区分异常和函数调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如下示例：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;  
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//抛出的是类型为Base的异常对象。只有在基类指针或引用指向派生类对象，且调用虚函数的情况下才会看动态类型，其余都是静态类型。  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;异常对象是抛出对象的副本，是一个临时对象。一般临时对象是常量的。但是catch字句中non-const引用也可以捕获，这是一个特例。  &lt;/li&gt;
&lt;li&gt;异常和函数调用区别：&lt;br /&gt;
1.总会被复制，需要支持复制构造&lt;br /&gt;
2.允许的类型转换很少&lt;br /&gt;
3.按catch子句出现的顺序匹配，而不是最佳匹配  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item13 以引用方式捕获异常&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原因：&lt;br /&gt;
1.by-pointer:不知道是全局和静态对象，还是动态对象，所以不知道要不要delete；和语言本身可能抛出的异常(bad_alloc等)不符合&lt;br /&gt;
2.by-value:切割对象，无法多态；复制对象成本高&lt;br /&gt;
3.by-reference:没上面的问题  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item14 异常说明符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;try和catch后面的语句必须用大括号包围，即使只有1条语句。  &lt;/li&gt;
&lt;li&gt;当抛出exception specification中没有出现的异常时，unexpected函数会被系统调用，默认调用terminate中止程序。&lt;br /&gt;
就像不希望析构函数抛出异常一样，必须防止任何中止程序(很可能是需要一直运行的服务程序)的行为，即使有错误发生。&lt;br /&gt;
注意：&lt;br /&gt;
1.不要给模版函数提供异常说明。因为模版的类型实参千变万化，无法预料抛出异常的情况。&lt;br /&gt;
2.需要调用没有异常说明的函数，自己也不要给出异常说明。&lt;br /&gt;
3.不使用默认版本的unexcepted函数：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一种方式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nf"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;span class="c1"&gt;//第二种方式  &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;;}&lt;/span&gt;&lt;span class="c1"&gt;//重抛，默认抛出bad_exception  &lt;/span&gt;
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：采用了上面任一种方式后，需要在函数的异常说明符中加入UnexpectedException或bad_exception，否则还是会terminate。  &lt;/p&gt;
&lt;h2&gt;Item15 understand exception handling's cost&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;即使从未使用exception处理机制，程序为了支持exception，也需要放置一些数据结构占用空间，维护这些数据结构占用时间。  &lt;/li&gt;
&lt;li&gt;try语句，以及异常说明，会导致代码膨胀和速度下降5%~10%（一些测试结果，并未很准确）。异常的真正抛出，会比正常函数返回，慢3个数量级（同上，不准确）。  &lt;/li&gt;
&lt;li&gt;代价很大，所以仅在非用不可的时候才使用，不要像写python那样轻易使用。  &lt;/li&gt;
&lt;li&gt;如果确保自己的程序中没有用到exception机制，并且确保调用的标准库没有用到，例如没有try catch throw关键字，那么可以通过编译器的选项禁止。&lt;br /&gt;
g++下的禁止方式是&lt;code&gt;-fno-exceptions&lt;/code&gt;。如果有异常抛出（new无法分配等），直接调用std::abort()进行中止。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(3)</title><link href="http://particle128.com/posts/2013/10/MoreEffectiveCpp(3).html" rel="alternate"></link><updated>2013-10-29T10:02:10+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-29:posts/2013/10/MoreEffectiveCpp(3).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;效率Efficiency&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item16 80-20 principal&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Most programs' performance bottle-neck is inclined to high counter-intuition. If you just improve programs here and there, it won't help a lot.  &lt;/li&gt;
&lt;li&gt;The accurate way to do this is to use program profiler(程序分析器).  &lt;/li&gt;
&lt;li&gt;Offer as much data as possible to the profiler, to find the real bottle-neck.  &lt;/li&gt;
&lt;li&gt;Make sure that every group of data is representative(典型的，可重现的).  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item17 consider to use Lazy Evaluation(缓式评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First of all, let me quote a sentence：  &lt;blockquote&gt;
&lt;p&gt;从效率的观点来看，最好的运算是从未被执行的运算。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Lazy evaluation means you should write your class in the way that calculation should be made only when it's urgent.&lt;br /&gt;
Three usages:&lt;br /&gt;
1.reference counting&lt;br /&gt;
Maybe some copy behaviour is no use.  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//need not malloc and copy,just assign a pointer  &lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConvertToUpper&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//need to malloc and copy  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.lazy fetching&lt;br /&gt;
Maybe a large table only need a small part.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LargeObject&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;LargeObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//just assign private pointers to 0  &lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;field1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//connect to the database and fetch data  &lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;field2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;oid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fieldValue1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filedValue2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.lazy expression evaluation&lt;br /&gt;
Maybe you just need to calculate some parts.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//just store two pointers to m2 and m3,and a enum indicating it&amp;#39;s addition  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//only calculate the fourth line//define operator[]  &lt;/span&gt;
&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//have to change m1,which has a pointer to m2.//reload operator+  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Don't over do it.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item18 consider to use Over-Eager Evaluation(超急评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Two usages:&lt;br /&gt;
1.caching  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="nf"&gt;CubicleNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Cubicle&lt;/span&gt; &lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//访问数据库耗时，访问缓存快速  &lt;/span&gt;
    &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*get info from the databse and update cubes*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//more portable than it-&amp;gt;second}  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.prefetching&lt;br /&gt;
when it needs x spaces, allocate 2x spaces.//系统调用（operator new中malloc）耗时，调用进程内函数快速&lt;br /&gt;
* Trade space for time.  &lt;/p&gt;
&lt;h2&gt;Item19 understand the sources of Temporary Objects&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++真正的临时对象是不可见的，不会在代码中出现。在代码中出现的是局部对象（特别是未命名局部对象）。  &lt;/li&gt;
&lt;li&gt;产生临时对象两种情况：&lt;br /&gt;
1.对象传入reference-to-const参数，而对象需要隐式类型转换才能被参数接受。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:reference-to-non-const参数不能接受需要隐式类型转换的对象，因为参数可能会在函数中被修改，而修改仅仅作用于临时对象，C++禁止这种行为，编译失败，报错&lt;code&gt;invalid initialization of non-const reference of type ‘std::string&amp;amp; {aka std::basic_string&amp;lt;char&amp;gt;&amp;amp;}’ from an rvalue of type ‘char*’&lt;/code&gt;&lt;br /&gt;
2.返回对象。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item20 降低返回值临时对象的成本return value optimization(RVO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;书上说在return表达式中，返回匿名局部对象（比如&lt;code&gt;return Rational(lhs.num()*rhs.num(),lhs.den()*rhs.den())&lt;/code&gt;），可以让编译器进行返回值优化（消除匿名对象以及返回值临时对象的构造和析构函数成本。&lt;code&gt;Rational c=a*b;&lt;/code&gt;中仅有c的构造成本）。  &lt;/li&gt;
&lt;li&gt;注释又说“1996年ISO/ANSI标准委员会又宣布，命名对象和匿名对象都可以借助RVO被优化去掉。”后者可能在编译器下具备更好的优化性能。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item21 消除参数临时对象的成本use overload&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以重载一堆函数，来代替隐式类型转换，来消除参数临时对象的构造和析构成本。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:每个重载操作符，都必须获得至少一个“用户定制类型”的自变量。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item22 操作符符合形式效率&amp;gt;独身形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果编译器无法进行RVO，那么operator+运算，会构造并析构两个对象：局部对象和返回值临时对象。替换成类内成员函数operator+=，则无需构造这两个对象。  &lt;/li&gt;
&lt;li&gt;可行的方案是：类内定义operator+=，类外定义模版operator+（使用对象的operator+=）。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:匿名对象比命名对象容易被消除，所以尽量选择前者。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item23 考虑使用其他程序库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用benchmark(性能评估软件)，判断某个程序库在特定软件里，性能如何，然后做出取舍。  &lt;/li&gt;
&lt;li&gt;iostream比stdio的速度慢20%~200%，程序大小也大很多，但是如果io不是瓶颈，不需要用stdio代替iostream，毕竟类型安全。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item24 了解虚函数等的成本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;看完Inside C++ Object Model回来看，现在看的不是很透彻。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(2)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html" rel="alternate"></link><updated>2013-10-18T14:53:19+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-18:posts/2013/10/EffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item 05: Know what functions C++ silently writes and calls&lt;/h2&gt;
&lt;p&gt;1.默认生成的4种函数，都是public+inline类型的。  &lt;br /&gt;
2.复制构造函数原型：&lt;code&gt;Empty(const Empty&amp;amp;);&lt;/code&gt; 赋值操作符原型：&lt;code&gt;Empty&amp;amp; operator=(const Empty&amp;amp;);&lt;/code&gt; 为了和内置类型的赋值操作意义相同，返回左值的引用  &lt;br /&gt;
3.唯有这4个函数被调用时，才被产生出来。  &lt;br /&gt;
4.默认产生的析构函数是non-virtual的，除非base class是virtual的。  &lt;br /&gt;
5.3种情况下，赋值操作符不会自动生成：含有const成员，含有ref成员，base class的赋值操作符号是private（这时候，子类无法调用父类的赋值操作符）。    &lt;/p&gt;
&lt;h2&gt;Item 06: Explicitly disallow the use of compiler-generated functions you do not want&lt;/h2&gt;
&lt;p&gt;1.使拷贝构造函数和赋值操作符不可用，两种方式：&lt;br /&gt;
(1)声明为private，且不给予实现。 不论类外（编译错误），还是类内或友元（链接错误），都不能访问这些函数。&lt;br /&gt;
注：此方法可以让任何类成员函数，不能被访问。如果是构造函数，则不能构造对象。&lt;br /&gt;
(2)父类的成员函数是private的。  不论什么继承方式，都在子类中不可见。而拷贝构造和赋值操作都需要调用父类的同类方法，此时编译器无能为力只能不自动生成。访问这些函数将导致编译错误。&lt;br /&gt;
注：同上一item的第5点  &lt;/p&gt;
&lt;h2&gt;Item 07： Declare destructors virtual in polymorphic base classes&lt;/h2&gt;
&lt;p&gt;1.delete父类指针或引用的时候，如果不是virtual析构函数，结果是未定义的。很可能的结果是，只调用了父类的析构函数，对象局部销毁，会造成内存泄露。&lt;br /&gt;
因此，多态基类，一定要定义虚析构函数。&lt;br /&gt;
2.不用于多态基类时，最好不要加上virtual属性，否则会增加一个指针的大小。&lt;br /&gt;
为实现virtual机制，对象需要携带一个vptr(虚表指针)，指向vtbl（虚表，函数指针的数组），用来在运行期间动态确定哪个virtual函数被真正调用。&lt;br /&gt;
3.C++不提供“禁止继承”的机制，Java中final class，或C#中sealed class提供此机制。&lt;br /&gt;
4.尽量不要继承STL容器等包含non-virtual析构函数的类，因为一旦使用多态机制，结果未定义或内存泄露。&lt;br /&gt;
5.需要抽象基类，并且手头没有纯虚函数时，定义纯虚析构函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//声明  &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//定义  &lt;/span&gt;
&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt; &lt;span class="c1"&gt;//之所以需要这个，是因为子类析构时需要调用父类析构函数，不定义会链接错误  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 08: Prevent exceptions from leaving destructors&lt;/h2&gt;
&lt;p&gt;1.析构函数抛出2个异常，可能导致程序终止，或未定义行为。使用标准库容器（set,list）或数组，很容易造成这种情况。所以一定不要让析构函数抛出异常。&lt;br /&gt;
2.正确的做法：提供用户调用可能抛出异常的函数，同时在析构函数里调用该函数，但是捕获其异常。这样用户不仅可以自己捕获异常，也能享受万一忘记调用close，析构函数帮助其close的好处。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;  
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
          &lt;span class="n"&gt;try&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
          &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*记录该事件；要么结束程序要么吞下异常*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(1)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-15T15:20:21+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/EffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;【补充概念】&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;类型安全&lt;/strong&gt;：&lt;br /&gt;
&lt;em&gt;MSDN上的权威解释&lt;/em&gt;：类型安全，意味着每个变量、函数参数和函数返回值存储到可接受的数据，并且，涉及不同类型的值“的操作有意义”和不导致数据丢失、位组合的解释不正确或内存损坏。&lt;br /&gt;
&lt;em&gt;简单理解&lt;/em&gt;：编译器会帮助程序员检查程序中是否使用了合适的类型，即如果程序员使用了不正确的类型，编译器会报错，而不会把错误留到运行时。&lt;br /&gt;
printf，memcpy，#define 宏定义函数就不是类型安全的。&lt;br /&gt;
(1) printf("The meaning of life is %s",42);  》》》类型安全的cout&lt;br /&gt;
(2) SomeClass a;AnotherClass b;&lt;br /&gt;
   memcpy((void&lt;em&gt;)&amp;amp;a,(void&lt;/em&gt;)&amp;amp;b,sizeof(b)); 》》》类型安全的copy constructor&lt;br /&gt;
(3) #define max(a,b) ((a)&amp;gt;(b)?(a):(b))  &lt;br /&gt;
   max(15,"abc");max(a++,b); 》》》类型安全的template inline函数（同样效率，函数可预料行为，类型安全）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Item 02: Prefer const, enum, and inline to #define&lt;/h2&gt;
&lt;p&gt;1.除非我有一个很好的理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。&lt;br /&gt;
2.头文件里定义字符串常量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//或 char const * const str=&amp;quot;hello&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺第1个const，&lt;code&gt;warning： deprecated conversion from string constant to ‘char*’&lt;/code&gt; 
缺第2个const，如果两个源文件引用该头文件，会&lt;code&gt;multiple definition&lt;/code&gt;的错误&lt;br /&gt;
3.类关键字：&lt;br /&gt;
一般情况，只允许声明处出现一次：explicit,static,virtual,默认实参&lt;br /&gt;
特殊的2个，inline：出现在任一处都行，一般写在定义处；const：两处都要出现。&lt;br /&gt;
4.&lt;code&gt;#define&lt;/code&gt;宏定义完全可以被代替。const代替常量宏，template inline函数代替函数宏。&lt;br /&gt;
此外，static const可以定义类属常量，这是#define做不到的。&lt;br /&gt;
5.static const类属常量，如果是整数类型（char，short，int，bool等），可以在声明时直接赋值，只要不取地址都可以直接使用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果非整数类型（如double），如果需要取地址，如果编译器比较旧，需要在源文件中定义，给初值。&lt;br /&gt;
如果非要在编译时使用，编译器还不允许，可以使用enum hack的方法  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.需要一组常量的时候，可以使用枚举，用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;March&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;April&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//枚举类型可以被枚举值赋值&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Third&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//整数类型也可以被枚举值赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 03: Use const whenever possible&lt;/h2&gt;
&lt;p&gt;1.const可作用于任何作用域范围的对象、函数参数、函数返回类型、成员函数本身。&lt;br /&gt;
2.函数返回类型+const的意义，限制返回值再被赋值：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;防止  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过编译&lt;br /&gt;
3.将const作用于成员函数，保证该成员函数可以被const对象调用。&lt;br /&gt;
4.const成员函数可以"重载"非const成员函数。虽然const成员函数也可以被non-const对象调用，但是重载后，定义const和non-const对象，调用的同一个函数原型，效果就不一样了。如果返回引用类型或非内置类型，一个可以被赋值，一个不可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原理：&lt;br /&gt;
重载函数的确定，先找到candidate函数（名字相同），再找到viable函数（参数列表符合），再确定best match。&lt;br /&gt;
const成员函数内隐藏的this指针是&lt;code&gt;const type *&lt;/code&gt; 类型，而非const成员函数的则是&lt;code&gt;type *&lt;/code&gt; 。因此，const重载的实质是参数类型不同。&lt;br /&gt;
所以，非const对象优先调用非const函数（最佳匹配），没有的时候才调用const函数。&lt;br /&gt;
5.函数返回内置类型，不能做左值；函数返回自定义类型，或引用类型（内置或自定义），可以做左值。&lt;br /&gt;
6.被mutable声明的变量，即使在const成员函数内，也可以修改。这样可以实现概念上的const函数，而不是bitwise上的const函数。&lt;br /&gt;
举例：类里保存cache缓冲区的指针。每次调用length()函数读取cache缓冲区大小的时候，都要重新计算一下。
7.重复代码：编译时间、维护、代码臃肿问题。&lt;br /&gt;
在operator[]函数里调用const operator[]函数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;                      &lt;span class="c1"&gt;//C++中仅有这一种方式  &lt;/span&gt;
     &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;//也可以用const_cast代替,不转换成const对象会无限递归调用自己，段错误~  &lt;/span&gt;
     &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 04: Make sure that objects are initialized before they're used.&lt;/h2&gt;
&lt;p&gt;1.类成员变量中的自定义类型，在构造函数语句执行之前，已经调用过默认构造函数初始化自身了。所以，为了效率，应该使用初始化列表，然后构造函数语句体为空。代价（默认构造函数+赋值操作）&amp;gt;代价（1个构造函数）。&lt;br /&gt;
类成员变量中的内置类型，构造函数语句执行之前一般不会初始化，而且初始化和赋值效率相同，所以放在哪里一样。代价（1次初始化）=代价（1次赋值）。&lt;br /&gt;
2.内置类型为const或引用，必须初始化，不能赋值。&lt;br /&gt;
3.static对象，包括global对象，namespace作用域内对象，类内静态对象，函数内静态对象（local static对象）。&lt;br /&gt;
寿命：从运行中被构造出来，直到main()结束自动调用析构。&lt;br /&gt;
4.&lt;br /&gt;
原理：C++对定义于不同编译单元内的non-local static对象的初始化相对次序，没有明确定义。&lt;br /&gt;
导致的问题：先构造的对象，在构造函数中引用了后构造的对象，此时该对象还没有初始化。&lt;br /&gt;
解决：以函数调用（返回local static对象的引用），替代直接访问non-local static对象。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;getobj&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;C1&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++保证，函数内local static 对象会在该函数被调用期间，首次遇上该对象的定义式时被初始化。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>两个类定义相互转换时的二义性</title><link href="http://particle128.com/posts/2013/10/inter-convert.html" rel="alternate"></link><updated>2013-10-15T15:16:41+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/inter-convert.html</id><summary type="html">&lt;p&gt;两个类，分别定义了到对方的转换，隐式使用这种转换的时候，一般会出现二义性。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;converting constructor&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;conversion function&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据C++Primer P460的讲解，很显然这段代码在编译时会报二义性（ambiguous）的错误。原因在于：conversion constructor和conversion operator并没有高下之分，所以在Y类型转换成X类型的时候，出现了二义。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果X的构造函数和Y的转换操作符变成如下声明形式：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认operator X()是最佳匹配。原因在于：如果要调用X的构造函数，那么需要首先进行标准转换（Y-&amp;gt;const Y）；而如果调用operator X则免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果声明式改成：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认X(Y&amp;amp;)是最佳匹配。原因在于：const函数的this指针是const Y &lt;em&gt;const，因此首先需要一个标准转换（Y &lt;/em&gt;-&amp;gt;const Y *）；而如果调用前者，免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;诡异的事情来了，如果声明式是：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们按照前面的推理过程，应该的得这是一个二义性的代码，因为都需要一个标准转换在调用类类型转换之前。但是g++神奇的没有报错就选择了X(const Y&amp;amp;)这个函数作为转换函数。百撕不得骑姐，甚至怀疑刚才我的推理都错了，终于在stackoverflow上找到了解答，&lt;a href="http://stackoverflow.com/questions/1384007/conversion-constructor-vs-conversion-operator-precedence"&gt;链接&lt;/a&gt; &lt;br /&gt;
这应该是g++不符合C++标准的地方，是它的一个策略：在这个都需要const转换的"二义性"情况下，默默吞掉二义性而选择conversion constructor作为最佳匹配。如果想看到二义性错误，只要使用&lt;code&gt;g++ -pedantic&lt;/code&gt;命令，pedantic的意思是迂腐的,学究式的。  &lt;/p&gt;
&lt;h3&gt;之前讨论的是隐式转换，如果是强制类型转换呢？&lt;/h3&gt;
&lt;p&gt;在测试的时候发现：如果既有构造函数，又有转换操作符，使A类对象转化为B类对象，如下3种强制类型转换方法都偏向于构造函数，除非构造函数不存在的时候，才调用转换操作符进行转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B(A)&lt;/li&gt;
&lt;li&gt;(B)A&lt;/li&gt;
&lt;li&gt;static_cast&lt;B&gt;(A)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：强制类型转换不看最佳匹配，所以即使构造函数的代价比转换操作符代价大，比如const constructor和non-const operator，也是如此。&lt;/p&gt;
&lt;p&gt;花了好久才涨了这点姿势，不过得出一个结论：&lt;strong&gt;纸上得来终觉浅，绝知此事要躬行&lt;/strong&gt;。  &lt;/p&gt;</summary><category term="conversion"></category><category term="cpp"></category></entry><entry><title>程序员的自我修养 笔记</title><link href="http://particle128.com/posts/2013/10/ziwoxiuyang.html" rel="alternate"></link><updated>2013-10-14T11:11:55+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/ziwoxiuyang.html</id><summary type="html">&lt;h2&gt;Chapter 2&lt;/h2&gt;
&lt;p&gt;所谓“编译”（gcc 1.cpp），实际上包括预处理，编译，汇编，链接。&lt;br /&gt;
gcc命令实际是后台程序的包装，包装了cc1预处理，as汇编，ld链接器&lt;br /&gt;
[1]预处理   主要处理预处理指令（#开头的），主要工作如下：&lt;br /&gt;
宏展开; 头文件插入 ; 删除注释 ； 添加行号和文件标识 。 &lt;br /&gt;
gcc -E 1.cpp -o 1.i             阅读.i文件，可以查看宏展开是否正确&lt;br /&gt;
[2]编译  把源文件生成汇编代码 (调用cc1)&lt;br /&gt;
gcc -S 1.i -o 1.s   或直接gcc -S 1.cpp -o 1.s&lt;br /&gt;
[3]汇编   把汇编代码转化成机器指令，即目标文件 (调用as)&lt;br /&gt;
gcc -c 1.s -o 1.o  或直接 gcc -c 1.cpp -o 1.o&lt;br /&gt;
[4]链接  把目标文件、库链接起来，生成可执行文件（调用ld）&lt;br /&gt;
gcc 1.o -o 1  或直接 gcc 1.cpp -o 1&lt;br /&gt;
简记：ESc   iso  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程&lt;/strong&gt;：&lt;br /&gt;
前端：跟机器无关&lt;br /&gt;
词法分析、语法分析、语义分析（给语法树的节点添加类型，主要工作是：声明和类型的匹配，类型的转换）、中间语言生成（包含优化，比如生成三地址码）&lt;br /&gt;
后端：跟机器有关&lt;br /&gt;
目标代码生成、优化  &lt;/p&gt;
&lt;h2&gt;Chapter 3       目标文件（统称）&lt;/h2&gt;
&lt;p&gt;[1] linux下目标文件和可执行文件的格式均为ELF格式。具体分类：&lt;br /&gt;
relocatable file：目标文件（.o）、静态链接库（.a）&lt;br /&gt;
executable file：可执行文件（无后缀）&lt;br /&gt;
shared object file：动态链接库（.so）&lt;br /&gt;
[2] ELF文件中数据和指令分别存放在不同的段里。原因如下：&lt;br /&gt;
（1）程序被装载后，数据和指令被映射到两个不同的虚存区域（一个可读写，一个只读），这样可以防止修改指令。&lt;br /&gt;
（2）现代cpu的cache分为指令缓存和数据缓存，提高cpu缓存命中率。&lt;br /&gt;
（3）系统中运行同一个程序的多个副本时，可以共享指令部分，但是数据部分必须一个副本拥有一份。&lt;br /&gt;
[3] 程序的指令部分放在.text段中，初始化的全局数据和局部i静态数据放在.data段中，未初始化的全局数据和局部静态数据放在.bss段中（虚拟的，不占用空间）。&lt;br /&gt;
[4] 查看目标文件中各种信息的方式：&lt;br /&gt;
objdump -h  显示各个段的基本信息&lt;br /&gt;
objdump -x  显示各个段的基本信息，显示符号表、重定位表的信息&lt;br /&gt;
objdump -s  将段的内容以16进制打印，   -d  显示指令段反汇编之后的汇编代码&lt;br /&gt;
readelf -h  查看ELF文件头 &lt;br /&gt;
readelf -S  查看段表（section header）&lt;br /&gt;
readelf -s  查看符号表&lt;br /&gt;
[5] 文件头&lt;br /&gt;
包含段表地址（相对于文件头）、段表大小、段表字符串表的索引（所有段从0开始编辑索引）&lt;br /&gt;
[5] 符号表&lt;br /&gt;
在链接中，函数和变量统称为符号（symbol），函数名和变量名就是符号名。&lt;br /&gt;
符号表中存在 定义在本目标文件中的全局符号(&lt;code&gt;global_var&lt;/code&gt;)，以及，在本目标文件中引用的全局符号(printf,&lt;code&gt;extern_var&lt;/code&gt;)。&lt;br /&gt;
[6] 字符串表（包括字符串表strtab和段表字符串表shstrtab）&lt;br /&gt;
表中就是一个接一个的存放字符串（以\0结尾），在符号表和段表中的某些需要用字符串来表示的信息（比如符号名、段名），是通过字符串在字符串表中的偏移来引用的。&lt;br /&gt;
[7] C++支持函数重载，即相同函数名的函数，可以根据参数列表（个数、类型）来区分。C++支持命名空间（类也属于），在不同命名空间可以有同样名字的符号。为了支持这一点，C++中的符号名（函数、全局变量）需要进行“名称修饰”，修饰后的名称叫“修饰后名称”（Decorated Name）。目标文件中的符号名即为修饰后名称。&lt;br /&gt;
&lt;code&gt;int N::C::func(int)&lt;/code&gt; 在gcc下的修饰后名称为&lt;code&gt;_ZN1N1C4funcEi&lt;/code&gt;，&lt;code&gt;_Z&lt;/code&gt;开头，N和E标识命名空间开始和结尾，i是参数&lt;br /&gt;
断开方式为：&lt;code&gt;_Z N 1N 1C 4func E i&lt;/code&gt;。数字标识后面的命名空间有几个字符。&lt;br /&gt;
在VC++下的修饰后名称为&lt;code&gt;?func@C@N@@AAEHH@Z&lt;/code&gt;。&lt;br /&gt;
函数返回的变量类型，并没有加入符号的修饰后名称中，所以，不能通过函数返回类型进行重载。&lt;br /&gt;
[8] C中没有名称修饰（name mangling）的概念，所有符号定义的名称（func）即为目标文件中的符号名称（func）。&lt;br /&gt;
C++中为了兼容使用C的库，头文件需要添加&lt;code&gt;extern "C" { void *memset(void*, int , size_t); }&lt;/code&gt;。&lt;br /&gt;
该关键字表明，后面的符号不使用“名称修饰”。这样，在C++中调用C的库memset可以正常使用，否则修饰后的名称和C语言库中未修饰的名称不一致，会提示链接错误。&lt;br /&gt;
[9] 强符号：函数、初始化的全局变量                 弱符号：未初始化的全局变量、用&lt;code&gt;__attribute__((weak))&lt;/code&gt;修饰的变量/函数&lt;br /&gt;
选择多次定义的全局符号    规则如下：&lt;br /&gt;
（1）不允许强符号多次定义&lt;br /&gt;
（2）多个文件中只有一个强符号，则选择强符号&lt;br /&gt;
（3）都是弱符号，选择空间最大的&lt;br /&gt;
[10] 强引用：默认             弱引用：用&lt;code&gt;__attribute__((weakref))&lt;/code&gt;修饰的引用&lt;br /&gt;
强引用的符号，链接时找不到，报链接错误;&lt;br /&gt;
弱引用的则不报错，使用地址0给那个未找到的符号赋值，运行时调用的话会出错。&lt;br /&gt;
[11] 调试信息在目标文件中占的空间（多了需要.debug开头的段），往往比代码和数据大的多，发布之前去除：strip  a.out  &lt;/p&gt;
&lt;h2&gt;Chapter4     静态链接&lt;/h2&gt;
&lt;p&gt;[1] .bss段在可执行文件中不占用空间，但是在装载后，要占用虚拟地址空间。&lt;br /&gt;
.bss段内的数据起初都是0,所以文件不必分配空间，但是运行中可能赋值，所以内存中需要空间。&lt;br /&gt;
[2] &lt;code&gt;ld a.o b.o -e main -o ab&lt;/code&gt;，-e参数表明main函数作为程序入口，否则ld链接器默认&lt;code&gt;_start&lt;/code&gt;作为入口。&lt;br /&gt;
[3] 链接两步：1.空间与地址的分配（合并目标文件[比如符号表合并成全局符号表]，分配虚拟地址）  2.符号解析与重定位（符号表中的und类型的符号在全局符号表中查找，修正代码中的地址）&lt;br /&gt;
第一步：链接之后，段表中各个段的属性VMA（Virtual Memory Address）被分配了虚拟内存地址。链接之前该属性均为0.链接之后，符号表中符号的value值变为虚拟内存地址。链接之前为想对于段的偏移。&lt;br /&gt;
第二步：链接之后，代码中的地址（外部函数和变量的引用）由默认值（0之类的）修正为实际的虚拟内存地址。&lt;br /&gt;
[4] 静态库，即目标文件的打包。ar -t libc.a可以查看包含的目标文件&lt;br /&gt;
链接库的过程：搜索库（xx.a）中所有目标文件（xx.o）的符号表，把被引用的符号存在的那个目标文件包含进可执行文件。如果被引用目标文件，还引用了其他目标文件的符号，再递归包含其他目标文件。&lt;br /&gt;
[5] 静态运行库libc.a里面一个目标文件只包含一个函数，比如printf.o，strlen.o等。&lt;br /&gt;
原因：链接器在链接静态库的时候，是以目标文件为单位的，引用了哪些目标文件中的符号（当然包括间接引用的符号），就链接哪些目标文件，库中其余的目标文件都丢弃。函数独立成目标文件，有利于减少目标文件的大小。  &lt;/p&gt;
&lt;h2&gt;Chapter7     动态链接&lt;/h2&gt;
&lt;p&gt;[1] dl好处：节省磁盘和内存空间（多个可执行文件都引用同一个模块的话，内存和磁盘上只需要保留一份）; 使软件更新之后发布更加方便（只下载并覆盖更新了的模块，而不是整个软件）。&lt;br /&gt;
[2] 动态链接，是把链接的过程推迟到了程序装载的时候，但是性能的损失不大，利远大于弊。&lt;br /&gt;
[3] &lt;code&gt;gcc -fPIC -shared -o xxx.so xxx.c&lt;/code&gt;  其中-shared表示共享对象，-fPIC（position independent code）表示地址无关代码，这是动态链接中的一种机制。&lt;br /&gt;
[4] &lt;code&gt;gcc -o -L/path/to/libyyy.so Program Program1.c ./xxx.so -lyyy&lt;/code&gt; &lt;br /&gt;
注意，动态链接库xxx.so，libyyy.so也要作为输入文件之一。这样链接器对Program1.c中引用的外部符号，就可以进行特殊处理，使它成为一个对动态符号的引用。否则ld会报错：未定义的引用。&lt;br /&gt;
gcc或ld，如果显示加上-static参数，-lyyy会查找libyyy.a，属于静态链接。ld如果使用-dynamic-linker参数（默认），-lyyy会查找最新版本的libyyy.so.x.y.z，属于动态链接。（静、动态链接查找目录包括：标准库目录，-L参数指定的目录，&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录）&lt;br /&gt;
注意：：但是编译动态库的时候，可以不加它所依赖的共享库，因为动态库不会直接执行。但是所有调用该动态库的程序，在编译的时候都要加上动态库所依赖的库。最标准的做法是，编译动态库的时候，也加上它所依赖的库。&lt;br /&gt;
[6] ldd xxx.so  查看共享对象的依赖&lt;br /&gt;
[7] 显式运行时链接，即调用动态链接器提供的api在程序中进行链接装载。好处是，减少程序的启动时间，支持插件的动态加载、删除和更新等。&lt;br /&gt;
api：dlopen（可以通过参数设置延迟绑定，当通过dlsym加载的函数第一次被使用时才进行绑定，而不是当模块被加载时就完成所有函数的绑定）,dlsym,dlclose,dlerror  &lt;/p&gt;
&lt;h2&gt;Chapter8    linux共享库的组织&lt;/h2&gt;
&lt;p&gt;[1] 共享库，动态链接库，共享对象，可以看作是同一个概念&lt;br /&gt;
[2] 版本命名：libname.so.x.y.z。&lt;br /&gt;
主版本号x表示库的重大升级，不同主版本号的库之间不兼容。&lt;br /&gt;
次版本号y表示库的增量升级，增加一些新的接口符号，但是原符号保持不变，向后兼容。&lt;br /&gt;
发布版本号z表示库的一些错误修正和性能改进，接口符号完全保持不变，互相兼容。&lt;br /&gt;
[3] Linux和Solaris系统中，采用SO-NAME的命名机制。每个共享库都对应一个SO-NAME，即共享库名去掉次版本和发表版本号之后的名字（xx.2.1.12 -&amp;gt; xx.2）。&lt;br /&gt;
共享库管理程序ldconfig，会自动在标准库目录（/usr/lib,/lib）和/etc/ld.so.conf配置文件中制定的目录（包括/usr/local/lib）下搜索，建立以"SO-NAME"为名的软链接，指向目录中主版本号相同、其他版本号最新的共享库。&lt;br /&gt;
当系统中安装或更新一个共享库时，需要运行ldconfig一下，以便更新"SO-NAME"的软链接，指向最新版本的共享库。&lt;br /&gt;
[4] 动态链接的模块所依赖的模块的路径保存在.dynamic段里面（编译的时候写入的，所以编译需要把共享库也作为输入文件）。.dynamic里如果保存的模块路径是绝对路径，动态链接器直接去加载即可。如果保存的是相对路径，依次搜索下面几个目录：&lt;br /&gt;
0)  传递给ld的参数-rpath指定的目录&lt;br /&gt;
1）&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录  &lt;br /&gt;
2）/etc/ld.so.cache指定的库路径（ldconfig执行的时候，除了建立SO-NAME软链接外，还在ld.so.cache中保存这些软链接的信息，方便动态链接器查找共享库）。（包括/usr/local/lib目录下的库）&lt;br /&gt;
3）/usr/lib，/lib。&lt;br /&gt;
[5] 环境变量&lt;code&gt;LD_PRELOAD&lt;/code&gt;里指定的文件会在动态链接器按照固定规则搜索共享库之前装载，无论程序是否依赖他们。由于“全局符号介入”机制，这里面的库中定义的符号，会让后来再加载的库中定义的同名符号失效。&lt;br /&gt;
[6] &lt;code&gt;gcc -W1,-soname,my_soname&lt;/code&gt;，-W1参数表示将指定参数传递给链接器。-soname参数指定共享库的SO-NAME，否则建立的共享库没有SO-NAME，ldconfig不会理睬这个库。  &lt;/p&gt;</summary><category term="link"></category><category term="load"></category></entry><entry><title>C++提供的数据封装，只是访问控制，而不是信息隐藏</title><link href="http://particle128.com/posts/2013/10/cpp-encapsulation.html" rel="alternate"></link><updated>2013-10-14T09:25:05+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/cpp-encapsulation.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;C++通过private，protected和public提供的encapsulation并不是information hiding，而是access specifier。因为C++中类的定义比如放在头文件中，所有private数据类型也都暴露在用户下了。  &lt;/li&gt;
&lt;li&gt;C#，Java中类的定义（private数据成员）在源文件里，因此用户如果要访问这个类，using 对应的namespace，只能接触到public成员，private里有什么根本无从知晓。&lt;br /&gt;
甚至C语言的struct，如果把实现放在源文件，也让结构体访问者无法得知其实现，只能通过一些API来访问。例子来自wiki百科&lt;a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)"&gt;Encapsulation词条&lt;/a&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Header file &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Opaque structure with hidden members  &lt;/span&gt;
&lt;span class="c1"&gt;// API functions that operate on &amp;#39;Entity&amp;#39; objects  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  



&lt;span class="c1"&gt;// Implementation file &amp;quot;api.c&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ent_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// ID number  &lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ent_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Name  &lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;// API function implementations  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category><category term="encapsulation"></category></entry><entry><title>Effective C++学习笔记(8)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html" rel="alternate"></link><updated>2013-10-13T20:15:25+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(8).html</id><summary type="html">&lt;h2&gt;Item 30: Understand the ins and outs of inlining.&lt;/h2&gt;
&lt;p&gt;1.inline（函数体代替函数调用）的好处：&lt;br /&gt;
（1）没有函数调用的开销，速度快。&lt;br /&gt;
（2）使编译器能对起进行outlined的函数所不具备的优化，因为上下文更明显了。&lt;br /&gt;
坏处：&lt;br /&gt;
（1）可能导致代码膨胀，如果inline函数内语句比较多的话。&lt;br /&gt;
（2）如果inline函数是程序库的一部分，对它的改动，需要使用者重新编译。（outline的话，直接链接即可，动态链接的话，使用者甚至不知道函数库的修改）&lt;br /&gt;
（3）大部分调试器不能调试inline函数。&lt;br /&gt;
2.inline是对编译器的申请，不是强制。&lt;br /&gt;
如下情况编译器”可能“拒绝inline（gcc -Winline会发出不能inline的警告，但是我尝试了递归和循环，没有发出警告）：&lt;br /&gt;
（1）函数太过复杂（包含递归或循环）。&lt;br /&gt;
（2）函数中调用virtual函数，因为多态是运行期行为，而inline是编译期行为。&lt;br /&gt;
如下情况提供outline版本：&lt;br /&gt;
（1）通过函数指针调用inline函数。因为如果inline函数没有outline版本的话，就没有函数地址了。&lt;br /&gt;
3.除了显示inline，类成员函数和右元函数定义与class内，也是inline函数&lt;br /&gt;
4.inline函数的函数体，通常应定义于头文件内，保证编译时可以用函数体替换函数调用。因为大多数C++编译器实现中，inling行为是编译行为。&lt;br /&gt;
5.构造和析构不适合inline。因为里面有编译器加入的代码（比如构造数据成员，出错就析构之前构造的成员），往往代码量不小，导致代码膨胀。  &lt;/p&gt;
&lt;h2&gt;Item 31: Minimize compilation dependencies between files.&lt;/h2&gt;
&lt;p&gt;1.降低文件间的编译依赖性（低耦合）的好处：&lt;br /&gt;
实现有所改变的时候，如果接口（类的public成员）没有改变，那么客户代码不用重新编译。&lt;br /&gt;
2.C++中类的定义，并没有“将接口从实现中分离”做的很好。因为类定义中，私有成员也会出现在头文件中。&lt;br /&gt;
类定义的头文件中仅仅包括前置声明（class Date;），然后在源文件中定义（Date Person::theBirthDate;）是行不通的。因为编译时，需要知道一个类型占据多大的内存，而编译器不会去查看源文件中的具体实现，仅仅查看头文件的类定义，所以必须在类定义中出现。&lt;br /&gt;
3.编译依赖性比较大的例子：&lt;br /&gt;
（0）具象类（concrete class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Date.h&amp;quot; &lt;/span&gt;&lt;span class="c1"&gt;//引入类型定义式  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Address.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;theName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;theBirthDate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="n"&gt;theAddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：Date或Address的修改，Person需要重新编译，继而Person的客户也要重新编译。Person实现的修改（比如增加或减少了成员变量），Person客户要重新编译，即使接口没有改变。&lt;br /&gt;
两种解决办法：&lt;br /&gt;
（1）句柄类（handle class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：大部分都是前置声明  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//实现细节隔离到了PersonImpl中，所以PersonImpl的实现改变后，不影响Person的客户  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//类型声明式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//使用对象的指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：需要引入一些头文件中的类型定义  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Person.h&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;PersonImpl&amp;quot;   &lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)){}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只靠"类型声明式"(class Date)就可以定义该类型的引用或指针；必须提供"类型定义式"(#include "Date.h")才可以定义该类型的对象。  &lt;/li&gt;
&lt;li&gt;声明一个函数，如果函数的参数或返回值是某自定义类型的（比如Date），只包含其类型声明式即可（class Date）。  &lt;/li&gt;
&lt;li&gt;程序库作者应该提供两种头文件：类型声明式(datefwd.h)和类型定义式(Date.h)。客户在声明包含该类型的函数时，只需包含datefwd.h即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）接口类（interface class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//抽象类   &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//全部是纯虚函数  &lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//工厂函数，返回智能指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;RealPerson.h&amp;quot;  &lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RealPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较（个人观点）：&lt;br /&gt;
（1）易用性&lt;br /&gt;
handle class更易用： Person p1(...); string name=p1.getName()&lt;br /&gt;
interface class不好用：std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(...)); string name=pp-&amp;gt;getName();&lt;br /&gt;
（2）扩展性&lt;br /&gt;
handle class没法扩展。&lt;br /&gt;
interface class方便扩展，基类可以有多个相同接口的派生类。比如create中增加一个参数，可以选择create哪个派生类。&lt;br /&gt;
4.句柄和接口类，会速度降低、内存消耗增大，但是的确可以带来松耦合的好处。&lt;br /&gt;
原则：开发过程中，用句柄和接口类；当它们导致的性能损失比较严重时，改成具象类。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(12)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html" rel="alternate"></link><updated>2013-10-13T20:09:29+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(12).html</id><summary type="html">&lt;p&gt;关于new和delete的东西，笔记不够详尽，因为新知识比较多，不太方便记录笔记。发现相关知识漏洞的时候，再去查看Cpp Primer和Effective Cpp相关章节。  &lt;/p&gt;
&lt;h2&gt;Item 49: Understand the behavior of the new-handler&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;std::set_new_handler()&lt;/code&gt;可以绑定一个&lt;code&gt;new_handler&lt;/code&gt;（类型为&lt;code&gt;void (*)()&lt;/code&gt;），即new获取不到所需内存时调用的客户定制函数。如果不设置函数，或设置null，直接抛出异常&lt;code&gt;std::bad_alloc&lt;/code&gt;。&lt;br /&gt;
2.获取&lt;code&gt;new_handler&lt;/code&gt;函数的方式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.new_handler应该具备以下一种功能：&lt;br /&gt;
（1）让更多内存可被使用。否则::operator new会无限循环调用非空的new_handler。例如程序开始分配一个内存池，动态分配不到资源的时候释放一些资源出来。&lt;br /&gt;
（2）安装另一个可以释放更多内存的new_handler函数。&lt;br /&gt;
（3）卸除new_handler，这样::operator new就会直接throw std::bad_alloc()异常了。&lt;br /&gt;
（4）抛出bad_alloc异常。不等operator new抛，自己就抛了。&lt;br /&gt;
（5）调用exit或abort直接退出程序。  &lt;/p&gt;
&lt;h2&gt;Item 50: Understand when it makes sense to replace new and delete&lt;/h2&gt;
&lt;p&gt;重写operator new和operator delete的原因：&lt;br /&gt;
（1）检查所分配内存上的运用错误：每次new的时候，在要分配空间的前后多分配一段内存，存放签名。delete的时候检查签名是否正确。如果前面的签名错了，发生了underrun（数据写到分配内存的前面了）；如果后面的签名错了，发生了overrun（ditto）。&lt;br /&gt;
（2）收集动态分配内存的使用情况：每次new的时候都要统计一些信息，比如分配了多少，等等&lt;br /&gt;
（3）加快速度：定制版本处理的情况比通用版本少，所以速度往往更快。&lt;br /&gt;
（4）降低空间开销：通用版本往往会分配额外一些内存来保存一些信息。小型对象分配器：Boost的Pool&lt;br /&gt;
（5）弥补缺省allocator非最佳齐位（alignment）：好多编译器上的new都声称保证16bit齐位，double变量需要32bit齐位，才能获得最佳的访问速度。&lt;br /&gt;
（6）获得非传统的行为：比如delete释放的时候，空间覆盖为0.  &lt;/p&gt;
&lt;h2&gt;Item 51:Adhere to convention when writing new and deletes(固守常规)&lt;/h2&gt;
&lt;p&gt;1.自定义operator new的时候，需要注意的几点&lt;br /&gt;
（1）尽量和::operator new行为一致，即while(true)下循环尝试分配内存，如果new_handle非0就调用，否则bad_alloc&lt;br /&gt;
（2）用户分配大小为0的空间  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator new的参数  &lt;/span&gt;
     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）基类的operator new，需要首先执行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//如果new派生类的话，使用全局版本的operator new  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.自定义operator delete的时候，需要注意的几点&lt;br /&gt;
（1）用户delete一个空指针  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//ptr是operator delete的参数  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）基类的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator delete的第二个参数  &lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 52: Write placement delete if you write placement new.&lt;/h2&gt;
&lt;p&gt;1.placement new，C++ Primer上翻译为定位new，理解为：特定位置（第二个参数指定的指针位置）上的new比较好。&lt;br /&gt;
2.编写placement new的时候，也要编写对应版本的placement delete。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则，可能内存泄露。&lt;br /&gt;
因为，new表达式执行中，如果第一步operator new分配内存成功，但是构造函数抛出异常，C++运行期系统需要保证内存不发生泄露，就会自动调用&lt;strong&gt;对应版本&lt;/strong&gt;的operator delete释放内存。如果找不到对应版本的operator delete，就会造成内存泄露。&lt;br /&gt;
3.global作用域定义了3种形式的operator new和对应3种形式的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;nothrow_t&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应delete版本就是第一个参数换成void*，全部不抛出异常。&lt;br /&gt;
4.定义于类内的operator new，不管是placement还是非placement，都会掩盖全局的3个版本。如果需要使用，重写这6个函数：函数体只是调用全局作用域的版本。&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：&lt;strong&gt;不能在类内简单的using ::operator new，否则报错using-declaration for non-member at class scope。&lt;/strong&gt;只能using基类的被覆盖的名字，不能using全局的，但是可以用作用域限定符(::)调用全局的函数。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(11)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html" rel="alternate"></link><updated>2013-10-13T20:06:53+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(11).html</id><summary type="html">&lt;h2&gt;Item 44: Factor parameter-independent code out of templates&lt;/h2&gt;
&lt;p&gt;1.类模版成员函数函数，只有被使用时才被具现化。类似类的合成版本的构造/复制构造/赋值操作符/析构函数。&lt;br /&gt;
2.模版的时候减少了源代码量，但是可能导致目标代码增加，因为每具现化一个版本，就多一份目标码。&lt;br /&gt;
策略：把与模版参数（类型参数或非类型参数）无关的代码，剥离出模版类。&lt;br /&gt;
（1）非类型参数&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SquareMatrix&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//方形矩阵  &lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化一次invert  &lt;/span&gt;
&lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化第二次invert，内容和第一次的代码重复了（只是把10换成5）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义一个不含有非类型参数的基类SquareMatrixBase，含有invert函数。SquareMatrix只要调用基类invert即可。这样上面的例子就会只有1个版本的invert（基类的invert函数）。&lt;br /&gt;
（2）类型参数&lt;br /&gt;
例如：大多数平台，所有指针类型都有相同的二进制表述，模版的类型参数是指针类型的（比如vector&lt;char*&gt;，vector&lt;Date*&gt;），其成员函数应该调用唯一一份底层实现（操作void*指针的函数）。  &lt;/p&gt;
&lt;h2&gt;Item 45: Use member function templates to accept all compatible types&lt;/h2&gt;
&lt;p&gt;1.以TR1::shared_ptr为例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//由“内置指针类型”构造，但是不能隐式转换，只能通过C-style类型转换或reinterpret_cast转换（尚未验证？？？）  &lt;/span&gt;
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
          &lt;span class="p"&gt;{...}&lt;/span&gt; &lt;span class="c1"&gt;//由“任意兼容类型的shared_ptr指针”构造，可以隐式转换。如果Y和U不兼容，成员初始化列表会报错  &lt;/span&gt;
         &lt;span class="c1"&gt;//赋值操作符也要定义成员函数模版，略  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本，而不是调用上面的构造函数模版  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本。  &lt;/span&gt;
         &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 46: Define non-member functions inside templates when type conversions are desired&lt;/h2&gt;
&lt;p&gt;1.希望函数所有实参接受隐式类型转换，需要定义成非成员函数；希望模版函数被自动具现化，需要声明在类内。所以需要友元函数，且定义在类内。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//需要实现这个  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="c1"&gt;//如果定义在类外的话，不能通过编译。因为“模版实参推导过程中不进行隐式类型转换”，所以int不会通过non-explicit构造函数，隐式转换成Ratioanl&amp;lt;int&amp;gt;，使模版函数operator*以int为实参具现出来。函数在类内则不同：oneHalf的定义，以int具现出来一个Rational类，编译器产生了该友元函数的声明，且该函数不是模版函数，所以接受隐式类型转换。  &lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//在类模版内，可以把Rational&amp;lt;T&amp;gt;（模版名+参数名）简写成Rational（模版名）   &lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;//如果实现在外面的话，会链接错误。  &lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.很多编译期强迫把所有模版的定义式放进头文件里，比如模版函数的实现。  &lt;/p&gt;
&lt;h2&gt;Item 47: Use traits classes for information about types&lt;/h2&gt;
&lt;p&gt;1.STL迭代器分类&lt;br /&gt;
（1）input：istream_iterator&lt;br /&gt;
（2）output：ostream_iterator&lt;br /&gt;
（3）forward：slist（单链表，STL不包含该结构）&lt;br /&gt;
（4）bidirectional：set，multiset，map，multimap，list（双向链表）&lt;br /&gt;
（5）random_access：vector，deque，string&lt;br /&gt;
2.typeid确定一个变量的类型是运行期行为，“重载函数的最佳匹配”相当于编译期的类型确定，而且有if-else功能。&lt;br /&gt;
3.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//定义类型  &lt;/span&gt;
     &lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//引用T定义的类型  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//对指针的特化版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//随即访问指针的重载版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数不需要形参，因为没有用到  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数传入一个未命名对象，类型后跟一对括号  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 48: Be aware of template metaprogramming&lt;/h2&gt;
&lt;p&gt;1.TMP的主要意义：（1）完成一些其他方法没法实现的功能（2）将运行期的工作转移到编译期，可以提高程序执行效率。&lt;br /&gt;
2.##Item47中提到的do_advance方法，就是模版元编程里的if-else用法。用typeid没法实现（非random access iterator 没法编译通过iter+=d这句话）。&lt;br /&gt;
3.循环的用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//变量在enum里，递归调用自身  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//循环结束条件：特化模版  &lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//使用：  &lt;/span&gt;
&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(10)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html" rel="alternate"></link><updated>2013-10-13T20:05:09+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(10).html</id><summary type="html">&lt;h2&gt;Item 39: Use private inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.私有继承和复合(composition)意义相同：根据某物实现出（is-implemented-in-terms-of）。&lt;br /&gt;
2.除非必要，尽量用复合实现这种语义。&lt;br /&gt;
3.可以考虑使用private继承的情况：&lt;br /&gt;
（1）需要需要访问protected成员&lt;br /&gt;
（2）需要重写virtual函数。（替代策略:可以派生一个类，重写virtual函数。然后包含这个类的对象）&lt;br /&gt;
（3）如果需要包含的是一个空类对象，用private继承，节省空间。&lt;br /&gt;
Empty Class是指，只包含typedef，enum，statice成员变量和non-virtual函数的类。因为不含非静态成员变量和虚函数，所以一般不需要内存空间。&lt;br /&gt;
注：&lt;br /&gt;
1)类中包含一个空类对象的时候，大多数编译器至少需要1个字节的内存空间。&lt;br /&gt;
2)继承自空类对象，不需要任何内存空间。&lt;br /&gt;
4.尽量复用已有代码，所以平时注意积累自己的工具箱，设计的越通用越好，随时可以拿来复用。  &lt;/p&gt;
&lt;h2&gt;Item 40: Use multiple inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.多重继承尽量不用，因为它比单一继承复杂，比如引起二义性（ambiguity），还有可能需要虚继承（虚基类）&lt;br /&gt;
合理用途：&lt;br /&gt;
public继承一个接口类，private继承一个协助实现的类（需要复用它的一些成员，但是需要重写virtual）。&lt;br /&gt;
2.二义性例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base1:public&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base2:private&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="c1"&gt;//using Base1::checkOut;  //解决二义性的方法1  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

     &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
      &lt;span class="c1"&gt;//d.Base1::checkOut();  //解决二义性的方法2  &lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++首选确定对调用而言的最佳匹配（此处两个checkOut都是最佳匹配），之后才检查其可取用性。&lt;br /&gt;
所以，虽然private明显不能用，编译器还是返回错误：request for member 'checkOut' is ambigous。&lt;br /&gt;
解决：见程序注释。&lt;br /&gt;
3.钻石型多重继承，如果不希望最上层基类的成员在下层派生类中有多个副本，需要使用虚继承。&lt;br /&gt;
虚基类：所有派生自基类的类都采用virtual继承，该基类就被成为virtual base class&lt;br /&gt;
例子：STL中basic_ios ——&amp;gt;basic_istrem，basic_ostrem——&amp;gt;basic_iostrem&lt;br /&gt;
4.虚基类的初始化责任由继承体系的最底层（most derived）类负责。这样才可以避免虚基类被初始化多次。&lt;br /&gt;
5.虚继承有代价，所以一般不要用：虚继承的派生类占内存多，虚基类访问速度慢。&lt;br /&gt;
6.如果非要使用虚基类，尽量不要在里面放置数据，做一个接口类。类似与C#和Java中的Interfaces。  &lt;/p&gt;
&lt;h2&gt;Item 41: Understand implicit interfaces and compile-time-polymorphism&lt;/h2&gt;
&lt;p&gt;1.OOP的世界，显式接口（类的public接口，函数原型）和运行期多态 （virtual调用）。&lt;br /&gt;
Generic Programming，除了上面两者之外，还有隐式接口（typename需要支持的操作），和编译期多态（具现化）。&lt;br /&gt;
2.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;someWidget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;隐式接口是：w.size()&amp;gt;10 &amp;amp;&amp;amp; w!=someWidget返回bool类型。&lt;br /&gt;
可能w.size()返回数值型，或w有operator&amp;gt;成员，或opeartor&amp;gt;函数第一个参数接受T类型（或隐式转化成T类型），&lt;br /&gt;
可能operator&amp;amp;&amp;amp;被重载，返回一个bool类型。。。  &lt;/p&gt;
&lt;h2&gt;Item 42: Understand the two meaning of typename.&lt;/h2&gt;
&lt;p&gt;1.嵌套从属类型名称(nested dependent type name)需要在前面加typename，以表明它是类型名，否则编译器会假设它不是类型，而是一个变量。&lt;br /&gt;
举例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译期默认const_iterator是T中的静态变量，x可能全局变量之类的，它们做相乘。。。&lt;br /&gt;
声明其为类型：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//函数模版  &lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;Nested&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//类模版  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.两个特例不能加typename：&lt;br /&gt;
（1）继承的基类列表（base class list）&lt;br /&gt;
（2）构造函数成员初始化列表（member initialization list）  &lt;/p&gt;
&lt;h2&gt;Item 43: Know how to access names in templatized base classes&lt;/h2&gt;
&lt;p&gt;1.跟模版没关的一个话题：&lt;br /&gt;
当需要在派生类定义一个函数，是对基类函数的扩充，但是基类函数是non-virtual函数，这时候就用一个不同的名字。比如Base::sendClear()，Derived::sendClearMsg()&lt;br /&gt;
2.模版派生类，调用模版基类的函数时，不能不加任何修饰符的调用，因为编译期拒绝向模版基类的定义中寻找这个函数的声明。否则会在编译期"解析该模版类的定义式"时就报错。&lt;br /&gt;
原因：模版基类（templatized base class）可能存在特化版本，而这个特化版本中没有定义模版派生类要调用的那个函数。编译期在检查模版定义式的时候，没法确定具体是什么类型来具现化这个模版派生类。&lt;br /&gt;
解决：&lt;br /&gt;
（1）this-&amp;gt;修饰函数&lt;br /&gt;
（2）using Base&lt;T&gt;:: 引入相应名字&lt;br /&gt;
（3）Base&lt;T&gt;::修饰函数（最差的解决方法，因为会关闭virtual绑定行为）&lt;br /&gt;
3.编译器诊断模版相关的东西，分两个阶段&lt;br /&gt;
（1）解析模版的定义式。如上一条所列，可能报错。&lt;br /&gt;
（2）用实参具现化模版。如果this引入了基类的函数，但是基类相应特化版本的确不含有那个函数，这时候报错。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(9)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html" rel="alternate"></link><updated>2013-10-13T20:03:58+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(9).html</id><summary type="html">&lt;h2&gt;Item 32: Make sure public inheritance models "is-a"&lt;/h2&gt;
&lt;p&gt;1.C++OOP最重要的规则是：公有继承模型，建模的是‘is-a’关系，基类有的特性派生类一定具有。&lt;br /&gt;
2.没有通用的设计，有些地方看似很合理的设计，在一些情形下却不能使用：&lt;br /&gt;
企鹅是鸟，但是鸟可以飞；正方形是矩形，但是矩形可以在不改变宽的情况下修改高&lt;br /&gt;
3.修改”企鹅-&amp;gt;鸟“设计：&lt;br /&gt;
（1）class Bird; class Penguin :public Bird; class FlyingBird: public Bird; //在Bird里不定义fly()，在FlyingBird里定义&lt;br /&gt;
（2）class Bird; class Penguin :public Bird; //在Bird里定义fly()，但是在Penguin里实现fly()中导出一个错误。&lt;br /&gt;
比较：前者更优，编译期错误。  &lt;/p&gt;
&lt;h2&gt;Item 33: Avoid hiding inherited names.&lt;/h2&gt;
&lt;p&gt;1.派生类中的名字，会掩盖基类中的名字。即使派生类中的函数和基类的函数参数列表不同，不论函数是non-virtual或virtual或pure-virtual的，派生类对象也无法调用基类被掩盖的函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//错误！！！  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的目的，是防止派生类从遥远的基类中继承它并不清楚的同名重载函数。&lt;br /&gt;
2.一般公有继承，都要继承父类的所有成员，所以采取两种办法可以解决掩盖，实现重载：&lt;br /&gt;
（1）using声明式  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//引入base的所有func的名字，如果func函数包括多个重载版本，都引入派生类作用域  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）forwarding function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//之所以private inheritance，是因为公有继承的设计原则就是派生类拥有基类的一切特征  &lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;  
         &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt; &lt;span class="c1"&gt;//只引入base中的一个版本的func(int)，一般设计成inline，毕竟就一句。  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 34: Differentiate between inheritance of interface and inheritance of implementation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;class设计者，将接口函数设计成不同类型，就会限制派生类的行为：&lt;br /&gt;
（1）纯虚函数——&amp;gt;接口继承，希望只继承其接口。&lt;br /&gt;
注：纯虚函数也可以实现（在源文件中），除非要提供默认的行为供子类调用(Base::fly();)，否则一般不实现。&lt;br /&gt;
（2）虚函数——&amp;gt;接口和实现继承，提供默认实现，允许覆盖继承的实现。&lt;br /&gt;
派生类不重新定义，就默认使用的基类的版本；派生类重新定义，就可以实现多态。&lt;br /&gt;
（3）非虚函数——&amp;gt;接口和实现继承，不希望被覆盖。&lt;br /&gt;
非虚函数，应该在派生类和基类中有一致的行为，所以不应该被覆盖（名字掩盖的话，就using进来基类的名字）。&lt;br /&gt;
如果想覆盖基类，就把基类的函数定义成virtual。&lt;br /&gt;
2.任何类如果打算作为基类，都要拥有若干virtual函数（至少析构函数）。&lt;br /&gt;
3.任何函数如果不变性（invariant）大于特异性（specialization），就应该被定义成基类的非虚函数，不让子类覆盖（虽然遵守与否看子类守不守规矩）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 35: Consider alternatives to virtual functions.&lt;/h2&gt;
&lt;p&gt;正如上一个item所讲，虚函数的目的：提供默认实现，允许派生类覆盖。&lt;br /&gt;
public virtual的可选替代方案如下，实现了上面的两个目的：&lt;br /&gt;
（1）Template Method模式：NVI（non-virtual interface）手法&lt;br /&gt;
基类定义non-virtual函数healthValue()，调用private/protected virtual函数doHealthValue（每个派生类可以包含各自的实现）。&lt;br /&gt;
因为healthValue()有隐式this指针参数，所以根据调用对象的类型，可以执行不同类中定义的doHealthValue。&lt;br /&gt;
优点：避免代码重复。&lt;br /&gt;
healthValue函数，在调用doHealthValue的前面做一些准备工作（锁），在后面做一些清理工作。如果用public virtual的方法，每个派生类的函数都要有重复的准备和清理代码。&lt;br /&gt;
缺点：增加一个函数调用的开销。&lt;br /&gt;
（2）Strategy模式：非成员函数指针&lt;br /&gt;
基类有函数指针成员（healthFunc），构造函数中传入函数指针，比如int (*)(const GameCharacter&amp;amp;)，默认实参是一个缺省函数的指针。&lt;br /&gt;
优点：同一类型不同对象，可以有不同health函数；同一对象的行为也可以在运行时改变（提供setHealth函数）&lt;br /&gt;
缺点：非成员函数只能访问public成员，除非降低封装性，将其定义为友元函数，或private成员提供public访问方法。 &lt;br /&gt;
（3）Strategy模式：tr1::function&lt;br /&gt;
typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;&lt;br /&gt;
同上，但是支持函数指针、函数对象，和成员函数，且不需要函数完全匹配，兼容（参数和返回类型可以隐式转换）即可。&lt;br /&gt;
（4）Strategy模式：对象指针&lt;br /&gt;
类中包含，指向另一个继承体系的对象（包含一个healthFunc的函数）的指针，构造的时候传入。  &lt;/p&gt;
&lt;h2&gt;Item37: Never redefine a function's inherited default parameter values.&lt;/h2&gt;
&lt;p&gt;1.虚函数是dynamically bound，而默认参数statically bound。所以通过基类指针或引用访问派生类对象的成员函数，使用的基类的默认参数，和派生类的具体实现。&lt;br /&gt;
2.仅仅改变默认实参，不够成重载&lt;br /&gt;
3.派生类和基类中声明同样的默认参数，遵循默认参数不变的原则。但是代码重复，且有相依性（with dependencies），意味着一处修改就要多处修改。PS：貌似重复的代码大多都有相依性，所以杜绝复制粘贴，避免重复。&lt;br /&gt;
解决办法：NVI，仅在 base's non-virtual function上声明默认参数。  &lt;/p&gt;
&lt;h2&gt;Item 38: Model 'has-a' or 'is-implemented-in-terms-of' through composition.&lt;/h2&gt;
&lt;p&gt;1.复合(composition)还有一些同义词（synonym）：内含（containment），聚合（aggregation），内嵌（embedding）&lt;br /&gt;
2.复合，即对象包含在对象里面的情况。塑模两种情况&lt;br /&gt;
（1）has-a（包含）关系：应用域，比如人包含名字、地址&lt;br /&gt;
（2）is-implemented-in-terms-of（根据某物实现出）关系：实现域，比如set是根据linked list实现出的。&lt;br /&gt;
3.区分is-a和is-implemented-in-terms-of：&lt;br /&gt;
is-a的话，对基类为真的每一件事，对派生类也为真。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(7)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html" rel="alternate"></link><updated>2013-10-13T20:00:59+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 26: Postpone variable definitions as long as possible.&lt;/h2&gt;
&lt;p&gt;1.延后变量定义的意义是，有可能变量定义后，出现异常导致变量用不到，这样变量的构造和析构函数就白费了。所以，只在使用这个变量的代码之前定义它。&lt;br /&gt;
2.循环内变量的使用，是个特殊情况。但是仍然鼓励在循环内，变量使用前才定义变量。除非满足下面两点&lt;br /&gt;
(1)赋值成本比构造+析构成本低 (2)该段代码是效率敏感（performance-sensitive）的部分&lt;br /&gt;
因为：缩小变量的作用域，对于程序的可理解性和易维护性好。  &lt;/p&gt;
&lt;h2&gt;Item 27:Minimizing casting&lt;/h2&gt;
&lt;p&gt;1.C++风格类型转换中，&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;(expr)&lt;/code&gt;是唯一一个无法用旧式语达（C风格，函数风格）执行的动作，用来将基类的指针或引用转化为子类的指针或引用。&lt;br /&gt;
2.能用C++风格转型，就不用旧式语法。因为它们容易在代码中被辨识出来，因为简化了"找出类型系统在哪个地点被破坏"的过程。&lt;br /&gt;
3.显示构造：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//func的调用方式，包括3种强制类型转换的方式：  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle函数式类型转换，也理解为构造一个临时的Widget对象&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle标准类型转换  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//C++style类型转换  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.单一对象可能有一个以上的地址。Base&lt;em&gt;指向它和Derived&lt;/em&gt;指向它时的地址可能不同，这依赖于编译器将C++的对象如何布局。&lt;br /&gt;
而且，一旦多重继承，多个基类的指针指向同一个对象，地址一定是不一样的。&lt;br /&gt;
5.以上例子表明，类型转换并不仅仅是让编译器把某种类型视为另一种类型，其他什么也没做。&lt;br /&gt;
6.派生类虚函数中调用基类的版本，错误做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用onResize的不是this的base部分，而是强制类型转换所建立的临时对象  &lt;/span&gt;
&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//因为是虚函数，且是基类的引用，会调用自己，无穷递归。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WIndow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.应该尽量避免dynamic_cast，因为很多实现版本效率很低（比如调用多个strcmp，逐层比较class name）。&lt;br /&gt;
办法是，让父类定义空virtual函数，运用多态自动调用派生类的相应函数。&lt;br /&gt;
8.来自Cpp Primer：&lt;br /&gt;
dynamic_cast（成功返回相应指针或引用，失败返回NULL或抛出异常）：处理含有virtual函数的基类引用或指针，返回动态类型。&lt;br /&gt;
typeid（返回type_info对象，支持相等比较运算和name()方法）：处理含有virtual函数的基类，返回动态类型。  &lt;/p&gt;
&lt;h2&gt;Item 28:Avoid returning handles to object internals&lt;/h2&gt;
&lt;p&gt;1.以下句子编译可以通过，但是是错误的，因为这样的话外部就可以修改内部数据了，与const矛盾了。这是因为const成员函数实现的是bitwise const，而不是logical const  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="c1"&gt;//修改成：  &lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.引用、指针和迭代器都是所谓的handle，返回一个指向内部数据的handle，降低封装性，而且可能导致悬垂handle（即handle所指向的对象被销毁了，因为handle生存期可能比对象长）。&lt;br /&gt;
因此，尽量避免返回指向内部对象的handle，除非像string和vector的operator[]方法，不得不做的时候。  &lt;/p&gt;
&lt;h2&gt;Item 29: Strive for exception-safe code.&lt;/h2&gt;
&lt;p&gt;错误例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1.“异常安全”两个条件：&lt;br /&gt;
（1）不泄露任何资源&lt;br /&gt;
（2）不允许数据败坏&lt;br /&gt;
例子中，如果new出错（时刻注意，new分配内存的时候可能因为内存不足而抛出异常），mutex资源泄露，bgImage指针悬空。&lt;br /&gt;
“异常安全的函数”满足两个条件后，还分3个等级：&lt;br /&gt;
（1）基本承诺，即保证：任何事物在有效状态下，只是调用者不确切知道处于哪种状态。&lt;br /&gt;
（2）强烈保证，即保证：函数成功就完全成功；失败，就回到调用前的状态。&lt;br /&gt;
（3）不抛异常保证，即保证：只成功不失败，不抛出异常。&lt;br /&gt;
2.不抛出异常：只能靠程序保证。如下声明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只是告诉调用者，不打算抛出异常。但是“完全可能”抛出异常，那时候会有一个函数被调用（std::set_unexcepted函数的参数绑定的异常处理函数，该函数会在抛出非声明的类型的异常时执行）。&lt;br /&gt;
3.强烈保证：&lt;br /&gt;
变换语句顺序有时候可以做到；copy-and-swap一般可以做到。&lt;br /&gt;
（1）变换语句顺序：delete 和 ++放到new后面。当然用对象管理资源更安全和简洁  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;ml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//reset的过程中，原image会delete  &lt;/span&gt;
     &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c1"&gt;//函数退出后，Lock析构会释放mutex  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）copy-and-swap：把打算修改的对象复制一份，然后修改副本，再把副本和原对象交换。&lt;br /&gt;
4.尽量让函数等级更高，但是不抛出异常很难保证，因为很多库函数都可能抛出异常；强烈保证可能耗费很大的代价，比如copy and swap方法，复制构造和赋值操作的代价。&lt;br /&gt;
权衡的过程：tradeoff。&lt;br /&gt;
但是，要在文档上说明清楚可能抛出的异常等，以及为什么没有实现安全级别更高的代码。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(5)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html" rel="alternate"></link><updated>2013-10-11T16:34:30+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-11:posts/2013/10/EffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item18:  Make interfaces easy to use correctly and hard to use incorrectly&lt;/h2&gt;
&lt;p&gt;1.促进接口被正确使用：&lt;br /&gt;
（1）接口一致性：stl中所有容器都具有size() 函数，而不像Java和.Net。&lt;br /&gt;
（2）与内置类型行为兼容：想想和int类比。&lt;br /&gt;
2.阻止接口被误用（！！！不正确的行为，编译都不能通过）：&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）建立新类型，防止调用顺序错乱，比如(2013,1,10)。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//定义Month,Day,Year类型（struct，只含一个val变量和一个explicit单个参数构造函数即可）  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）束缚对象值，防止无意义的值，比如(Month(13),Day(1),Year(2013))。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Date类中私有化构造函数。  &lt;/span&gt;
&lt;span class="c1"&gt;//只提供一系列静态函数供调用。static Month Jan() {return Month(1);}  &lt;/span&gt;
&lt;span class="c1"&gt;//不能定义static Month Jan(1);因为 非局部静态对象的初始化顺序未定义，万一d是全局的对象，构造时可能Jan对象尚未初始化。  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）消除对象的资源管理责任，防止忘记释放资源。&lt;br /&gt;
//提供智能指针对象，而不是原始资源&lt;br /&gt;
总结：C++中为了保证接口不被误用，可能会增加很多C语言程序员看起来感觉冗余的代码，比如增加Month，Day，Year 3个类，比如定义Month::Jan()等静态函数。但是的确起到了C语言没法起到的作用：&lt;br /&gt;
（1）没法，只能认真看接口原型。&lt;br /&gt;
（2）可以通过函数内语句判断合法性，但是就将错误推迟到了运行时。&lt;br /&gt;
（3）没法，只能提醒自己释放。  &lt;/p&gt;
&lt;h2&gt;Item19: Treat class design as type design&lt;/h2&gt;
&lt;p&gt;1.应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研究class的设计。&lt;br /&gt;
2.允许T1类型被隐式转换成T2类型：&lt;br /&gt;
（1）T1类内定义operator T2()函数。&lt;br /&gt;
（2）T2含有非explicit的构造函数，且函数参数只有一个T1类型的对象。&lt;br /&gt;
3.设计类时遵循的准则略，需要设计类时查阅该书。  &lt;/p&gt;
&lt;h2&gt;Item20: Prefer pass-by-reference-to-const to pass-by-value&lt;/h2&gt;
&lt;p&gt;1.传递对象的引用，好处：&lt;br /&gt;
（1）效率高。值传递会调用参数的复制构造函数（同时调用其基类和成员变量的复制构造函数），函数退出时还要调用它们的析构函数。&lt;br /&gt;
（2）易于优化。常量引用的实现是指针，编译器通常更愿意将其放入缓存器。即使class尽含有一个double变量，编译器也不视其为内置类型，拒绝将其放入缓存器。&lt;br /&gt;
2.传递“常量”引用，好处：&lt;br /&gt;
（1）调用者不必担心传入的实参被改变。&lt;br /&gt;
（2）const或non-const对象都可以传入，适用范围更广。&lt;br /&gt;
3.小型自定义类型也不要值传递，原因：&lt;br /&gt;
（1）复制构造函数不一定小型（比如可能要deep-copy）。&lt;br /&gt;
（2）不易于被编译器优化，放入缓存器。&lt;br /&gt;
（3）该自定义类型可能在之后的更新中，体积变大。&lt;br /&gt;
4.不适合引用传递的情况：&lt;br /&gt;
（1）内置类型：效率更高，见下图&lt;br /&gt;
&lt;img alt="ec5" src="http://particle128.com/static/images/ec5.png" /&gt;
（2）STL迭代器：类似指针，STL会保证其复制构造效率高，习惯值传递&lt;br /&gt;
（3）函数对象：实质是指针  &lt;/p&gt;
&lt;h2&gt;Item21: Don't try to return a reference when you must return an object.&lt;/h2&gt;
&lt;p&gt;函数返回对象的时候，也会执行一次构造和析构函数。为了减少这次的构造和析构，可能考虑返回引用。问题：&lt;br /&gt;
（1）指向局部变量：显而易见不行。&lt;br /&gt;
（2）指向动态分配的堆上的对象：内存泄露。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//两个new出来的对象都没有办法释放，因为接触不到new出的指针。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）指向静态变量：多线程问题，还有语义上瑕疵。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;//总是返回true，因为返回的都是同一个static对象  &lt;/span&gt;
&lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(4)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html" rel="alternate"></link><updated>2013-10-04T19:33:09+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(4).html</id><summary type="html">&lt;h2&gt;Item 13: Use objects to manage resources&lt;/h2&gt;
&lt;p&gt;1.资源是指，使用完之后需要归还系统的东西。比如动态分配的内存，文件描述符，互斥锁，数据库连接，sockets。&lt;br /&gt;
2.尽管可以手动释放资源（比如delete），但是程序的修改（delete之前返回了），或客户的忘记，可能导致资源释放不了。&lt;br /&gt;
解决办法：用对象管理资源，利用对象在作用域范围之外会自动调用析构函数的机制，释放资源。&lt;br /&gt;
对于heap-based资源（资源new出来的，通过指针访问），有如下两种智能指针可用：&lt;br /&gt;
（1）std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &lt;br /&gt;
缺点：指向同一对象的auto_ptr，进行赋值或拷贝构造，会导致原ptr变成null。这样的目的，释放多次同一个资源。&lt;br /&gt;
（2）std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&lt;br /&gt;
注意：不存在上面的问题，因为是RCSP(引用计数智能指针)。&lt;br /&gt;
3.以上两种指针，都是在析构函数中使用delete，动态数组元素放入上面两个智能指针中，会导致释放不完全。&lt;br /&gt;
解决：&lt;br /&gt;
（1）使用vector代替动态数组。&lt;br /&gt;
（2）仍然使用动态数组，那么使用&lt;code&gt;boost::scoped_array&lt;/code&gt;，&lt;code&gt;boost::shared_array&lt;/code&gt;。  &lt;/p&gt;
&lt;h2&gt;Item 14: Think carefully about copying behavior in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.不是heap-based的资源，需要自己建立资源管理类。然后将需要管理的资源类放在一个大括号内，退出大括号析构函数负责释放资源。&lt;br /&gt;
2.资源管理类的复制行为：&lt;br /&gt;
（1）不希望复制：&lt;br /&gt;
private继承Uncopyable&lt;br /&gt;
（2）资源一个副本，引用计数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mutexPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第二个参数是删除器，引用计数为0时调用的函数。不带此参数默认行为是delete  &lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutext&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）资源多个副本：&lt;br /&gt;
每次复制资源都深拷贝。&lt;br /&gt;
（4）转移资源拥有权：&lt;br /&gt;
使用std::auto_ptr。  &lt;/p&gt;
&lt;h2&gt;Item 15: Provide access to raw resources in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.API往往访问原始资源，所以资源管理类要提供取得原始资源的办法。&lt;br /&gt;
2.标准库中两个智能指针的做法：&lt;br /&gt;
（1）显式访问：get()&lt;br /&gt;
（2）隐式访问：成员访问操作符 -&amp;gt; 和 .可以访问到原始资源的成员&lt;br /&gt;
3.自定义资源管理类的做法：&lt;br /&gt;
（1）显式访问：定义get() ，更安全&lt;br /&gt;
&lt;code&gt;FontHandle get() const {return f;}&lt;/code&gt;&lt;br /&gt;
（2）隐式访问：定义隐式转换函数 ，更方便&lt;br /&gt;
&lt;code&gt;operator FontHandle() const {return f;}&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item16: Use the same form in corresponding uses of new and delete&lt;/h2&gt;
&lt;p&gt;1.new执行过程：通过名为operator new的函数分配内存；在该块内存有一个或多个（new string[4]）构造函数被调用。&lt;br /&gt;
delete执行过程：在该内存有一个或多个（delete [] arr）析构函数被调用；通过名为operator delete的函数释放内存。&lt;br /&gt;
2.delete []一个对象，和delete一个数组，结果都未定义。因为数组在内存的布局可能是：起始地址放置数组大小（4B），之后是数组内容。&lt;br /&gt;
3.注意typedef定义的数组类型的释放:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非常容易引起混淆，所以最好不好定义数组类型，vector代替。  &lt;/p&gt;
&lt;h2&gt;Item17: Store newed object in smart pointers in standalone statements(standalone 独立的)&lt;/h2&gt;
&lt;p&gt;1.例子：&lt;br /&gt;
&lt;code&gt;processWidget(std::tr1::shared_ptr&amp;lt;Widget&amp;gt;(new Widget),priority());&lt;/code&gt; &lt;br /&gt;
问题：编译器的优化可能导致这种顺序的调用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;  
&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//如果抛出异常，new的资源就泄露了，因为没有指针指向它，没法释放  std::tr1::shared_ptr&amp;lt;Widget&amp;gt;构造函数  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决办法：独立语句中将动态分配的对象存入智能指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;tr1&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="nx"&gt;processWidget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(3)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html" rel="alternate"></link><updated>2013-10-04T19:28:25+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(3).html</id><summary type="html">&lt;h2&gt;Item 09: Never call virtual functions in constructions and destructions&lt;/h2&gt;
&lt;p&gt;1.derived class对象构造时，base class构造函数先被调用，在其中调用/间接调用的虚函数是是父类的版本。原因有二：&lt;br /&gt;
（1）父类构造时，子类成员变量尚未初始化，处于未定义状态，C++不允许调用子类virtual函数（几乎必然会访问成员变量）&lt;br /&gt;
（2）父类构造函数执行时，动态类型是父类。&lt;br /&gt;
同理，析构函数。&lt;br /&gt;
2.替代策略：对于每个子类都要调用的函数，不声明virtual&lt;br /&gt;
（1）每个子类构造函数分别调用相应函数。例如logTransaction()&lt;br /&gt;
（2）子类构造函数显示调用父类构造函数，传递参数上去。例如&lt;code&gt;BaseClass(createLogString(para))&lt;/code&gt;，其中createLogString是static成员，保证不会访问子类对象的成员变量。  &lt;/p&gt;
&lt;h2&gt;Item 11: Handle assignment to self in operator=&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
         &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
         &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：自我赋值安全性，异常安全性。&lt;br /&gt;
解决：&lt;br /&gt;
（1）证同测试 identity test  -》解决了自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;==&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  &lt;span class="c1"&gt;//测试是否是自我赋值  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//异常可能发生，比如内存不足，复制构造函数有异常抛出。如果外面捕获了该异常，并继续执行程序，那么pb将指向被释放了的空间，之后任何操作都会引起未定义行为。  &lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）调整语句顺序 -》解决异常安全性，同时解决自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//先构造，后删除  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）copy and swap -》解决异常安全性，同时解决自我赋值安全性&lt;br /&gt;
思想就是用参数构造一个临时对象，然后和类内对象交换。具体代码略。  &lt;/p&gt;
&lt;h2&gt;Item 12： Copy all parts of an object&lt;/h2&gt;
&lt;p&gt;1.如果类中新增了一个成员变量，一定记得同时修改构造函数、复制构造函数和赋值操作符，确保新成员变量被合理的初始化和赋值。&lt;br /&gt;
2.派生类定义的复制构造函数，和赋值操作符，需要调用基类的相应函数，否则前者隐式调用基类的默认构造函数，后者则不会调用基类的赋值操作符。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;),...&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//也可以使用if(this==&amp;amp;rhs)包裹函数体，跳过自我赋值。这需要权衡自我赋值的次数，以及增加这一条判断语句的代价。一般可以不加这句话。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：编译器合成的版本，会自动调用基类的复制构造和赋值操作，就像上面实现的一样。&lt;br /&gt;
3.重复代码放到私有函数init里，不要复制构造调用赋值操作符，或反过来。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry></feed>