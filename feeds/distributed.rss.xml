<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/distributed.rss.xml" rel="self"></link><id>http://particle128.com/</id><updated>2014-07-29T00:00:00+08:00</updated><entry><title>使用Storm 2个月后的总结</title><link href="http://particle128.com/posts/2014/07/storm-sum.html" rel="alternate"></link><updated>2014-07-29T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-07-29:posts/2014/07/storm-sum.html</id><summary type="html">&lt;h2&gt;如何使用directGrouping&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;申明流是direct Stream&lt;br /&gt;
spout/bolt的declareOutputFields中&lt;br /&gt;
outputFieldsDeclarer.declare(/&lt;em&gt;direct&lt;/em&gt;/true, new Fields("word"));  &lt;/li&gt;
&lt;li&gt;使用emitDirect来发送数据&lt;br /&gt;
spout/bolt的nextTuple/execute中&lt;br /&gt;
collector.emitDirect(/&lt;em&gt;taskId&lt;/em&gt;/getWordCountIndex(word),new Values(word));&lt;br /&gt;
注意：因为第一个参数是taskid，首先需要在open/prepare里面获取下游bolt的taskid列表&lt;br /&gt;
topologyContext.getComponentTasks("word-counter")  &lt;/li&gt;
&lt;li&gt;topology定义中指定连接方式为directGrouping&lt;br /&gt;
builder.setBolt("word-counter", new WordCounter(), 3).directGrouping("spout");  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如何利用Storm提供的可靠性保证&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在spout中，用SpoutOutputCollector调用emit的时候，必须指定messageId。&lt;br /&gt;
一个messageId对应一个tuple树。&lt;br /&gt;
这样，在某个tuple树全部被处理完后，spout的回调函数ack会被调用，ack的参数是那个tuple树对应的messageId。  &lt;/li&gt;
&lt;li&gt;在每一个bolt中，用OutputCollector调用emit的时候，需要指定源tuple，并且在emit之后要调用ack。&lt;br /&gt;
如果该bolt继承自BaseBasicBolt，则自动完成上述操作。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;问题集锦&lt;/h2&gt;
&lt;h3&gt;Problem1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Spout：emit出去一个map，下游Bolt：有时候读到空的map，有时候读到有内容的map&lt;br /&gt;
&lt;strong&gt;原因&lt;/strong&gt;&lt;br /&gt;
emit出去一个map，就调用pruneData函数把map给clear了。&lt;br /&gt;
因为本地模式在同一个虚拟机下，storm并没有把这个map深拷贝到tuple中保存，Bolt读到的map和上游Spout发送的map是来自同一块内存。&lt;br /&gt;
这样，就出现了一个竞争条件：如果Spout线程先clear，下游Bolt才接到的话，读到的就是空map；如果先接到，Spout再clear，读到的就是有内容的map。&lt;br /&gt;
&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
pruneData不clear这个map了，而是new一个新的map。让垃圾回收器去把不用的map回收。  &lt;/p&gt;
&lt;h3&gt;Problem2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Trident中，使用each和partitionAggregate函数，下游接收到空的tuple&lt;br /&gt;
&lt;strong&gt;原因&lt;/strong&gt;&lt;br /&gt;
这和&lt;a href="http://storm.incubator.apache.org/documentation/Documentation.html"&gt;官方Documentation&lt;/a&gt;不符，原因不详&lt;br /&gt;
&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
不管是each，还是partitionAggregate函数，必须指定第一个参数（即Fields），表明输入的值列表。  &lt;/p&gt;
&lt;h3&gt;Probelm3&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Trident中，一旦加上partitionPersist函数，就会报错  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;NotSerializableException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;aliyun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;aep&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;storm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;binpacking&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;BinpackingTrident&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
让BinpackTrident实现Serializable。  &lt;/p&gt;</summary><category term="storm"></category></entry></feed>