<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/linux.rss.xml" rel="self"></link><id>http://particle128.com/</id><updated>2014-05-26T00:00:00+08:00</updated><entry><title>项目中一个诡异的问题</title><link href="http://particle128.com/posts/2014/05/vdisk-one-question.html" rel="alternate"></link><updated>2014-05-26T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-26:posts/2014/05/vdisk-one-question.html</id><summary type="html">&lt;p&gt;记录下今天在做虚拟磁盘过程中，遇到的一个问题。  &lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;因为没有找到合适的fat32格式文件系统的扩容工具（fatresize没有效果，parted3.1可以检测到分区但是没有resize功能，parted2.x有resize功能但是检测不到分区），只能暂时采用如下方法来进行“磁盘扩容”。（假设原磁盘test.img，大小为100M，要扩容到200M）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  
&lt;span class="n"&gt;mkdosfs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;iocharset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;  
&lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;iocharset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;umount&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;  
&lt;span class="n"&gt;umount&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;mv&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了测试这种方法的可行性，用了如下步骤：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端挂载test.img，并写入一系列文件  &lt;/li&gt;
&lt;li&gt;客户端卸载test.img  &lt;/li&gt;
&lt;li&gt;服务器执行上述命令  &lt;/li&gt;
&lt;li&gt;客户端再次挂载test.img，查看文件是否存在并且该磁盘大小是否变成200M  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果，奇怪的事情发生了：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户的windows下现实的磁盘大小仍然为100M  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我用&lt;code&gt;head -c 512 test.img| xxd&lt;/code&gt;查看了一下test.img的启动扇区，0x20开始的4个字节显示磁盘的扇区数目没有错，对应的就是200M大小的磁盘。  &lt;/p&gt;
&lt;p&gt;后来又发现了更诡异的事情：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端对test.img对应磁盘的修改，从服务器的打印信息来看是写入成功了，但是在服务器上mount一下test.img后发现跟原来一样。（写入磁盘我用的mmap+msync方式，所以不存在对文件的修改没有写入磁盘的问题）  &lt;/li&gt;
&lt;li&gt;ls -l 命令显示，客户端对test.img进行修改后，test.img的mtime并没有变化  &lt;/li&gt;
&lt;li&gt;客户端对test.img修改之后，卸载了再挂载，之前的修改保留在了磁盘上  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端对test.img的修改去哪里了？为啥客户端可以看到修改，服务器看不到？  &lt;/p&gt;
&lt;h3&gt;排查&lt;/h3&gt;
&lt;p&gt;试了几种方法，都没有发现问题，后来用&lt;code&gt;lsof | sed -n '1p;/test.img/p'&lt;/code&gt;查看打开文件的时候，发现问题了。&lt;br /&gt;
结果如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;COMMAND&lt;/span&gt;     &lt;span class="n"&gt;PID&lt;/span&gt;       &lt;span class="n"&gt;USER&lt;/span&gt;   &lt;span class="n"&gt;FD&lt;/span&gt;      &lt;span class="n"&gt;TYPE&lt;/span&gt;     &lt;span class="n"&gt;DEVICE&lt;/span&gt;  &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;OFF&lt;/span&gt;       &lt;span class="n"&gt;NODE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;  &lt;span class="n"&gt;DEL&lt;/span&gt;       &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;              &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;    &lt;span class="mi"&gt;6u&lt;/span&gt;      &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deleted&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正常情况，在执行PUT的过程中输出如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;COMMAND&lt;/span&gt;     &lt;span class="n"&gt;PID&lt;/span&gt;       &lt;span class="n"&gt;USER&lt;/span&gt;   &lt;span class="n"&gt;FD&lt;/span&gt;      &lt;span class="n"&gt;TYPE&lt;/span&gt;     &lt;span class="n"&gt;DEVICE&lt;/span&gt;  &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;OFF&lt;/span&gt;       &lt;span class="n"&gt;NODE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;  &lt;span class="n"&gt;mem&lt;/span&gt;       &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;    &lt;span class="mi"&gt;6u&lt;/span&gt;      &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中mem表示test.img被内存映射  &lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;首先引用一句APUE里的话：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关闭一个文件时，内核会首先检查打开该文件的进程数。如果进程数达到0，然后检查其链接数，如果这个数才是0，那么就删除该文件。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：shell下可以分别用&lt;code&gt;lsof | grep filename&lt;/code&gt;和&lt;code&gt;ls -l filename | cut -d ' ' -f 2&lt;/code&gt;来检查这两点是否满足。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv bigger.img test.img&lt;/code&gt;，其实是删除原test.img再把bigger.img改名为test.img的过程。&lt;br /&gt;
test.img的删除，是unlink的过程，即“将test.img的inode结点中的链接数字段-1”。虽然此时test.img的链接数变为0，但是test.img还打开着，所以不会马上删除这个文件的inode结点、数据块。但是，会删除test.img所在目录里的一行文件记录(inode号-&amp;gt;文件名)。由于，inode块和数据块没有删除，inode map和data map中对应的位置也占用着，所以后续在文件系统创建新文件，不会把他们覆盖。  &lt;/p&gt;
&lt;p&gt;项目中我使用了全局hashmap path2fd(保存文件路径到文件描述符)，所以客户端卸载再加载test.img的过程，还在使用原来的文件描述符来访问文件。read和write系统调用，都是使用文件描述符来引用的。因此mv删除原test.img后，重新挂载test.img后，仍然都在修改原test.img——一个在目录中找不到的文件，也被称为幽灵文件(phantom file)。  &lt;/p&gt;
&lt;h4&gt;一个问题&lt;/h4&gt;
&lt;p&gt;这个原理，顺便可以解释一个问题——“什么情况下，df -h /dir和du -hs /dir的结果不一样：&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;答&lt;/em&gt;&lt;/strong&gt;：运行中进程打开的文件，被用户删除！（link=0，但访问进程数&amp;gt;0）&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;解释&lt;/em&gt;&lt;/strong&gt;：df直接从文件系统的超级块读取磁盘使用情况信息，所以往往返回结果很快。但是du递归深入目录，readdir来获取每一个目录下的文件，然后将各个文件的inode中保存的文件大小相加。目录项被删除，du变小；文件没有被真正删除，超级块没变，df没变。df的结果&amp;gt;du的结果。  &lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;每次resize一个FAT32磁盘，就重新打开一遍这个文件，更新一下全局hashmap。  &lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>linux中的线程的实质和实现</title><link href="http://particle128.com/posts/2014/05/linux-thread.html" rel="alternate"></link><updated>2014-05-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-20:posts/2014/05/linux-thread.html</id><summary type="html">&lt;h3&gt;线程的实质&lt;/h3&gt;
&lt;p&gt;gdb调试线程，在线程创建和退出的时候，会看到这样的字样  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;New&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="mh"&gt;0xb799ab40&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LWP&lt;/span&gt; &lt;span class="mi"&gt;20528&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="mh"&gt;0xb799ab40&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LWP&lt;/span&gt; &lt;span class="mi"&gt;20528&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exited&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Thread后面的数字是线程id，但是后面出现的LWP是什么呢？  &lt;/p&gt;
&lt;p&gt;LWP(light weighted process)，即轻量级进程。它是进程，但是和普通进程的区别在于，子进程和父进程共享绝大多数地址空间和资源:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址空间中，除了栈，其他段（text、data、bss、heap等）都是共享的。  &lt;/li&gt;
&lt;li&gt;资源中，除了tid、线程特定的信号屏蔽字、errno等少数几个，其余的（pid、ppid、pgid、sid、controlling terminal、uid、gid、open file descriptors、record locks、当前目录和根目录、rlimit限制、文件默认创建模式、itimer定时器等）都是共享的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普通进程和LWP在实现上的不同点是：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通进程，fork会调用clone，第三个参数flags不会包含CLONE_THREAD  &lt;/li&gt;
&lt;li&gt;LWP，pthread_create会调用clone，第三个参数flags会包含CLONE_THREAD(可能还有其他几个标志)，标示子进程和父进程同属一个线程组(相同TGID)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程和LWP是同一个东西，只是在用户态，我们管进程中每一个执行序列为“线程”，但是内核中它被称为LWP。因为内核上没有线程的概念，CPU的调度是以进程为单位的。  &lt;/p&gt;
&lt;h3&gt;线程的实现&lt;/h3&gt;
&lt;p&gt;线程的实现，经历了如下发展阶段：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinuxThreads : Linux2.6之前  &lt;/li&gt;
&lt;li&gt;NPTL (Native Posix Thread Library) : RedHat负责，Linux2.6之后  &lt;/li&gt;
&lt;li&gt;NGPT (Next Generation Posix Thread): IBM负责，同NPTL同时开始研究的，但是最后被抛弃了(IBM啊...哎...)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;LinuxThreads&lt;/h4&gt;
&lt;p&gt;在LinuxThreads中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建并启动管理线程。然后管理线程再来创建用户请求的线程。也就是说，用户在调用pthread_create后，先是创建了管理线程，再由管理线程创建了用户的线程。  &lt;/p&gt;
&lt;p&gt;为了遵循POSIX对线程的一个规定：&lt;code&gt;当"进程"收到一个致命信号(比如由于段错误收到SIGSEGV信号), 进程内的线程全部退出&lt;/code&gt;，LinuxThreads的实现方法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序第一次调用pthread_create时, linuxthreads发现管理线程不存在, 于是创建这个管理线程. 这个管理线程是进程中的第一个线程(主线程)的儿子.  &lt;/li&gt;
&lt;li&gt;然后在pthread_create中, 会通过pipe向管理线程发送一个命令, 告诉它创建线程. 即是说, 除主线程外, 所有的线程都是由管理线程来创建的, 管理线程是它们的父亲.  &lt;/li&gt;
&lt;li&gt;于是, 当任何一个子线程退出时, 管理线程将收到SIGUSER1信号(这是在通过clone创建子线程时指定的). 管理线程在对应的sig_handler中会判断子线程是否正常退出, 如果不是, 则杀死所有线程, 然后自杀.  &lt;/li&gt;
&lt;li&gt;主线程是管理线程的父亲, 其退出时并不会给管理线程发信号. 于是, 在管理线程的主循环中通过getppid检查父进程的ID号, 如果ID号是1, 说明父亲已经退出, 并把自己托管给了init进程(1号进程). 这时候, 管理线程也会杀掉所有子线程, 然后自杀.  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;容易发现，管理线程可能成为多线程系统的瓶颈，线程创建和销毁的开销很大（需要IPC）。&lt;br /&gt;
更为重要的是，LinuxThreads无法满足Posix对线程的绝大多数规定，比如：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看进程列表的时候, 相关的一组task_struct应当被展现为列表中的一个节点;  &lt;/li&gt;
&lt;li&gt;发送给这个"进程"的信号(对应kill系统调用), 将被对应的这一组task_struct所共享, 并且被其中的任意一个"线程"处理;  &lt;/li&gt;
&lt;li&gt;发送给某个"线程"的信号(对应pthread_kill), 将只被对应的一个task_struct接收, 并且由它自己来处理;  &lt;/li&gt;
&lt;li&gt;当"进程"被停止或继续时(对应SIGSTOP/SIGCONT信号), 对应的这一组task_struct状态将改变;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NPTL&lt;/h4&gt;
&lt;p&gt;在linux 2.6中, 内核有了线程组的概念, task_struct结构中增加了一个tgid(thread group id)字段.&lt;br /&gt;
如果这个task是一个"主线程", 则它的tgid等于pid, 否则tgid等于进程的pid(即主线程的pid).  &lt;/p&gt;
&lt;p&gt;通过如下方式，解决了LinuxThreads不能兼容POSIX的问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有了tgid, 内核或相关的shell程序就知道某个tast_struct是代表一个进程还是代表一个线程, 也就知道在什么时候该展现它们, 什么时候不该展现(比如在ps的时候, 线程就不要展现了).  &lt;/li&gt;
&lt;li&gt;为了应付"发送给进程的信号"和"发送给线程的信号", task_struct里面维护了两套signal_pending, 一套是线程组共享的, 一套是线程独有的。通过kill发送的信号被放在线程组共享的signal_pending中, 可以由任意一个线程来处理; 通过pthread_kill发送的信号(pthread_kill是pthread库的接口, 对应的系统调用中tkill)被放在线程独有的signal_pending中, 只能由本线程来处理.  &lt;/li&gt;
&lt;li&gt;当线程停止/继续, 或者是收到一个致命信号时, 内核会将处理动作施加到整个线程组中.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NGPT&lt;/h4&gt;
&lt;p&gt;上面提到的两种线程库使用的都是内核级线程(每个线程都对应内核中的一个调度实体), 这种模型称为1:1模型(1个线程对应1个内核级线程);&lt;br /&gt;
而NGPT则打算实现M:N模型(M个线程对应N个内核级线程), 也就是说若干个线程可能是在同一个执行实体上实现的.  &lt;/p&gt;
&lt;p&gt;因为模型太复杂，貌似没有实现出来所有预定功能，所以被放弃了。  &lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.thegeekstuff.com/2013/11/linux-process-and-threads/"&gt;What are Linux Processes, Threads, Light Weight Processes, and Process State&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.cnitblog.com/tarius.wu/articles/2277.html"&gt;关于进程、线程和轻量级进程的一些笔记&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www3.ece.neu.edu/~dschaa/docs/processes.html"&gt;PROCESSES AND THREADS&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://blog.csdn.net/tianyue168/article/details/7403693"&gt;Linux进程、线程模型，LWP，pthread_self()&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library"&gt;wiki:Native POSIX Thread Library&lt;/a&gt;  &lt;/p&gt;</summary><category term="linux"></category><category term="thread"></category><category term="lwp"></category></entry><entry><title>一场core dump引发的思考</title><link href="http://particle128.com/posts/2014/05/delete-core-dump.html" rel="alternate"></link><updated>2014-05-19T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-19:posts/2014/05/delete-core-dump.html</id><summary type="html">&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;上午在实现算法“找出最小的k个元素/找出第k大的元素”时，遇到了core dump。代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iterator&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;algorithm&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cstdlib&amp;gt;  &lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="c1"&gt;//copy(arr+begin,arr+end+1,ostream_iterator&amp;lt;int&amp;gt;(cout,&amp;quot;,&amp;quot;));  &lt;/span&gt;
    &lt;span class="c1"&gt;//cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;begin:&amp;quot;&amp;lt;&amp;lt;begin&amp;lt;&amp;lt;&amp;quot;,end:&amp;quot;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;quot;,mid:&amp;quot;&amp;lt;&amp;lt;mid&amp;lt;&amp;lt;endl;  &lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// the last element of the small part!!!  &lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;mink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;||!&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;srand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;random_shuffle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ostream_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// fail  &lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ostream_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并不总会出现core dump，往往测试几组会出现一次。错误信息：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;glibc&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x09499008&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt;  
&lt;span class="o"&gt;=======&lt;/span&gt; &lt;span class="n"&gt;Backtrace&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=========&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x75ee2&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb751bee2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libstdc&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_ZdlPv&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb76f951f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libstdc&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_ZdaPv&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x1b&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb76f957b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x8048bfb&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__libc_start_main&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0xf3&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb74bf4d3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x8048791&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;=======&lt;/span&gt; &lt;span class="n"&gt;Memory&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;========&lt;/span&gt;  
&lt;span class="mi"&gt;08048000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;a000&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xp&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;a000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00001000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;c000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00002000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;09499000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;094&lt;/span&gt;&lt;span class="n"&gt;ba000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;b7459000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b745b000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;错误显示为free了一个无效的指针，但是这段代码中new 和 delete的关系如此简单，怎么也想不通啊。况且，从内存映射信息中可以看出，free的指针的确也位于堆上，更让人费解。  &lt;/p&gt;
&lt;h3&gt;转折&lt;/h3&gt;
&lt;p&gt;下午有事没有来实验室，晚上再次拾起这个问题的时候，发现partition代码让我给弄没了（-.-|||），只能重写。&lt;br /&gt;
重写的过程中，突然意识到应该是&lt;code&gt;int j=begin;&lt;/code&gt;，因为j保存的是小于arr[mid]的区段的最后一个元素，区段开始位置是begin+1，上午写成了&lt;code&gt;int j=begin-1;&lt;/code&gt;。改了这一句，在main函数里加了一个循环测试，一点问题都没有。  &lt;/p&gt;
&lt;p&gt;看来，问题出在这一句上。思虑片刻，又翻了一下CSAPP，恍然大悟。  &lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;new和delete的底层会使用malloc和free，在堆上进行内存分配和释放。用malloc分配一个数组，使用，之后传递给free一个数组指针的时候，它如何知道释放多少空间呢？&lt;br /&gt;
答案是，从指针位置前面的一个字中寻找要释放的内存的大小，块大小保存在实际数据位置-4的内存中。&lt;br /&gt;
堆中分配的内存块的截图如下：&lt;br /&gt;
&lt;img alt="image" src="http://particle128.com/images/heap_map.png" /&gt;  &lt;/p&gt;
&lt;p&gt;在gdb中测试一下，结果和解释：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;                  &lt;span class="c1"&gt;//输入，表示会动态分配10个int  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c038&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c034&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c034&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;49&lt;/span&gt;          &lt;span class="c1"&gt;//解释：至少需要的字节数为10*4+4=44（10个4B的int，加一个4B的块大小），为了凑够8B对齐（双字对齐），添加4B的填充(padding)，正好48B。49是因为块大小的最后一位被置1，表示是已分配  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;conti&lt;/span&gt;  
&lt;span class="n"&gt;Continuing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;  
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  

&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;  
&lt;span class="mi"&gt;52&lt;/span&gt;  &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c078&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c074&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c074&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;          &lt;span class="c1"&gt;//解释：至少1*4+4=8B，按理来说8B满足对齐要求了，不需要填充了。（猜测）但为了防止外部碎片，分配策略约定至少分配16B，所以8B的填充。  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;conti&lt;/span&gt;  
&lt;span class="n"&gt;Continuing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;  
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  

&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;  
&lt;span class="mi"&gt;52&lt;/span&gt;  &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c0a0&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c09c&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c09c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;25&lt;/span&gt;          &lt;span class="c1"&gt;//同理  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;明白了这一点后，我把程序改回了原来的状态(即&lt;code&gt;j=begin-1;&lt;/code&gt;)，并且把上面的代码中注释部分去掉注释，让它打印局部状态，执行结果和解释如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;          &lt;span class="c1"&gt;//输入5和3(5个元素的数组，取最大的3个元素)，后面的为输出信息  &lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="c1"&gt;// arr[mid]=0，是最小的一个元素，所以这一趟执行完之后，j=begin-1=-1，swap交换了arr[-1]和arr[0]，arr[-1]存的正好是堆块的大小信息，所以0不见了，25出现了。  &lt;/span&gt;
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;glibc&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x09499008&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="c1"&gt;// free指针，发现释放的指针的前一个字的最后一位是0，表明是未分配的内存，所以调用abort()函数中止了进程的执行。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>类unix系统下函数的可重入性</title><link href="http://particle128.com/posts/2014/05/reentrant.html" rel="alternate"></link><updated>2014-05-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-05:posts/2014/05/reentrant.html</id><summary type="html">&lt;p&gt;以下内容汇总自APUE不同章节，还包括自己的一些测试  &lt;/p&gt;
&lt;h3&gt;可重入&lt;/h3&gt;
&lt;p&gt;可重入（reentrant）函数，字面意思就是可以重复进入执行，而不会发生数据错乱等异常情况。包括两重意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号处理程序可重入 —— 满足这个条件的函数，称之为异步-信号安全的(async-signal-safe)  &lt;/li&gt;
&lt;li&gt;线程可重入 —— 满足这个条件的函数，称之为线程安全的(thread-safe)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个概念并不对等:&lt;br /&gt;
标准IO库函数比如printf，是线程安全的，因为内部使用了递归锁，即用&lt;code&gt;flockfile(FILE*fp)&lt;/code&gt;和&lt;code&gt;funlockfile(FILE*fp)&lt;/code&gt;包裹;&lt;br /&gt;
但是，它并不是异步信号安全的，因为毕竟&lt;code&gt;FILE&lt;/code&gt;结构是全局的，信号处理程序中可能会修改它(flockfile和funlockfile之间).  &lt;/p&gt;
&lt;h3&gt;信号处理程序可重入&lt;/h3&gt;
&lt;p&gt;不可重入的几种情况：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用静态数据结构，比如getpwnam，getpwuid：如果信号发生时正在执行getpwnam，信号处理程序中执行getpwnam可能覆盖原来getpwnam获取的旧值  &lt;/li&gt;
&lt;li&gt;调用malloc或free：如果信号发生时正在malloc（修改堆上存储空间的链接表），信号处理程序又调用malloc，会破坏内核的数据结构  &lt;/li&gt;
&lt;li&gt;使用标准IO函数，因为好多标准IO的实现都使用全局数据结构，比如printf(文件偏移是全局的)  &lt;/li&gt;
&lt;li&gt;函数中调用longjmp或siglongjmp：信号发生时程序正在修改一个数据结构，处理程序返回到另外一处，导致数据被部分更新。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试书中的例子发现并不会产生SIGSEGV信号，但是程序会阻塞在信号处理程序中调用getpwnam处，怀疑是我的linux版本中getpwnam实现中使用锁来保护静态数据结构struct passwd，而且不是递归锁。  &lt;/p&gt;
&lt;p&gt;测试代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/unistd.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/time.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;signal.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;pwd.h&amp;gt;  &lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sig_alrm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;in the sig_alrm&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getpwnam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;root&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;root error&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after the sig_alrm&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;alarm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//!!!  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;sighandler_t&lt;/span&gt; &lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGALRM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;sig_alrm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;alarm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//alarm只支持秒级的定时器  &lt;/span&gt;
    &lt;span class="cm"&gt;/*  &lt;/span&gt;
&lt;span class="cm"&gt;    struct itimerval old_val,new_val;  &lt;/span&gt;
&lt;span class="cm"&gt;    new_val.it_interval.tv_sec=0;  &lt;/span&gt;
&lt;span class="cm"&gt;    new_val.it_interval.tv_usec=1000; //1ms  &lt;/span&gt;
&lt;span class="cm"&gt;    setitimer(ITIMER_REAL,&amp;amp;new_val,&amp;amp;old_val);//setitimer支持精度更高的定时器，最高可以达到us级，如果系统支持这么高的精度的话  &lt;/span&gt;
&lt;span class="cm"&gt;    cout&amp;lt;&amp;lt;&amp;quot;old itimerval,interval:&amp;quot;&amp;lt;&amp;lt;old_val.it_interval.tv_sec*1000+old_val.it_interval.tv_usec/1000&amp;lt;&amp;lt;&amp;quot;,value:&amp;quot;&amp;lt;&amp;lt;old_val.it_value.tv_sec*1000+old_val.it_value.tv_usec/1000&amp;lt;&amp;lt;endl;  &lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before pwnam&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getpwnam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after pwnam&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu error&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pw_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;not mashu&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  

    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGALRM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;线程可重入&lt;/h3&gt;
&lt;p&gt;很多线程不可重入的系统调用或库函数，都有对应的线程可重入版本，比如  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asctime_r,ctime_r,gmtime_r,localtime_r  &lt;/li&gt;
&lt;li&gt;getpwnam_r,getpwuid_r,getgrgid_r,getgrnam_r  &lt;/li&gt;
&lt;li&gt;readdir_r,rand_r,strerror_r,strtok_r  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书中实现的getenv_r，做到了线程安全：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改接口，让调用者自己提供缓冲区，而不是用静态/全局缓冲区  &lt;/li&gt;
&lt;li&gt;在访问全局变量environ时递归互斥锁，防止其他线程对该全局变量的修改(pthread_once,pthread_mutex_lock,pthread_mutex_unlock...)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS，第一点，还可以选择用线程私有/特定数据实现（pthread_key_create,pthread_setspecific,pthread_getspecific）&lt;br /&gt;
第二点，之所以递归，是防止信号处理程序调用同一函数时，死锁。  &lt;/p&gt;
&lt;p&gt;即使做到这几点，getenv_r仍然不是异步信号安全的，因为pthread函数库不保证异步信号安全，包含pthread函数库的函数（getenv_r）也就不能保证异步信号安全。  &lt;/p&gt;</summary><category term="reentrant"></category><category term="linux"></category></entry><entry><title>初识自旋锁spinlock</title><link href="http://particle128.com/posts/2014/04/spinlock.html" rel="alternate"></link><updated>2014-04-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-02:posts/2014/04/spinlock.html</id><summary type="html">&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;虚拟磁盘的项目中，使用了互斥锁(mutex)来控制任务队列的访问。但是mutex开销过大，让线程池的效果大打折扣，于是发现了spinlock的存在。  &lt;/p&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;来自&lt;a href="http://en.wikipedia.org/wiki/Spinlock"&gt;wiki&lt;/a&gt;的定义：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自旋锁是一种忙等锁，它不像其他同步方式（mutex,rwlock,cond）一样，将不能进入临界区的线程阻塞，并通过上下文切换，让另一个可以执行的线程在该cpu上运行。该锁会一直循环检查，直到别的线程释放。  &lt;/p&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多处理器（或者多核） ——否则，线程会进入死循环，程序死锁  &lt;/li&gt;
&lt;li&gt;临界区代码执行很快   ——比如就几行代码，且没有系统调用  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优点和缺点&lt;/h3&gt;
&lt;p&gt;优点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了上下文切换的繁重开销（用户态-&amp;gt;内核态，保护现场，可能页置换等），执行速度快  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一直占用CPU，如果锁很久也得不到，就会浪费过多的cpu资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;p&gt;pthread库就支持spinlock，提供的API如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;pthread.h&amp;gt;  &lt;/span&gt;

&lt;span class="c1"&gt;//创建和初始化  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pshared&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// pshared 可选： PTHREAD_PROCESS_SHARED 或 PTHREAD_PROCESS_PRIVATE  &lt;/span&gt;
&lt;span class="c1"&gt;//销毁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//加锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_trylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//解锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="spinlock"></category><category term="multi-thread"></category></entry><entry><title>core dump相关</title><link href="http://particle128.com/posts/2013/10/core-dump.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/core-dump.html</id><summary type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;当程序异常退出（接受到内核或其他程序的某种信号，比如SIGTERM，SIGKILL等）的时候，一般会将出错时候的内存状况保存到core file中，以帮助开发者了解程序崩溃的原因。&lt;br /&gt;
即core memory（内存最开始使用线圈做的），其实就是内存。core dump就是内存倾倒的意思。  &lt;/p&gt;
&lt;h3&gt;ubuntu下使能core dump功能&lt;/h3&gt;
&lt;p&gt;ubuntu下默认core文件的大小限制是0（执行ulimit -c查看），即不允许core文件产生。&lt;br /&gt;
解除限制：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited &lt;span class="c"&gt;#设置core file的限制  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -a &lt;span class="c"&gt;#查看所有限制（包括栈大小、cpu时间、虚拟内存、文件大小等）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;core文件的默认位置&lt;/h3&gt;
&lt;p&gt;查看core文件存储格式，以及ubuntu下输出结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat /proc/sys/kernel/core_pattern   
|/usr/share/apport/apport %p %s %c  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;意思是：core file文件通过管道，变做apport程序的输入。&lt;br /&gt;
后面的参数解释如下（man core）：&lt;br /&gt;
%p - insert pid into filename 添加pid&lt;br /&gt;
%u - insert current uid into filename 添加当前uid&lt;br /&gt;
%g - insert current gid into filename 添加当前gid&lt;br /&gt;
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号&lt;br /&gt;
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间&lt;br /&gt;
%h - insert hostname where the coredump happened into filename 添加主机名&lt;br /&gt;
%e - insert coredumping executable name into filename 添加命令名&lt;br /&gt;
%c - core  file  size soft resource limit of crashing process 添加core文件大小限制  &lt;/p&gt;
&lt;h3&gt;apport&lt;/h3&gt;
&lt;p&gt;介绍它的页面：&lt;a href="https://wiki.ubuntu.com/Apport"&gt;link&lt;/a&gt;&lt;br /&gt;
需要注意的地方：&lt;br /&gt;
1. apport把core file保存在 /var/crash/ 目录下&lt;br /&gt;
2. ubuntu12.04之后，apport才默认开启。之前的版本都需要设置 /etc/default/apport 文件&lt;br /&gt;
3. apport的日志文件保存在 /var/log/apport.log 一般日志文件都放置于此，例如syslog，redis&lt;br /&gt;
4. 自己的程序，只有打包成.deb文件，并被安装之后，apport才会保存其core file到/var/crash。否则不生成core file，log文件里会报错如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;executable does not belong to a package, ignoring  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重定向core file&lt;/h3&gt;
&lt;p&gt;既然apport只能处理ubuntu下的包程序，那么我们就不让apport干涉core file的产生了。&lt;br /&gt;
执行如下命令：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited  
&lt;span class="c"&gt;# echo &amp;quot;core.%e.%p&amp;quot; &amp;gt; /proc/sys/kernel/core_pattern  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，每次core file都会在当前目录下保存了。  &lt;/p&gt;
&lt;h3&gt;gdb定位错误位置&lt;/h3&gt;
&lt;p&gt;产生core file之后（姑且命名为core.a.out.11111），直接vi查看其内容会一头雾水。&lt;br /&gt;
执行如下命令，定位程序崩溃的位置：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;gdb -c core.a.out.11111  
&lt;span class="o"&gt;(&lt;/span&gt;gdb&lt;span class="o"&gt;)&lt;/span&gt; where  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;程序中捕捉崩溃事件&lt;/h3&gt;
&lt;p&gt;sigaction()函数指定信号的处理函数（比如SIGSEGV），然后在处理函数中打log，发送错误报告之类的。  &lt;/p&gt;</summary><category term="core dump"></category></entry><entry><title>Linux权限小结</title><link href="http://particle128.com/posts/2013/09/authority.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/authority.html</id><summary type="html">&lt;h4&gt;1、文件权限：针对文件的实际数据（data block中的内容）&lt;/h4&gt;
&lt;p&gt;r：可以查看文件内容&lt;br /&gt;
w：可以修改文件内容&lt;br /&gt;
x：可以执行文件内容  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; &lt;br /&gt;
一个文件可以仅有r权限，修改需要强制写入，比如vim下:w!，然后再:q。&lt;/p&gt;
&lt;h4&gt;2、目录权限：针对目录的结构，实际也是目录的实际数据（data block里存的就是目录里的文件列表&amp;lt;文件名，inode号&amp;gt;）&lt;/h4&gt;
&lt;p&gt;r：可以查看目录结构（ls）&lt;br /&gt;
w：可以修改目录结构（如touch新文件，rm文件，其他无出其右：mv重命名是先删再增）&lt;br /&gt;
x：可以把目录当作工作目录（cd。即使不cd进去，在目录下进行各种操作比如读、修改文件也要有目录的x权限）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
一个目录开放浏览，需要r+x权限。&lt;br /&gt;
有r没x，ls可以看到文件名，不能cd进入，ls -l看到其他属性都是问号；&lt;br /&gt;
有x没r，可以cd进去，不能ls查看内容。【所谓不能，是指执行该操作会返回“Permission denied”】&lt;br /&gt;
仅有w，无法修改目录结构，因为命令进入不进去这个目录，需要x权限配合w才能完成修改目录的作用。&lt;/p&gt;
&lt;h4&gt;3、umask：初始权限中需要屏蔽的部分，ubuntu12.04下默认是0002，去掉其他用户的写权限。&lt;/h4&gt;
&lt;p&gt;文件初始权限：-rw-rw-rw- （0666）&lt;br /&gt;
文件默认权限：初始-umask。0666-0002=0664，即-rw-rw-r--&lt;br /&gt;
文件夹初始权限：drwxrwxrwx（0777）&lt;br /&gt;
文件夹默认权限：初始-umask。0777-0002=0775，即drwxrwxr-x  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
所有者和同组用户权限相同，其他用户剥夺写权限。&lt;br /&gt;
命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="mo"&gt;022&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;修改&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;默认值&lt;/span&gt;
&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;以字符的形式显示&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;之后的效果，&lt;/span&gt;&lt;span class="mo"&gt;0002&lt;/span&gt;&lt;span class="err"&gt;对应&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rx&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4、三个特殊权限：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SUID（SetUID）&lt;/strong&gt;：ls-l显示所有者权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/passwd。普通用户可以执行passwd修改自己的密码，执行该程序后默认UID变为root（passwd的所有者），因此可以修改仅仅root可读的/etc/shadow&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGID（SetGID）&lt;/strong&gt;：ls-l显示组权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/locate。普通用户执行locate定位文件，执行该程序后默认GID变为slocate（locate的所属用户组），因此可以查询仅仅mlocate组内用户可以访问的mlocate.db&lt;br /&gt;
另：作用于目录时，相当于用户cd进该目录后有效用户组就变成该目录的用户组了，影响此后新建的文件的所属用户组。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SBIT（Sticky Bit）&lt;/strong&gt;：ls-l显示其他权限x-&amp;gt;t&lt;br /&gt;
例子：/tmp。用户进入/tmp下新建的文件，只有root和文件所有者可以删除，其他用户即使对/tmp有w权限也没用。&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Linux下的用户和用户组小结</title><link href="http://particle128.com/posts/2013/09/linux_user.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/linux_user.html</id><summary type="html">&lt;h3&gt;1. 修改文件的相应属性&lt;/h3&gt;
&lt;h4&gt;chown 修改文件所有者&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chown mashu:mashu aa.txt &lt;span class="c"&gt;# 或chown mashu.mashu aa.txt 同时修改所有者和组&lt;/span&gt;
chown mashu aa.txt &lt;span class="c"&gt;# 修改所有者&lt;/span&gt;
chown .mashu aa.txt &lt;span class="c"&gt;# 修改组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chgrp 修改文件所属用户组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chgrp mashu aa.txt 修改组
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chmod 修改权限&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod 777 aa.txt   
chmod a+r aa.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 3个重要文件&lt;/h3&gt;
&lt;h4&gt;/etc/passwd&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的UID，初始用户组GID，说明，home dir，shell  &lt;/p&gt;
&lt;h4&gt;/etc/shadow&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的密码（加密后）  &lt;/p&gt;
&lt;h4&gt;/etc/group&lt;/h4&gt;
&lt;p&gt;记录 组名 对应的GID，组内用户（不包括初始用户组是该组的用户，因为/etc/passwd里有了）&lt;/p&gt;
&lt;h3&gt;3. 概念区分&lt;/h3&gt;
&lt;h4&gt;初始用户组：&lt;/h4&gt;
&lt;p&gt;useradd或usermod，-g参数后的组名。保存在/etc/passwd中。&lt;br /&gt;
实际意义是，/etc/group里少写一个用户名。。。  &lt;/p&gt;
&lt;h4&gt;有效用户组：&lt;/h4&gt;
&lt;p&gt;groups显示的第一用户组。可以通过newgrp重设。具体哪个文件保存不详。&lt;br /&gt;
实际意义是，用户新建文件时文件的所属用户组，就是有效用户组。&lt;/p&gt;
&lt;h3&gt;4. 用户分类&lt;/h3&gt;
&lt;p&gt;ubuntu12.04下，根据/etc/login.defs&lt;br /&gt;
UID=0  系统管理员&lt;br /&gt;
UID in {100,999} 系统用户  (SYS_UID_MIN - SYS_UID_MAX)&lt;br /&gt;
UID in {1000,60000} 可登录用户  (UID_MIN - UID_MAX)  &lt;/p&gt;
&lt;h3&gt;5. linux命令&lt;/h3&gt;
&lt;h4&gt;1) useradd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;useradd -u &lt;span class="o"&gt;[&lt;/span&gt;UID&lt;span class="o"&gt;]&lt;/span&gt; -g &lt;span class="o"&gt;[&lt;/span&gt;initial group name&lt;span class="o"&gt;]&lt;/span&gt; -G &lt;span class="o"&gt;[&lt;/span&gt;other group name&lt;span class="o"&gt;]&lt;/span&gt; -d &lt;span class="o"&gt;[&lt;/span&gt;home dir&lt;span class="o"&gt;]&lt;/span&gt; -s &lt;span class="o"&gt;[&lt;/span&gt;shell&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;没有参数，默认是可登录用户（有shell，有home dir），同名初始用户组。&lt;br /&gt;
-r 建立系统用户（不能登录，没有shell，默认没有home dir，除非修改/etc/login.defs文件）&lt;/p&gt;
&lt;h4&gt;2) usermod&lt;/h4&gt;
&lt;p&gt;同useradd&lt;/p&gt;
&lt;h4&gt;3) passwd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;passwd &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt; 
passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无参数修改自己的密码&lt;/p&gt;
&lt;h4&gt;4) userdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;userdel -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加上-r，连同主文件夹也一同删除&lt;/p&gt;
&lt;h4&gt;5) groupadd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupadd -g &lt;span class="o"&gt;[&lt;/span&gt;GID&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-g 指定GID，-r 创建系统组&lt;/p&gt;
&lt;h4&gt;6) groupdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupdel &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category><category term="user"></category></entry></feed>