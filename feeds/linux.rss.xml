<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/linux.rss.xml" rel="self"></link><id>http://particle128.com/</id><updated>2014-04-02T00:00:00+08:00</updated><entry><title>初识自旋锁spinlock</title><link href="http://particle128.com/posts/2014/04/spinlock.html" rel="alternate"></link><updated>2014-04-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-02:posts/2014/04/spinlock.html</id><summary type="html">&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;虚拟磁盘的项目中，使用了互斥锁(mutex)来控制任务队列的访问。但是mutex开销过大，让线程池的效果大打折扣，于是发现了spinlock的存在。  &lt;/p&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;来自&lt;a href="http://en.wikipedia.org/wiki/Spinlock"&gt;wiki&lt;/a&gt;的定义：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自旋锁是一种忙等锁，它不像其他同步方式（mutex,rwlock,cond）一样，将不能进入临界区的线程阻塞，并通过上下文切换，让另一个可以执行的线程在该cpu上运行。该锁会一直循环检查，直到别的线程释放。  &lt;/p&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多处理器（或者多核） ——否则，线程会进入死循环，程序死锁  &lt;/li&gt;
&lt;li&gt;临界区代码执行很快   ——比如就几行代码，且没有系统调用  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优点和缺点&lt;/h3&gt;
&lt;p&gt;优点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了上下文切换的繁重开销（用户态-&amp;gt;内核态，保护现场，可能页置换等），执行速度快  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一直占用CPU，如果锁很久也得不到，就会浪费过多的cpu资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;p&gt;pthread库就支持spinlock，提供的API如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;pthread.h&amp;gt;  &lt;/span&gt;

&lt;span class="c1"&gt;//创建和初始化  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pshared&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// pshared 可选： PTHREAD_PROCESS_SHARED 或 PTHREAD_PROCESS_PRIVATE  &lt;/span&gt;
&lt;span class="c1"&gt;//销毁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//加锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_trylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//解锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="spinlock"></category><category term="multi-thread"></category></entry><entry><title>Linux下的用户和用户组小结</title><link href="http://particle128.com/posts/2013/12/linux_user.html" rel="alternate"></link><updated>2013-12-27T22:09:30+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-27:posts/2013/12/linux_user.html</id><summary type="html">&lt;h3&gt;1. 修改文件的相应属性&lt;/h3&gt;
&lt;h4&gt;chown 修改文件所有者&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chown mashu:mashu aa.txt &lt;span class="c"&gt;# 或chown mashu.mashu aa.txt 同时修改所有者和组&lt;/span&gt;
chown mashu aa.txt &lt;span class="c"&gt;# 修改所有者&lt;/span&gt;
chown .mashu aa.txt &lt;span class="c"&gt;# 修改组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chgrp 修改文件所属用户组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chgrp mashu aa.txt 修改组
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chmod 修改权限&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod 777 aa.txt   
chmod a+r aa.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 3个重要文件&lt;/h3&gt;
&lt;h4&gt;/etc/passwd&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的UID，初始用户组GID，说明，home dir，shell  &lt;/p&gt;
&lt;h4&gt;/etc/shadow&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的密码（加密后）  &lt;/p&gt;
&lt;h4&gt;/etc/group&lt;/h4&gt;
&lt;p&gt;记录 组名 对应的GID，组内用户（不包括初始用户组是该组的用户，因为/etc/passwd里有了）&lt;/p&gt;
&lt;h3&gt;3. 概念区分&lt;/h3&gt;
&lt;h4&gt;初始用户组：&lt;/h4&gt;
&lt;p&gt;useradd或usermod，-g参数后的组名。保存在/etc/passwd中。&lt;br /&gt;
实际意义是，/etc/group里少写一个用户名。。。  &lt;/p&gt;
&lt;h4&gt;有效用户组：&lt;/h4&gt;
&lt;p&gt;groups显示的第一用户组。可以通过newgrp重设。具体哪个文件保存不详。&lt;br /&gt;
实际意义是，用户新建文件时文件的所属用户组，就是有效用户组。&lt;/p&gt;
&lt;h3&gt;4. 用户分类&lt;/h3&gt;
&lt;p&gt;ubuntu12.04下，根据/etc/login.defs&lt;br /&gt;
UID=0  系统管理员&lt;br /&gt;
UID in {100,999} 系统用户  (SYS_UID_MIN - SYS_UID_MAX)&lt;br /&gt;
UID in {1000,60000} 可登录用户  (UID_MIN - UID_MAX)  &lt;/p&gt;
&lt;h3&gt;5. linux命令&lt;/h3&gt;
&lt;h4&gt;1) useradd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;useradd -u &lt;span class="o"&gt;[&lt;/span&gt;UID&lt;span class="o"&gt;]&lt;/span&gt; -g &lt;span class="o"&gt;[&lt;/span&gt;initial group name&lt;span class="o"&gt;]&lt;/span&gt; -G &lt;span class="o"&gt;[&lt;/span&gt;other group name&lt;span class="o"&gt;]&lt;/span&gt; -d &lt;span class="o"&gt;[&lt;/span&gt;home dir&lt;span class="o"&gt;]&lt;/span&gt; -s &lt;span class="o"&gt;[&lt;/span&gt;shell&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;没有参数，默认是可登录用户（有shell，有home dir），同名初始用户组。&lt;br /&gt;
-r 建立系统用户（不能登录，没有shell，默认没有home dir，除非修改/etc/login.defs文件）&lt;/p&gt;
&lt;h4&gt;2) usermod&lt;/h4&gt;
&lt;p&gt;同useradd&lt;/p&gt;
&lt;h4&gt;3) passwd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;passwd &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt; 
passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无参数修改自己的密码&lt;/p&gt;
&lt;h4&gt;4) userdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;userdel -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加上-r，连同主文件夹也一同删除&lt;/p&gt;
&lt;h4&gt;5) groupadd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupadd -g &lt;span class="o"&gt;[&lt;/span&gt;GID&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-g 指定GID，-r 创建系统组&lt;/p&gt;
&lt;h4&gt;6) groupdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupdel &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category><category term="user"></category></entry><entry><title>DNS相关</title><link href="http://particle128.com/posts/2013/12/dns.html" rel="alternate"></link><updated>2013-12-27T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-27:posts/2013/12/dns.html</id><summary type="html">&lt;p&gt;信息来源：谢希仁-计算机网络(第5版)，wikipedia，unp，tcp/ip详解。  &lt;/p&gt;
&lt;h3&gt;Domain Name System&lt;/h3&gt;
&lt;p&gt;host name &amp;lt; - &amp;gt; ip address&lt;br /&gt;
主机名可以是不完全域名，比如solaris；也可以是FQDN(fully-qualified domain name)，以点号结尾的域名，如solaris.unpbook.com. 。另：如果不完全域名中包含2个或以上的点号，则认为是完全限定域名。&lt;br /&gt;
如果主机名使用不完全域名，需要在/etc/resolv.conf文件里配置search unpbook.com或domain unpbook.com，以便帮助完成全限定域名的补全。  &lt;/p&gt;
&lt;h3&gt;名字/域名服务器层次结构：&lt;/h3&gt;
&lt;p&gt;root name server 根域名服务器（无名）&lt;br /&gt;
TLD(tol-level-domain) name server 顶级域名服务器（包括特殊域arpa，普通域com等，和国家域cn等）&lt;br /&gt;
authoritative name server 授权域名服务器&lt;br /&gt;
local name server 本地域名服务器  &lt;/p&gt;
&lt;h3&gt;DNS查询过程：&lt;/h3&gt;
&lt;p&gt;本地主机高速缓存里有记录的话，不用查找了。&lt;br /&gt;
本地主机缓存里记录过期或没有，以递归方式查找local。&lt;br /&gt;
local没有记录的话，一般以迭代方式分别查找root,TLD,authoritative，直到找到，返回给local。&lt;br /&gt;
以本地主机的视角，就看到查找local并得到local的回应了，local的查找过程时透明的。  &lt;/p&gt;
&lt;h3&gt;解析器的配置文件/etc/resolv.conf：&lt;/h3&gt;
&lt;p&gt;格式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lan&lt;/span&gt;  
&lt;span class="n"&gt;nameserver&lt;/span&gt; &lt;span class="mf"&gt;172.16.1.254&lt;/span&gt;  
&lt;span class="n"&gt;nameserver&lt;/span&gt; &lt;span class="mf"&gt;172.16.2.254&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;资源记录（resource record）&lt;/h3&gt;
&lt;p&gt;都可以简略理解成&amp;lt;域名，数据&amp;gt;对，数据有时候是ip地址，有时候是域名。PTR也不例外。&lt;br /&gt;
DNS中的常用RR：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A（address）：host name-&amp;gt;ipv4&lt;br /&gt;
AAAA：host name-&amp;gt;ipv6&lt;br /&gt;
PTR(pointer)：ipv4/ipv6-&amp;gt;hostname&lt;br /&gt;
MX(mail exchanger)：host name-&amp;gt;its mail exchanger&lt;br /&gt;
CNAME(canonical name):server name-&amp;gt; host name&lt;br /&gt;
NS（name server）:domain-&amp;gt;authoritive name server of this domain  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;指针查询&lt;/h3&gt;
&lt;p&gt;一个组织申请一个域名的时候，同时给其分配一个in-addr.arpa下的域名。&lt;br /&gt;
比如申请210.30.97.139的域名为www.mashu.com，那么名字服务器上会增加两条记录：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;                   &lt;span class="n"&gt;A&lt;/span&gt;      &lt;span class="mf"&gt;210.30.97.139&lt;/span&gt;  
&lt;span class="mf"&gt;139.97.30.210&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arpa&lt;/span&gt; &lt;span class="n"&gt;PTR&lt;/span&gt; &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，ip地址反向查找域名就直接找PTR记录即可，而不用遍历所有A记录了。&lt;br /&gt;
注：我理解的逆序有一定好处是，一个区域的ip地址高字节都是相同的，比如都是210.30，区分每一台主机的主要是低位的字节，所以把低字节排在前面，查找更迅速。&lt;br /&gt;
设想学校的local：逆序，第一个字节符合要求的就1个记录；正序，第一个字节所有记录都匹配。  &lt;/p&gt;
&lt;h3&gt;传输层协议：&lt;/h3&gt;
&lt;p&gt;DNS请求一般是解析器（resolver）发出的，解析器是应用程序的一部分（以模块的形式加入应用程序），而不是内核的一部分。&lt;br /&gt;
DNS一般都使用UDP数据报，只有2个特例：&lt;br /&gt;
1）DNS响应报文超过UDP的上限512B，解析器就会用TCP重发原来的请求。&lt;br /&gt;
2）一个域的辅助名字服务器从主名字服务器上拉取数据的时候，区域传送使用TCP。  &lt;/p&gt;
&lt;h3&gt;备份&lt;/h3&gt;
&lt;p&gt;除了本地名字服务器，网上有OpenDNS和googleDNS服务器的ip地址，应该是被墙了，现在访问不到。所以一旦学校的本地名字服务器崩了，就没办法通过主机名访问外网了。&lt;br /&gt;
常用网站ip地址：&lt;br /&gt;
google : 74.125.31.106  173.194.45.20 &lt;br /&gt;
yinxiang : 119.254.30.32/Home.action&lt;br /&gt;
youdao dict : 121.195.178.201  &lt;/p&gt;
&lt;h3&gt;查看DNS解析的linux工具：&lt;/h3&gt;
&lt;p&gt;[1] host&lt;br /&gt;
格式：$ host [-t type]{name} [server]&lt;br /&gt;
说明：&lt;br /&gt;
DNS解析工具。&lt;br /&gt;
name如果是一个主机名，就解析出其ip地址；name如果是ip地址，就反解析出其主机名。&lt;br /&gt;
server可选参数。默认从/etc/resolv.conf读取名字服务器（nameserver），加上该参数（ip地址或主机名形式均可）后，就采用该名字服务器。&lt;br /&gt;
-t后面接类型，比如cname，a等&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$host&lt;/span&gt; google.com    
&lt;span class="nv"&gt;$host&lt;/span&gt; google.com 202.118.66.6    
&lt;span class="nv"&gt;$host&lt;/span&gt; 127.0.0.1  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[2] nslookup&lt;br /&gt;
格式：$ nslookup [name] [server]&lt;br /&gt;
说明：交互式(interactve)DNS解析工具，输入nslookup之后出现交互式操作提示符“&amp;gt;”，之后就可以多次输入需要解析的host name。给出的解析结果相对host详细一些。  &lt;/p&gt;
&lt;p&gt;[3] dig(domain information groper)&lt;br /&gt;
格式： $ dig [server] {name} [type]&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com （默认只寻找资源类型A）  
&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com ANY  
&lt;span class="nv"&gt;$dig&lt;/span&gt; google.com MX  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="dns"></category></entry><entry><title>core dump相关</title><link href="http://particle128.com/posts/2013/10/core-dump.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/core-dump.html</id><summary type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;当程序异常退出（接受到内核或其他程序的某种信号，比如SIGTERM，SIGKILL等）的时候，一般会将出错时候的内存状况保存到core file中，以帮助开发者了解程序崩溃的原因。&lt;br /&gt;
即core memory（内存最开始使用线圈做的），其实就是内存。core dump就是内存倾倒的意思。  &lt;/p&gt;
&lt;h3&gt;ubuntu下使能core dump功能&lt;/h3&gt;
&lt;p&gt;ubuntu下默认core文件的大小限制是0（执行ulimit -c查看），即不允许core文件产生。&lt;br /&gt;
解除限制：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited &lt;span class="c"&gt;#设置core file的限制  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -a &lt;span class="c"&gt;#查看所有限制（包括栈大小、cpu时间、虚拟内存、文件大小等）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;core文件的默认位置&lt;/h3&gt;
&lt;p&gt;查看core文件存储格式，以及ubuntu下输出结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat /proc/sys/kernel/core_pattern   
|/usr/share/apport/apport %p %s %c  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;意思是：core file文件通过管道，变做apport程序的输入。&lt;br /&gt;
后面的参数解释如下（man core）：&lt;br /&gt;
%p - insert pid into filename 添加pid&lt;br /&gt;
%u - insert current uid into filename 添加当前uid&lt;br /&gt;
%g - insert current gid into filename 添加当前gid&lt;br /&gt;
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号&lt;br /&gt;
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间&lt;br /&gt;
%h - insert hostname where the coredump happened into filename 添加主机名&lt;br /&gt;
%e - insert coredumping executable name into filename 添加命令名&lt;br /&gt;
%c - core  file  size soft resource limit of crashing process 添加core文件大小限制  &lt;/p&gt;
&lt;h3&gt;apport&lt;/h3&gt;
&lt;p&gt;介绍它的页面：&lt;a href="https://wiki.ubuntu.com/Apport"&gt;link&lt;/a&gt;&lt;br /&gt;
需要注意的地方：&lt;br /&gt;
1. apport把core file保存在 /var/crash/ 目录下&lt;br /&gt;
2. ubuntu12.04之后，apport才默认开启。之前的版本都需要设置 /etc/default/apport 文件&lt;br /&gt;
3. apport的日志文件保存在 /var/log/apport.log 一般日志文件都放置于此，例如syslog，redis&lt;br /&gt;
4. 自己的程序，只有打包成.deb文件，并被安装之后，apport才会保存其core file到/var/crash。否则不生成core file，log文件里会报错如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;executable does not belong to a package, ignoring  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重定向core file&lt;/h3&gt;
&lt;p&gt;既然apport只能处理ubuntu下的包程序，那么我们就不让apport干涉core file的产生了。&lt;br /&gt;
执行如下命令：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited  
&lt;span class="c"&gt;# echo &amp;quot;core.%e.%p&amp;quot; &amp;gt; /proc/sys/kernel/core_pattern  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，每次core file都会在当前目录下保存了。  &lt;/p&gt;
&lt;h3&gt;gdb定位错误位置&lt;/h3&gt;
&lt;p&gt;产生core file之后（姑且命名为core.a.out.11111），直接vi查看其内容会一头雾水。&lt;br /&gt;
执行如下命令，定位程序崩溃的位置：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;gdb -c core.a.out.11111  
&lt;span class="o"&gt;(&lt;/span&gt;gdb&lt;span class="o"&gt;)&lt;/span&gt; where  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;程序中捕捉崩溃事件&lt;/h3&gt;
&lt;p&gt;sigaction()函数指定信号的处理函数（比如SIGSEGV），然后在处理函数中打log，发送错误报告之类的。  &lt;/p&gt;</summary><category term="core dump"></category></entry><entry><title>Linux权限小结</title><link href="http://particle128.com/posts/2013/09/authority.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/authority.html</id><summary type="html">&lt;h4&gt;1、文件权限：针对文件的实际数据（data block中的内容）&lt;/h4&gt;
&lt;p&gt;r：可以查看文件内容&lt;br /&gt;
w：可以修改文件内容&lt;br /&gt;
x：可以执行文件内容  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; &lt;br /&gt;
一个文件可以仅有r权限，修改需要强制写入，比如vim下:w!，然后再:q。&lt;/p&gt;
&lt;h4&gt;2、目录权限：针对目录的结构，实际也是目录的实际数据（data block里存的就是目录里的文件列表&amp;lt;文件名，inode号&amp;gt;）&lt;/h4&gt;
&lt;p&gt;r：可以查看目录结构（ls）&lt;br /&gt;
w：可以修改目录结构（如touch新文件，rm文件，其他无出其右：mv重命名是先删再增）&lt;br /&gt;
x：可以把目录当作工作目录（cd。即使不cd进去，在目录下进行各种操作比如读、修改文件也要有目录的x权限）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
一个目录开放浏览，需要r+x权限。&lt;br /&gt;
有r没x，ls可以看到文件名，不能cd进入，ls -l看到其他属性都是问号；&lt;br /&gt;
有x没r，可以cd进去，不能ls查看内容。【所谓不能，是指执行该操作会返回“Permission denied”】&lt;br /&gt;
仅有w，无法修改目录结构，因为命令进入不进去这个目录，需要x权限配合w才能完成修改目录的作用。&lt;/p&gt;
&lt;h4&gt;3、umask：初始权限中需要屏蔽的部分，ubuntu12.04下默认是0002，去掉其他用户的写权限。&lt;/h4&gt;
&lt;p&gt;文件初始权限：-rw-rw-rw- （0666）&lt;br /&gt;
文件默认权限：初始-umask。0666-0002=0664，即-rw-rw-r--&lt;br /&gt;
文件夹初始权限：drwxrwxrwx（0777）&lt;br /&gt;
文件夹默认权限：初始-umask。0777-0002=0775，即drwxrwxr-x  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
所有者和同组用户权限相同，其他用户剥夺写权限。&lt;br /&gt;
命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="mo"&gt;022&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;修改&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;默认值&lt;/span&gt;
&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;以字符的形式显示&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;之后的效果，&lt;/span&gt;&lt;span class="mo"&gt;0002&lt;/span&gt;&lt;span class="err"&gt;对应&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rx&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4、三个特殊权限：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SUID（SetUID）&lt;/strong&gt;：ls-l显示所有者权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/passwd。普通用户可以执行passwd修改自己的密码，执行该程序后默认UID变为root（passwd的所有者），因此可以修改仅仅root可读的/etc/shadow&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGID（SetGID）&lt;/strong&gt;：ls-l显示组权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/locate。普通用户执行locate定位文件，执行该程序后默认GID变为slocate（locate的所属用户组），因此可以查询仅仅mlocate组内用户可以访问的mlocate.db&lt;br /&gt;
另：作用于目录时，相当于用户cd进该目录后有效用户组就变成该目录的用户组了，影响此后新建的文件的所属用户组。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SBIT（Sticky Bit）&lt;/strong&gt;：ls-l显示其他权限x-&amp;gt;t&lt;br /&gt;
例子：/tmp。用户进入/tmp下新建的文件，只有root和文件所有者可以删除，其他用户即使对/tmp有w权限也没用。&lt;/p&gt;</summary><category term="linux"></category></entry></feed>