<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/note.atom.xml" rel="self"></link><id>http://particle128.com/</id><updated>2015-04-24T21:59:40+08:00</updated><entry><title>C++11专题：智能指针</title><link href="http://particle128.com/posts/2015/04/smart-ptr.html" rel="alternate"></link><updated>2015-04-24T21:59:40+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-24:posts/2015/04/smart-ptr.html</id><summary type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;C++从C语言那里引入了指针类型，即所谓内建指针（built-in pointer）。传统的动态内存分配和释放(new &amp;amp; delete)也都是基于指针的，容易出如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;忘记delete，内存/资源泄露&lt;/li&gt;
&lt;li&gt;两次delete同一个指针，未定义&lt;/li&gt;
&lt;li&gt;delete之后的指针继续使用，未定义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，这些问题，很难调试，比如你delete了一个指针之后，堆上的同一块区域后来又被分配出去，那么你下次delete可能没有运行时错误，但是堆上的空闲链表却被你破坏了，之后的程序可能出现非常诡异的问题。&lt;/p&gt;
&lt;h2&gt;意义&lt;/h2&gt;
&lt;p&gt;智能指针，如果&lt;em&gt;使用得当&lt;/em&gt;，可以防止以上三个问题，因为delete操作交给析构函数来进行(问题1、2)，并且析构之后的智能指针被自动置nullptr(问题3)。另外，通过不同类型的智能指针，可以实现普通指针不能实现的额外好处，比如共享资源(&lt;code&gt;shared_ptr&lt;/code&gt;)、专用资源(&lt;code&gt;unique_ptr&lt;/code&gt;)等。&lt;/p&gt;
&lt;p&gt;这里说的&lt;em&gt;使用得当&lt;/em&gt;是指，按照惯例来使用智能指针：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要用同一个内建指针初始化或reset多个智能指针&lt;/li&gt;
&lt;li&gt;不要delete get()返回的指针&lt;/li&gt;
&lt;li&gt;不要用get()返回的指针初始化或reset另一个智能指针&lt;/li&gt;
&lt;li&gt;get()返回的指针，在智能指针所指对象被释放后，就不能使用了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;用法&lt;/h2&gt;
&lt;h3&gt;shared_ptr&lt;/h3&gt;
&lt;p&gt;共享资源，带引用计数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;del&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; (string *ele) {delete ele;};
    // construct
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p1;
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p2(new string);
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; pd1(new string, del); // 此处不能用auto,auto只能推导复制构造!
    // copy construct
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p4(p2);
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p5 = make_shared&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(&amp;quot;1&amp;quot;);
    auto p6 = make_shared&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;();
    auto p7(p6);
    // assign
    p1 = p2;
    // reset：用内建指针初始化和reset的格式一致
    p1.reset();
    p1.reset(new string);
    p1.reset(new string, del);
    // unique
    if (!p1.unique()) { /*if the string pointed by p1 has other references*/
        p1.reset(new string(*p1));
    }
    *p1 += &amp;quot;1&amp;quot;; /*change the string refered by p1*/
    // swap
    swap(p1,p2);
    p1.swap(p2);
    // * -&amp;gt;
    int size = p1-&amp;gt;size();
    string s = *p1;
    // get
    string *ps = p1.get();
    // use_count
    int n = p1.use_count();

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;unique_ptr&lt;/h3&gt;
&lt;p&gt;专用资源，资源只能被一个指针引用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;deref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;clone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;del&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; (string *ele) {delete ele;};
    // construct
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p1;
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p2(new string);
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="na"&gt;decltype&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;del&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; pd1(new string, del); 
    // reset：用内建指针初始化和reset的格式一致
    p1.reset();
    p1.reset(new string);
    // swap
    swap(p1,p2);
    p1.swap(p2);
    // * -&amp;gt;
    int size = p1-&amp;gt;size();
    string s = *p1;
    // get
    string *ps = p1.get();
    // release
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p3(p1.release());
    p2.reset(p1.release()); // p1 release之后指向nullptr
    p1 = nullptr;

    // 一般情况下，unique_ptr不能拷贝构造和赋值
    // 只有一个例外：当unique_ptr马上要被析构的时候
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; ptr1 = clone(string(&amp;quot;123&amp;quot;)); // 最常见用法：函数返回
    string res = deref(unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(new string(&amp;quot;123&amp;quot;))); // string res1 = deref(p1); //不行
    auto ptr2((unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;())); // auto ptr2(p1); //不行
    ptr1 = unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(); // ptr1 = p1; // 不行

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;指向共享资源的指针，但是不增加引用计数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="c1"&gt;// construct&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// copy construct&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// assign&lt;/span&gt;
    &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// reset&lt;/span&gt;
    &lt;span class="nx"&gt;p3.reset&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// use_count&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.use_count&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// expired&lt;/span&gt;
    &lt;span class="nx"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.expired&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// use_count() == 0 时返回true&lt;/span&gt;
    &lt;span class="c1"&gt;// lock&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.lock&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;sp1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="c++11"></category></entry><entry><title>C++11专题：constexpr类型</title><link href="http://particle128.com/posts/2015/04/constexpr.html" rel="alternate"></link><updated>2015-04-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-15:posts/2015/04/constexpr.html</id><summary type="html">&lt;p&gt;代码是最好的文档，所以，本系列主要在代码中讲解。&lt;/p&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;C++中的const变量，包括编译时常量（compile-time constants）和运行时常量（runtime constants）。其中，编译时常量又叫常量表达式（constant expression），只有初始化式也是常量表达式的const变量才是常量表达式。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;const变量不一定是常量表达式，所以，const变量不一定能用在一些需要常量表达式的地方，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 非常量表达式，后面的(1)~(4)均编译出错&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// （1）初始化数组大小，标准不支持，但是g++支持&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;: &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// （2）case表达式&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// （3）枚举类型初始化&lt;/span&gt;
&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// （4）模板非类型参数的实例化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;意义&lt;/h2&gt;
&lt;p&gt;有时候，我们想定义一个常量表达式，但是不好判断初始化式（const变量组成的表达式）是不是常量表达式，只能把初始化式中的const变量都&lt;em&gt;追踪&lt;/em&gt;一遍，因为可能编译过程非常耗时，不能轻易编译。因此，C++11增加了常量表达式类型（constexpr类型）。这样，只要我们确保初始化式完全由字面常量和constexpr常量构成，就可以确定初始化是常量表达式，而不用对初始化式中的每个变量进行追踪。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// c++11之前&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//若 const int a = 10 + fun()则x不是&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//需要追踪a，b，c，d才能搞清楚x是不是常量表达式&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// c++11&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//确保c和d是constexpr即可&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;用法&lt;/h2&gt;
&lt;p&gt;constexpr只能修饰字面值类型（literal type，即算术/指针/引用类型），用常量表达式或constexpr函数返回值初始化，用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 字面类 要求&lt;/span&gt;
&lt;span class="c1"&gt;// 1) 是聚集类(aggregate class：所有成员都是public，没有构造函数、类内初始化、基类、虚函数)&lt;/span&gt;
&lt;span class="c1"&gt;// 2) 不是聚集类，但是满足如下4个条件&lt;/span&gt;
&lt;span class="c1"&gt;// (1) 成员都是字面类型&lt;/span&gt;
&lt;span class="c1"&gt;// (2) 至少包含一个constexpr构造函数（函数体为空）&lt;/span&gt;
&lt;span class="c1"&gt;// (3) 若含有类内初始化，内建类型成员用constexpr初始化，类类型用constexpr构造函数初始化&lt;/span&gt;
&lt;span class="c1"&gt;// (4) 使用默认析构函数&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;geta&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getb&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
    &lt;span class="nl"&gt;private:&lt;/span&gt;
        &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// constexpr函数 要求&lt;/span&gt;
&lt;span class="c1"&gt;// (1) 参数和返回值都是字面值类型（算术、指针和引用类型，或字面类类型）&lt;/span&gt;
&lt;span class="c1"&gt;// (2) 函数体只有一条执行语句，即return语句&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geta&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getb&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// constexpr指针/引用指向的变量只能是全局变量或静态变量，编译时地址已知(data段)。&lt;/span&gt;
&lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 1. 用常量表达式初始化&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (1) 算术类型，包括bool,short,int,double...&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (2) 指针类型，const修饰指针，而不是char&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y1&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ry&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (3) 引用类型&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rz&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ry1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rz1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 2. 用constexpr函数返回值初始化（必须满足constexpr函数的参数都是常量表达式）&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// int i=10, j=5; constexpr int f1 = fun(i, i); // 用非常量表达式调用constexpr函数，返回结果也不是常量表达式&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="c++11"></category></entry><entry><title>C专家编程-笔记(2)</title><link href="http://particle128.com/posts/2015/04/ExpertC(2).html" rel="alternate"></link><updated>2015-04-11T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-11:posts/2015/04/ExpertC(2).html</id><summary type="html">&lt;h3&gt;第五章  对链接的思考&lt;/h3&gt;
&lt;p&gt;&lt;img alt="5-1" src="http://particle128.com/images/expert_c_5_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第六章  运动的诗章：运行时数据结构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="6-1" src="http://particle128.com/images/expert_c_6_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第七章  对内存的思考&lt;/h3&gt;
&lt;p&gt;&lt;img alt="7-1" src="http://particle128.com/images/expert_c_7_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第九、十章  再论数组、再论指针&lt;/h3&gt;
&lt;p&gt;&lt;img alt="9-1" src="http://particle128.com/images/expert_c_9_1.png" /&gt;&lt;/p&gt;</summary><category term="ExpertC"></category></entry><entry><title>The Clean Coder 笔记 (4)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(4).html" rel="alternate"></link><updated>2015-04-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-06:posts/2015/04/theCleanCoder(4).html</id><summary type="html">&lt;h3&gt;Chapter10 Estimation&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The Law Of Large Numbers.&lt;br /&gt;
If you break up a large task into many smaller tasks and estimate them independently, the sum of the estimates of the small tasks will be more accurate than a single estimate of the larger task. The reason for this increase in accurary is that the errors in the small tasks tend to integrate out.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把一个大任务分成一些小任务，分别估计，然后计算估计的总和，作为大任务的估计。&lt;/p&gt;
&lt;h3&gt;Chapter13 Teams and Projects&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;It makes no sense to tell a programmer to devote half their time to project A and the rest of their time to Project B.  &lt;/p&gt;
&lt;p&gt;Teams are harder to build than projects. Therefore, it is better to form persistent teams that move together from one project to the next and can take on more than one project at a time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Appendix A Tooling&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;There was day when I was known as a vi 'god', but those days are long gone. I use vi from time to time if I need to do a quick edit of a text file. But the amount of true coding I have done in vi in the last 10 years is vanishingly small.&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (3)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(3).html" rel="alternate"></link><updated>2015-04-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-05:posts/2015/04/theCleanCoder(3).html</id><summary type="html">&lt;h3&gt;Chapter6 Practicing&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Turnaround Time. &lt;br /&gt;
Doing anything quickly requires practice. Spinning around the code/test loop quickly requires you to make very quick decisions. Making decisions quickly means being able to recognize a vast number of situations and problems and simply know that to do to address them.&lt;br /&gt;
Speed depends on practice. We choose a repertoire of problem/solution pairs and execute them over and over again until we know them cold.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习的目的就是让我们更加熟练，让一些操作成为肌肉记忆，做决定或做动作的时候不再需要思考。跟打羽毛球一样...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kata.&lt;br /&gt;
The goal is to make the perfected movements automatic and instinctive so that they are there when you need them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kata是一种练习方式，通过这种练习，让一些操作凭直觉自动产生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Practice Ethics.&lt;br /&gt;
Since your practice time is your own time, you dont' have to use th same languages or platforms that you use with your employer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习时候，用一下自己工作中不常用的语言。当自己工作中的语言已经很熟悉了，用用别的语言，让自己成为多面手。&lt;/p&gt;
&lt;h3&gt;Chapter7 Acceptance Testing&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Premature Precision.&lt;br /&gt;
The problem is that things appear different on paper than they do in a working system. WHen the business actually sees what they specified running in a system, they realize that it wasn't what they wanted at all. Once they see the requirement actually running, they have a better idea of what they really want - and it's usually not what they are seeing.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过早的精确，往往是有害的。开发者想要精确的需求说明，以便进行时间估计。需求说明无论多么明确，最后还是会修改，因为说明里的需求和真正拿出来做出的东西，是有很大区别的。看到真正的效果，客户往往又觉得应该是另外一个样子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Acceptance Test.&lt;br /&gt;
We will define acceptance tests as tests written by a collaboration of the stakeholders and the programmers in order to define when a requirement is done.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;验收测试的定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Accpetance Tests And Unit Tests.&lt;br /&gt;
Unit tests and acceptance tests are documents first, and tests second. Their primary purpose is to formally document the design, structure, and behavior of the system. The fact that they automatically verify the design, structure, and behavior that they specify is wildly useful, but the specification is their true purpose.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试的作用，首先是程序文档，其次才是测试代码。&lt;/p&gt;
&lt;h3&gt;Chapter9 Time Management&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Meetings.&lt;br /&gt;
Professionals actively resist attending meetings that don't have an immediate and significant benefit.&lt;br /&gt;
Over the years I've developed a simple rule: When the meeting gets boring, leave.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量减少开会时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arguments, Disagreements.&lt;br /&gt;
Any argument that can't be settled in five minutes can't be settled by arguing. The reason it goes on so long is that there is no clear evidence supporting either side.&lt;br /&gt;
Some folks will be passive-aggressive. They'll agree just to end the argument, and then sabotage the result by refusing to engage in the solution. This is probably the worst kind of unprofessional behavior there is. Never, ever do this. If you agree, then you must engage.&lt;br /&gt;
How do you get the data you need to settle a disagreement? Sometimes you can run experiments, or do some simulation or modeling. But sometimes the best alternative is to simply filp a coin to choose one of the two paths in question.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最不专业的做法就是同意某人的意见，以便结束争论，但之后却不按照同意的方法做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Priority Inversion.&lt;br /&gt;
Whatever the reason, you find ways to avoid doing the real work. You convince yourself that something else is more urgent, and you do that instead. This is called priority inversion.&lt;br /&gt;
Clearly this is unprofessional behavior. Professionals evaluate the priority of each task, disregarding their personal fears and desires, and execute those tasks in priority order.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要因为畏难而改变事情的优先级，这是不专业的表现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Messes.&lt;br /&gt;
At some point you realize that you made a wrong design choice when you started, and that your code doesn't scale well in the direction that the requirements are moving. This is the inflction point! You can still go back and fix the design. But you can also continue to go forward. Going back looks expensive because you'll have to rework the existing code, bug going back will never be easier than it it now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业开发者会尽早察觉mess，并尽一切可能修改它，而不是将就着在mess上继续，因为这样最终会更加糟糕。&lt;br /&gt;
但是事事不绝对，facebook在发现php性能问题的时候，并没有重头推倒用java，因为担心这会至少影响几个月网站的更新。而是，继续用php做，同时投入研发了php转C++的工具——HipHop，使php继续用于网站开发，又不影响性能。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (2)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(2).html" rel="alternate"></link><updated>2015-04-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-04:posts/2015/04/theCleanCoder(2).html</id><summary type="html">&lt;h3&gt;Chapter4 Coding&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Preparedness. &lt;br /&gt;
If you are tired or distracted, do not code. You'll only wind up redoing what you did. Instead, find a way to eliminate the distractions and settle your mind. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;累或者走神的时候，别写代码。先把糟糕的状态排除或者减轻了，再来写代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3 AM Code. &lt;br /&gt;
I remember feeling so good about myself for the long hours I was working. I remember feeling dedicated. I remember thinking that working at 3 AM is what serious professionals do. How wrong I was! &lt;br /&gt;
That code came back to bite us over and over again.&lt;br /&gt;
We never had time to rewrite this wad (so we thought) but we always seemed to have time to add another wart or patch to work around it.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作到凌晨3点，不是件值得标榜的事。写坏了代码，做一些补丁，似乎总有时间，但是重新写代码，却总是没有时间，这是件讽刺的事。重新写，精力消耗很大，还是一开始就不要把代码写坏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flow Zone.&lt;br /&gt;
You will write more code in the Zone. The problem is that you lose some of the big picture while you are in the Zone, so you will likely make decisions that you will later have to go back and reverse.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;心流状态可以让你更加专注、提高产出，但是缺点是让你失去全局观，可能因此做出一些短视的决定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Interruptions&lt;br /&gt;
There will be interruptions that distract you and cause you to lose time. When they happen, remember that enxt time you may be the one who needs to interrupt someone else. So the professional attitude is a polite willingness to be helpful.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;别怕耽误时间，乐于助人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creative Input. &lt;br /&gt;
I learned a long time ago that creative output depends on creative input. I find that the thing that best primes the pump of creative output is science fiction. For you, it might be something else.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了本职工作，多涉猎些其他方面，找到属于自己的、能激发自己创造力的活动。作者是看科幻小说，需要多尝试才知道什么是最适合自己的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Debugging Time.&lt;br /&gt;
Nowadays I spend much less time debugging than I did ten years ago. It's about a factor of ten. I achieved this truly radical reduction in debugging time by adopting the practive of Test Driven Development(TDD).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试驱动开发，减少调试时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pacing Yourself.&lt;br /&gt;
When you are working on a problem, you somtimes get so close to it that you can't see all the options. You miss elegant solutions because the creative part of your mind is suppressed by the intensity of your focus. Sometimes the best way to solve a problem is to go home, eat dinner, watch TV, go to bed, and then wake up the next morning and take shower.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;放松一下，不要一直紧盯着问题，效果反而更好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Being Late.&lt;br /&gt;
Regularly measure your progress against your goal, and come up with three fact-based end dates: best case, normal case, and worst case. Be as honest as you can about all three dates. Do not incorporate hope into your estimates. Present all three numbers to your team and stakeholders. Update these numbers daily.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最好情况，最坏情况和常规情况都要考虑在内，不要在估计中参杂希望。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hope.&lt;br /&gt;
Hope is the project killer. Hope destroys schedules and ruins reputations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望的危害。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Overtime.&lt;br /&gt;
You are not likely to get 20% more work done by working 20% more hours. What's more, overtime will certainly fail if it goes on for more than two or three weeks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加班产出不如平时，而且加班最多不能超过2~3周，否则会适得其反。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Help.&lt;br /&gt;
Programming is hard. The younger you are the less you believe this.&lt;br /&gt;
You have to carefully partition the system into small understandable units that have as little to do with each other as possible and that's hard.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年龄越大，越知道编程有多难。把一个系统分成一些易于理解、相互独立的单元，就是其中一个难点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Helping Others.&lt;br /&gt;
When you help someone, sit down and write code together. Plan to spend the better part of an hour or more. It may take less than that, but you don't want to appear to be runshed. Resign yourself to the task and give it a solid effort. You will likely come away having learned more than you gave.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;帮助别人的时候，真的划分出一块时间来，别显得很匆忙。帮助别人的过程中，自己的提高更多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Being Helped.&lt;br /&gt;
If is unprofessional to remain stuck when help is easily accessible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能寻求帮助的时候，别让自己卡在某处。&lt;/p&gt;
&lt;h3&gt;Chapter5  Test Driven Development&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Design.&lt;br /&gt;
The problem with testing code is that you have to isolate that code. It is often difficult to test a function if that function calls other function. To write that test you've got to figure out some way to decouple the function from all the others. In other words, the need to test first forces you to think about good design. &lt;br /&gt;
If you don't write your tests first, there is no force preventing you from coupling the functions together into an untestable mass. If you write your tests later, you may be able to test the inputs and the outputs of the total mass, but it will probably be quite difficult to test the individual functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试驱动，意味着先写测试，再写代码。优点主要有：测试代码成为一种更好读的文档、测试详尽从而修改代码的底气更足、测试的力度小从而调试时间更短。除此之外，还有一个优点：利于生成更好的设计。一个函数往往会调用多个函数，为了方便测试，我们需要解耦这些函数依赖，从而使测试代码能够方便测试。&lt;br /&gt;
作者明确指出，写完代码再写测试，属于防御；写完测试再写代码，属于进攻。主张TDD。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Documentation&lt;br /&gt;
Have you ever used a third-party framework? Often the third party will send you a nicely formatted manual written by tech writers. Where's the first place you go in that manual? If you are a programmer, you go to the code examples.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单元测试，可以当做最好的文档。阅读第三方库的时候，第一个要查看应该是代码示例，而不是写得很规范的一页一页的文档。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (1)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(1).html" rel="alternate"></link><updated>2015-04-03T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-03:posts/2015/04/theCleanCoder(1).html</id><summary type="html">&lt;h3&gt;Chapter1 Professionalism&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;QA Should Find Nothing.&lt;br /&gt;
Some folks use QA as the bug catchers. They send them code that they haven't thoroughtly checked. They depend on QA to find the bugs and report them back to the developers. Indeed, some companies reward QA based on the number of bugs they find. The more bugs, the greater the reward. Every time QA, or worse a user, finds a problem, you should be surprised, chagrined, and determined to prevent it from happening again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让测试人员发现不了问题，是开发人员的职责。当QA或用户发现问题，我们应该有的反应不是“哦，我去看看”，而是“吃惊和失望”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do No Harm To Structure.&lt;br /&gt;
The only way to prove that your software is easy to change is to make easy changes to it. When do you make these easy changes? All the time! Every time you look at a module you make small, lightweight chagnes to it to improve its structure. Every time you read through the code you adjust the structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次看到代码结构不够清晰的地方，就改动它一下。这需要详尽的测试的支持，改完需要运行一遍所有的测试，否则改动会很危险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Work Ethic. &lt;br /&gt;
You should plan on working 60 hours per week. The first 40 are for your employer. The remaining 20 are for you. During this remaining 20 hours you should be reading, practicing, learning, and otherwise enhancing your career. Perhaps you don't want to make that kind of commitment. That's fine, but you should not then think of yourself as a professional. Professionals spend time caring for their profession.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;成为专家，需要工作之余的付出，一周除了工作之外抽出20小时。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Continuous Learning. &lt;br /&gt;
Learn things that are outside your comfort zone. If you are a .NET programmer, learn Java. If you are Java Programmer, learn Ruby.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;持续学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Practice. &lt;br /&gt;
It is not enough to simply do your daily jonb and call that practice. Doing your daily job is performance, not practice. Practice is when you specifically exercise your skills outside of the performance of your job for the sole purpose of refining and enhancing those skills.   &lt;br /&gt;
A kata usually comes in the form of a simple programming problem to solve, such as writing the function that calculates the prime factors of an integer. The point of kata is to train your fingers and your brain. I'll do a kata or two every day, often as part of settling in to work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习，不是展示，工作上做的东西不属于练习。每天做点小程序题，锻炼手指和脑袋。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mentoring. &lt;br /&gt;
Nothing will drive facts and values into your head faster and harder than having to communicate them to people you are responsible for.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教给别人知识的过程，是把知识内化最好、最快的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identify With Your Employer/Customer. &lt;br /&gt;
As you develop a system you need to put yourself in your employer's shoes and make sure that the features you are developing are really going to address your employers' needs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要仅仅想着完成上面交给的任务，而是站在老板的角度考虑需求。&lt;/p&gt;
&lt;h3&gt;Chapter2 Saying No&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Trying. &lt;br /&gt;
The worst thing Paula could do in response to Mike's manipulations is say "OK, we'll try." If you are not holding back some energy in reserve, if you don't have a new plan, if you aren't going to change your behavior, and if you are resonably confident in your original estimate, then promising to try is fundamentally dishonest. You are lying. And you are probably doing it to save face and to avoid a confrontation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过去说过好多“我试试吧”，以后要改掉这个习惯。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every feature a client asks for will always be more complex to write than it is to explain.&lt;br /&gt;
The client will always extend the deadline. They will always want more features. They will always want change late.&lt;br /&gt;
What we have to realize is that saying yes to dropping our professional disciplines is not the way to solve problems. Dropping those disciplines is the way you create problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文中举了一个非常鲜活的例子。John很想把代码弄整洁，写出好的结构，但是开发了很多年后，发现，不论如何，都做不到这一点。因为每次经理或客户给的任务，他都一开始信心满满的答应。但是做着做着，就发现，功能远比想象中复杂、做出来的东西也许要改，最后时间紧任务重，不仅牺牲了家庭生活时间，还不得不把代码弄糟以求速度。作者认为，全是John的过错，他既然知道客户的需求随时可能变化，给的截止日期也总可以拖后，就不该逞英雄、作保证。专业的开发者会在必要的时候说不。&lt;/p&gt;
&lt;h4&gt;Chapter3 Saying Yes&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;What Does Commitments Sound Like? &lt;br /&gt;
The secret ingredient to recognizing real commitment is to look for sentences that sound like this: I will ... by ... (example: I will finish this by Tuesday.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;need/should/hope/wish/let's都不是承诺。真正的承诺是：我会在什么时间之前做完什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can only commit to things that you have full control of. For example, if your goal is to finish a module that also depends on another team, you can't commit to finish a module that also depends on another team.  &lt;br /&gt;
If it can't be done, you can still commit to actions that will bring you closer to the target.&lt;br /&gt;
Something unexpected might happen, and that's life.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只对自己有完全控制、确定可以完成的事情做承诺。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Years of experience have taught us that breaking disciplines only slows us down.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要盲目承诺，破坏纪律的逞能，最后只会让速度更慢。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>C专家编程-笔记(1)</title><link href="http://particle128.com/posts/2015/04/ExpertC(1).html" rel="alternate"></link><updated>2015-04-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-02:posts/2015/04/ExpertC(1).html</id><summary type="html">&lt;p&gt;这次写C专家编程的笔记，感觉每一章的联系性比较强，就不用一行一行的文字罗列了，尝试用Xmind的流程图和思维导图来呈现。&lt;/p&gt;
&lt;h3&gt;第一章  C:穿越时空的迷雾&lt;/h3&gt;
&lt;p&gt;&lt;img alt="1-1" src="http://particle128.com/images/expert_c_1_1.png" /&gt;
&lt;img alt="1-2" src="http://particle128.com/images/expert_c_1_2.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第二章  这不是Bug，而是语言特性&lt;/h3&gt;
&lt;p&gt;&lt;img alt="2-1" src="http://particle128.com/images/expert_c_2_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第三章  分析C语言的声明&lt;/h3&gt;
&lt;p&gt;&lt;img alt="3-1" src="http://particle128.com/images/expert_c_3_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第四章  令人震惊的事实：数组和指针并不相同&lt;/h3&gt;
&lt;p&gt;数组/指针在不同源文件中的定义和声明，应该形式一样。&lt;/p&gt;
&lt;p&gt;一个源文件下定义的数组int a[10]，在另一个源文件下声明，必须使用extern int a[]形式；&lt;br /&gt;
一个源文件下定义的指针&lt;code&gt;int *a&lt;/code&gt;，在另一个源文件下声明，必须使用&lt;code&gt;extern int *a&lt;/code&gt;形式。  &lt;/p&gt;
&lt;p&gt;原因：同样一条语句&lt;code&gt;a[0] = 1;&lt;/code&gt;，编译器对于a是数组和a是指针的处理方式不同。&lt;/p&gt;
&lt;p&gt;假设我们定义了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并且a在符号表中的内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;var_address&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在外部用两种不同方式声明：&lt;/p&gt;
&lt;h4&gt;extern int a[]; a[1] = 1;&lt;/h4&gt;
&lt;p&gt;a是外部变量的声明，不分配空间，编译时用Undefined符号代替。&lt;br /&gt;
链接时，查找符号表，找到a，把符号表中a的地址123456当做数组首地址，把1赋给内存单元(123456+4)&lt;/p&gt;
&lt;h4&gt;extern int *a; a[1] = 1;&lt;/h4&gt;
&lt;p&gt;a是外部变量的声明，不分配空间，编译时用Undefined符号代替。&lt;br /&gt;
连接时，查找符号表，找到a，把符号表中a的地址123456当做指针地址，取(123456)内存单元中的内容，假设是654321，把该数值当做数组的首地址，然后把1赋给内存单元(654321+4)。&lt;/p&gt;</summary><category term="ExpertC"></category></entry><entry><title>Clean Code (6)</title><link href="http://particle128.com/posts/2014/12/cleanCode(6).html" rel="alternate"></link><updated>2014-12-28T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-28:posts/2014/12/cleanCode(6).html</id><summary type="html">&lt;h3&gt;Chapter17 Smells and Heuristics&lt;/h3&gt;
&lt;p&gt;这一章，是前面描述的内容的总结，列举了一些“不简洁代码”的表现。简单记录一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建工程，应当只需要一条命令；测试工程，也应该只需要一条命令。&lt;/li&gt;
&lt;li&gt;注释掉的代码，没有被调用的代码，不用担心，直接删掉就行。版本控制器会帮你管理。&lt;/li&gt;
&lt;li&gt;最小惊讶原则：你实现的函数，应当具有其他程序员凭直觉认定的，你这个函数应当具有的功能。比如&lt;code&gt;StringToDay&lt;/code&gt;函数，应当将字符串"Monday"转化成enum Day类型的对象，并且，支持缩写（"Mon"）、不缺分大小写（"monday"）。如果没有实现某些感觉上显而易见的功能，使用该函数的程序员就需要去看代码或文档。&lt;/li&gt;
&lt;li&gt;最重要的原则之一：去重复。不单单是代码的重复，还包括&lt;br /&gt;
1.大段的if/else或switch/case结构，用多态和抽象工场代替&lt;br /&gt;
2.相似的算法，用模板方法模式或策略模式代替&lt;/li&gt;
&lt;li&gt;将概念进行分层抽象，不要将代码写到错误的抽象层次上。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Isolating abstractions is one of the hardest things that software developers do, and there is no quick fix when you get it wrong.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;基类应对派生类一无所知，这是分离概念的要求。它们一般位于不同的jar文件中，当派生类替换时，基类不需要重新部署。例外：有限自动机，父类需要知道所有派生类的情况，父类和子类位于同一个jar文件中。&lt;/li&gt;
&lt;li&gt;接口越小越好，提供出来的公有函数越少越好。&lt;/li&gt;
&lt;li&gt;当两个模块之间没有依赖关系，不要仅仅因为一个模块需要使用另一个模块定义的一个东西时，建立了耦合。考虑一下，是不是我们把变量、常量、函数放错了地方？&lt;/li&gt;
&lt;li&gt;特性依恋（Features Envy），是指类A的方法使用了类B（参数或成员）的访问器或修改器。这种情况下，可以考虑把该方法实现在类B中。但是，以上解决方法，仅仅在不破坏其他方面的前提下，才成立。如果如下这种情况，就不能照顾特型依恋了，否则会破坏单一职责原则、打开闭合原则等。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;HourlyEmployeeReport&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;HourlyEmployee&lt;/span&gt; &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;reportHours&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Name: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;Hours:%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getHours&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;尽可能不用选择器参数（selector argument）。因为这样的方法，往往需要加注释，用来说明每种选项对应代码部分的意义。应当拆成几个方法，方法名就自我解释了。&lt;/li&gt;
&lt;li&gt;连续的长表达式，匈牙利标记法（Hungarian notation，用变量类型的缩写作为变量名的开头），魔数，都会让作者的意图很难理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;m_otCalc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iThsWkd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;iThsRte&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;iThsRte&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
          &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;iThsWkd&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;变量/常量/方法应该放在哪儿？&lt;/em&gt;用最少惊讶原则，即放置在语义上最合理的地方，而不是实现起来最方便的地方。好处：让读者可以很容易猜到它们的位置。&lt;/li&gt;
&lt;li&gt;静态方法还是非静态方法？优先非静态方法。如果感觉静态比较好，考虑是否将来会用到多态，如果可能用到多态，还是得非静态。&lt;/li&gt;
&lt;li&gt;用解释性变量，分拆一个长的表达式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toLowerCase&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 而不是&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toLowerCase&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;给date变量增加几天，命名：修改date本身，用&lt;code&gt;addDaysTo&lt;/code&gt;或&lt;code&gt;increaseByDays&lt;/code&gt;；不修改date，返回一个新的对象，用&lt;code&gt;daysLater&lt;/code&gt;或&lt;code&gt;daysSince&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;用常量取代魔数，例外：常量是众所周知的，出现在很清晰的代码上。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dailyPay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hourlyRate&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;circumference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2014/12/cleanCode(5).html"&gt;Clean Code (5)&lt;/a&gt;里提到了一种解决时间耦合的方法。还有一种方法，用返回值和参数约束：先调用的方法的返回值，作为后调用的方法的参数。&lt;/li&gt;
&lt;li&gt;封装边界条件，比如出现了两次的&lt;code&gt;level+1&lt;/code&gt;，可以用&lt;code&gt;nextLevel = level+1&lt;/code&gt;代替。&lt;/li&gt;
&lt;li&gt;如果模块A与模块B合作，模块B与模块C合作，我们不希望A知道C的存在。换句话说，让直接合作者（本例中的B）提供所有的服务。否则，如果想在B和C之间插入一个新的模块Q，将需要大动干戈：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getB&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getC&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// 应该是&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getB&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;如果我们需要引入同一个模块的两个以上的类，用通配符，好处（1）简洁（2）不是强依赖，降低耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全书总结&lt;/h3&gt;
&lt;p&gt;全书从代码层面和设计层面讲解了“简洁之道”，提到了很多我之前不知道的原则：SRP（单一职责原则）、OCP（打开闭合原则）、DRY（不要重复自己）、PLS（最少惊讶原则）...让我大开眼界。&lt;/p&gt;
&lt;p&gt;一年前，写paper的时候，我把实验代码封装成一些类，用继承和组合关系来关联它们。在这个过程中，我经常遇到一个让我头疼的问题，一个方法到底应该放在哪里：派生类还是基类？这个类还是那个类？引用一句Clean Code中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the most important decisions a software developer can make is where to put code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;clean code这本书里提到的一些坏味道（bad smell）和一些实践经验，给了我很好的指导。让我知道了哪些东西应该有（好的名字）、哪些东西不应该有（不言自明的注释）、代码应该有哪些功能、代码应该放在哪里（最少惊讶原则）。&lt;/p&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (5)</title><link href="http://particle128.com/posts/2014/12/cleanCode(5).html" rel="alternate"></link><updated>2014-12-17T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-17:posts/2014/12/cleanCode(5).html</id><summary type="html">&lt;h3&gt;Chapter14 Successive Refinement&lt;/h3&gt;
&lt;p&gt;本章通过一个例子（处理命令参数的工具类，它把它命名为Args），给我们展现了作者是如何一步一步重构代码的。这一章很赞，重构的步骤很有借鉴之处，代码非常可读。&lt;/p&gt;
&lt;p&gt;引用一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To write clean code, you must first write dirty code and then clean it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;焦义师兄写代码也是按照两步走来的。一开始写一个面向过程的，由许多文件构成的模块。之后，用面向对象思想和设计模式，将原来的代码重构成可读性、可扩展性、可维护性更强的版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试驱动开发（TDD）对于重构非常重要。重构过程中，每次只修改一点，刚好导致测试无法通过，然后再改到可以通过；再修改一点，刚好导致测试无法通过，再改到可以通过。。。这样循序渐进，保证重构不会引入新的问题。如果一次全部改完再测试，可能会引入新的bug，而且不容易定位bug的位置。&lt;/li&gt;
&lt;li&gt;重构的思路：找出每次扩展（对应该例子中，参数中增加新的类型），都要修改的地方。如果这些地方有共性，把这些方法抽离出来，形成一个类。&lt;/li&gt;
&lt;li&gt;在小作用域内，用简短的名字（比如&lt;code&gt;ArgumentMarshaler am&lt;/code&gt;），而不是更长和更有描述性的名字，更易读。&lt;/li&gt;
&lt;li&gt;尽早进行代码的调整和重构，越晚重构，成本越高！！！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构的细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重构，不是重写，所以不要上来就写所有要新增加的类，然后把原来的代码全部推翻，这样非常混乱，而且相当于把所有代码都重写之后再编译运行，并看结果如何。之前实习时的第二次重构，我就犯了这个错误，越改代码越乱，原来的代码还不敢删，所以各种注释代码，各种新增的、都还跑不通编译的代码。最后，我都要丧失了继续该下去的动力。而且即使这样改完，测试出bug，我还是需要跟踪到具体哪里的bug。&lt;/li&gt;
&lt;li&gt;假设新增一个类，其他代码保持原样（不要删除原来的旧类），然后，用新增的类替换现在类的一个出现位置，如果可以通过测试，再替换另一个出现位置，再测试。当所有这些位置，都已经通过了测试，再要被替换掉的类，这时候肯定也能通过测试。&lt;/li&gt;
&lt;li&gt;假设要定义一个类层次，首先把需要的一个功能添加到父类，子类只继承，不做其他的事情，替换代码，测试。像这样逐渐增加功能到父类，并全部通过测试。然后，再一步一步的把父类的东西挪到对应的子类。或许你会觉得这样很麻烦，但是如果上来就重头定义这个类层次，那么也意味着要重头修改所有用到该类的地方。这会导致同时产生过多没有通过测试的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter15 JUnit Internals&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比较长的表达式，要封装到函数中；否定比肯定要难理解一些，尽量用肯定语气的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;  &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;areStringEqual&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// shouldNotCompact&lt;/span&gt;
    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shouldBeCompacted&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;shouldBeCompacted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;shouldNotBeCompacted&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;shouldNotBeCompacted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expected&lt;/span&gt;  &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;areStringEqual&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;解决隐藏的时间耦合（hidden temporal coupling），防止程序员不经意间因为调换执行顺序，导致不易发现的bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;findCommonPrefix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// change prefixIndex&lt;/span&gt;
&lt;span class="nx"&gt;findCommonSuffix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// use the prefixIndex that was assigned by the previous function&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="nx"&gt;findCommonPrefixAndSuffix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;findCommonPrefixAndSuffix&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 去掉了findCommonSuffix()，把先后顺序硬编码进该函数中&lt;/span&gt;
    &lt;span class="nx"&gt;findCommonPrefix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// the content of previous findCommonSuffix()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;把复杂的for循环条件条件表达式和最后一个表达式抽成函数，或者重新定义循环变量，以简化。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 原代码略&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="c1"&gt;// 把循环变量由index -&amp;gt; length, 自定义suffixOverlapsPrefix和charFromEnd&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;suffixOverlapsPrefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;charFromEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;
        &lt;span class="n"&gt;charFromEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重构是一个迭代的过程，不断的尝试、出错、再尝试。而且经常会出现一种情况，就是，我们虽然刚刚重构了一些东西，但是由于发现了新的情况，我们要撤销之前重构的部分，以满足刚刚发现的情况需要进行的重构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本章所使用的例子，在重构之前就已经比较简洁和清晰了。但是任何代码都有改进的余地，而且我们有责任将遇到的代码修改的更好一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (4)</title><link href="http://particle128.com/posts/2014/12/cleanCode(4).html" rel="alternate"></link><updated>2014-12-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-13:posts/2014/12/cleanCode(4).html</id><summary type="html">&lt;h3&gt;Chapter12 Emergence&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The majority of the cost of a software project is in long-term maintenance  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解析极限编程：拥抱变化（Extreme Programming Explained: Embrace Change）里列举了“简单设计”的四原则，优先级依次降低：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跑通所有的测试：单一原则的简洁代码，依赖更少的代码，&lt;strong&gt;更加可测&lt;/strong&gt;。所以，测试功能的同时，也能确保程序逐渐符合“低耦合高内聚”的面向对象目标。此外，也能让我们更加大胆的重构。&lt;/li&gt;
&lt;li&gt;没有重复：提取重复的部分组成新的方法/新的类，用模板办法把公共的部分提升到抽象父类中&lt;/li&gt;
&lt;li&gt;有表达力：一个软件工程耗费最多时间的是长期的维护，所以，选好的名字、让方法和类尽可能小、写单元测试。有句话叫：想象你代码的维护者是一个精神狂暴症患者，并且他知道你家在哪儿。&lt;/li&gt;
&lt;li&gt;尽可能减少类和方法的数量：按照CLEAN CODE的各种原则，应该会产生更多的类和方法，但是过犹不及，别拆的太细了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;掌握了这些原则可以节省很多年的探索，但是只有在实践中才能更深入的理解这些原则！！！&lt;/p&gt;
&lt;h3&gt;Chapter13 Concurrency&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并发解耦了“做什么”和“什么时候做”。单线程程序通过加断点，我们很明确的知道当时程序的状态，即执行到哪里了，将要执行到哪儿。但是，多线程并不是如此，多个线程的“什么时候做”并不能通过“做什么”推导出先后顺序。&lt;/li&gt;
&lt;li&gt;并发防卫原则&lt;br /&gt;
1.单一职责。让并发代码和其他代码分隔开。&lt;br /&gt;
2.限制共享数据的使用范围。减少临界区。&lt;br /&gt;
3.优先拷贝数据(线程独占)而不是共享数据，除非效率开销在当前应用场景下影响很大。&lt;br /&gt;
4.线程越独立越好，尽量不与其他线程扯上关系（比如共享数据之类的）。&lt;/li&gt;
&lt;li&gt;使用线程安全的集合，&lt;code&gt;java.util.concurrent&lt;/code&gt;下的&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;熟悉一些常用模型和解决方法：生产者消费者、读者写者、哲学家就餐。绝大多数遇到的兵法问题，都是这些模型的变形。&lt;/li&gt;
&lt;li&gt;尽量不要让一个共享对象有两个公共方法？？？？？解决方法：基于客户端的锁、基于服务器的锁、适配的服务器？？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试线程代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要把一些不常见的失败，当做一次性（one-off）的，研究它的原因。&lt;/li&gt;
&lt;li&gt;先测试代码的非线程版本，再测试线程，从而确定是逻辑错了，还是线程同步出错了。&lt;/li&gt;
&lt;li&gt;开辟多于处理器的线程数，易于暴露问题&lt;/li&gt;
&lt;li&gt;尽早在多个平台上运行，易于暴露问题（不同平台的线程策略不同，在一个平台上不常见的bug可能在另一个平台上经常发生）&lt;/li&gt;
&lt;li&gt;很多多线程bug不容易发现是因为，有太多可能的执行路径，或者常见路径的概率太高（比如两个相邻的语句看似原子的执行），导致发生不常见路径的概率很低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动插入&lt;code&gt;yield()&lt;/code&gt;或&lt;code&gt;wait()&lt;/code&gt;或&lt;code&gt;sleep()&lt;/code&gt;或&lt;code&gt;priority()&lt;/code&gt;，改变执行顺序&lt;/li&gt;
&lt;li&gt;借助AOP，在测试时，随机插入这些语句之一，在生产代码中，插入空语句。如下所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//根据配置文件，随机插入不同的语句，或不插入语句&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nextUrlOrNull&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasNext&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urlGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;updateHasNext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (3)</title><link href="http://particle128.com/posts/2014/12/cleanCode(3).html" rel="alternate"></link><updated>2014-12-09T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-09:posts/2014/12/cleanCode(3).html</id><summary type="html">&lt;h3&gt;Chapter8 Boundaries&lt;/h3&gt;
&lt;p&gt;边界指的是第三方库和应用程序的边界。&lt;/p&gt;
&lt;p&gt;用包裹类，或适配器模式，来封装第三方代码（third-party code），可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;限制第三方代码的功能&lt;/li&gt;
&lt;li&gt;提供更一致和好用的接口&lt;/li&gt;
&lt;li&gt;减少受第三方代码改变带来的影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经常出现匪夷所思的bug，可能是由于第三方库导致的。所以，在使用之前应该做一个Learning Test（一遍学习文档，一遍写单元测试），确保我们需要的功能它都能正确提供。Learning Test好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帮助学习文档&lt;/li&gt;
&lt;li&gt;确保得到如期的结果，避免以后bug不知道从哪儿来&lt;/li&gt;
&lt;li&gt;第三方库版本更新后，继续用它测试是否符合预期（很多时候我们都不及时更新第三方库，因为我们怕更新后带来新的问题)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Chapter9 Unit Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD（Test Driven Development）的三法则：写了失败的UT再写成产代码；一旦可以保证生产代码失败，就停止写UT；一旦生产代码通过了UT，就停止写生产代码。这样一轮循环大约30s。&lt;/li&gt;
&lt;li&gt;测试代码和生产代码一样重要，也要简洁、可读。因为如果一开始测试代码标准不高，随着生产代码的演化，阅读和修改单元测试的成本会非常高，高到一定程度，可能团队就抛弃测试了。引用一句里面的经典语录：&lt;blockquote&gt;
&lt;p&gt;Having dirty tests is equivalent to, if not worse than, having no tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;测试的好处：可以让代码更加可扩展、可靠。因为测试详尽的话，人们就不怕修改/重构代码。反之，人们将不敢改代码，因为怕引入没有检查到的bug。&lt;/li&gt;
&lt;li&gt;测试代码要简洁，把过多的细节抽象到函数中，让测试只呈现三个部分（每一部分1、2行代码）：建立测试数据、执行操作、检查结果——即BUILD-OPERATE-CHECK模式。&lt;/li&gt;
&lt;li&gt;测试的双重标准：像成产代码一样简洁，效率可以低于生产代码（可读性 &amp;gt; 效率）。&lt;/li&gt;
&lt;li&gt;一个测试函数，只包含一个assert（尽量做到），或只处理一个概念。&lt;/li&gt;
&lt;li&gt;测试遵循FIRST原则：&lt;br /&gt;
Fast：执行效率&lt;br /&gt;
Independent：不能相互依赖，应当可以独立运行每一个测试，而且可以以任何顺序运行这些测试！！！&lt;br /&gt;
Repeatable：不依赖环境，在任何情况（生产环境，QA环境，断网环境，甚至家里）可重现&lt;br /&gt;
Self-validating：应当返回布尔值，而不是打印log&lt;br /&gt;
Timely：及时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter10 Classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当测试需要访问类的私有成员时，提升为package（外部测试）或protected（派生类测试）。只有在别无他法时，才可以这样做（这破坏/放松了封装）。&lt;/li&gt;
&lt;li&gt;类应当小：可以用大约25个词描述一个类，并且描述中不包括“如果”，“并且”，“或”，“但”；单一职责。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一职责经常被违背。  主要有两个原因：&lt;br /&gt;
1.仅仅让程序工作就满足了，并开始处理下一个问题，而不想着在类变得日益臃肿后，花心思将其拆开/解耦.&lt;br /&gt;
2.有一堆小的类，会比较难知道更大块的工作是如何实现的（需要在类之间跳来跳去）。  &lt;br /&gt;
实际上，在一个庞大的类中了解细节，和在多个简短的类中了解细节，需要移动的范围是一样大的，一个是函数间的跳转，一个是类间的跳转。但是，类一旦按照功能细分开来，开发者就可以根据自己的情况，选择不去了解一些更具体的东西，只掌握自己需要掌握的粒度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内聚性（cohesion）：类应该具有少量的实体变量，而且实体变量被越多的方法使用，类的内聚性越高。最理想的情况：所有实体变量被所有方法使用。因为这样的类成员更加相互依赖，更加紧凑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;拆分一个函数的过程，可能拆分出来多个类：函数太长 -&amp;gt; 拆出一个函数（含有4个参数） -&amp;gt; 因为参数太多，考虑提升为实体变量 -&amp;gt; 类多了四个、仅仅被一个方法使用的实体变量，内聚性差 -&amp;gt; 拆出一个类，包含这四个实体变量&lt;/li&gt;
&lt;li&gt;文中，Uncle Bob把Knuth的一个“产生素数”的算法拆成了3个，代码量长度多了一倍，但是却的确更好理解了。Knuth的代码需要加很多注释，但是Uncle Bob的代码已经自解释了。它里面的一些函数和变量的命名也让我大开眼界，原来名字这么长（最长的名字 &amp;gt; 40个字符），反而这么容易读懂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image" src="http://particle128.com/images/long_name.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了适应随时都会发生的变化（需求、演化），应该：&lt;br /&gt;
（1）用Single Responsibility Principal和Open Closed Principal来构造类（修改时，不用改原来的代码，只通过增加子类即可扩展）&lt;br /&gt;
（2）用接口/适配器模式来隔离具体类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter11 Systems&lt;/h3&gt;
&lt;p&gt;本章，把构建软件系统，类比为建造城市：需要有一开始的规划，但是不可能一开始就了解到所有的细节，以及可能会发生的所有变化，所以要做一些接受变化的决策（面向方面编程）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让应用程序（最高层抽象）和细节隔离开：(1)抽象工场模式，(2)依赖注入。&lt;/li&gt;
&lt;li&gt;将cross-cutting concern提取出来，使所有类都是模块化的POJO(Plain Old Java Object)，即面向切面编程（AOP）：(1)Java Proxies, (2) Spring或JBoss的AOP, (3)AspectJ&lt;/li&gt;
&lt;li&gt;准则：用可以解决问题的最简单的东西。比如，能用Spring就别用EJB2这类笨重和耦合度高的东西。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (2)</title><link href="http://particle128.com/posts/2014/12/cleanCode(2).html" rel="alternate"></link><updated>2014-12-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-06:posts/2014/12/cleanCode(2).html</id><summary type="html">&lt;h3&gt;Chapter5 Formatting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你的代码可能随着版本的升级，逐渐被替换；但是你的代码风格/格式会被后继开发者一直传承下去。&lt;/li&gt;
&lt;li&gt;文件的长度：通常200行以内，最多500行&lt;/li&gt;
&lt;li&gt;C++类文件，通常遵循scissors rule，即上面是成员函数，下面是成员变量；java相反，上面是成员变量，下面是共有函数&lt;br /&gt;
根据Sun的&lt;a href="http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html"&gt;Code Convention for Java&lt;/a&gt;，类中的成员的顺序如下：&lt;br /&gt;
1.static成员变量：public -&amp;gt; protected -&amp;gt; package -&amp;gt; private&lt;br /&gt;
2.non-static成员变量：public -&amp;gt; protected -&amp;gt; package -&amp;gt; private&lt;br /&gt;
3.构造函数&lt;br /&gt;
4.成员函数：按照语义顺序，而不是访问级别&lt;/li&gt;
&lt;li&gt;一行不超过120个字符，可以设置屏幕字符宽度为120，是否需要向右滚动屏幕是判断是否超过行限制的方法（Sun Java Convention规定是80个字符）&lt;/li&gt;
&lt;li&gt;操作符之间的空格：*和/符号两边不加空格，+和-符号两边加空格，用优先级来区分更加清晰。&lt;/li&gt;
&lt;li&gt;常量应该出现在，对该常量有意义的高层函数，然后通过参数传递给低层函数，而不是直接定义在低层函数中。&lt;/li&gt;
&lt;li&gt;不建议声明变量和赋值语句的对齐，这会导致读者只注意看变量名或赋值的右值，而忽视类型或左值&lt;/li&gt;
&lt;li&gt;尽量避免空的代码块。即使是空的代码块，也要加上括号和适当缩进，比如（书中没给出正确的例子）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;but&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;readBufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// empty&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Chapter6 Objects and Data Structures&lt;/h3&gt;
&lt;p&gt;我理解文中所谓的Objects应该是指类。&lt;/p&gt;
&lt;p&gt;对象暴漏行为，而隐藏数据，很容易增加新的对象，而不改变已经存在的行为；但很难增加行为，因为增加行为需要改变所有对象的行为。数据结构暴露数据，没有重要的行为，很容易增加新的行为，而不改变已经存在的对象；但很难增加数据结构，因为增加对象意味着需要改变所有操作这些数据结构的函数。例子如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 数据结构&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Geometry&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;area&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;NoSuchShapeException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchShapeException&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 对象&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 用多态获取不同类型对象的面积&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;对象和数据结构，几乎有相反的特性，根据实际需要进行选择&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;得墨忒耳率（The Law of Demeter）&lt;/strong&gt;：一个模块不应该知道它所操纵的对象的内部结构。具体来说来，类C的一个方法f应该仅能访问如下类的方法：&lt;br /&gt;
1.C这个对象&lt;br /&gt;
2.f中定义的对象&lt;br /&gt;
3.f的参数对象&lt;br /&gt;
4.C的成员对象  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面这句话是违反该规则的，因为getOptions()返回的对象，不属于上面四类之一，调用它的getDir意味着知道该返回对象的内部结构（成员函数）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOptions&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getDir&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePath&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;应该改成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePathOfDirOption&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDirOption&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePath&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 假设arg.getDirOption()返回的是数据结构，而不是对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;数据结构：成员变量是公有的，可能含有成员函数（构造函数，get函数...）。有时被称为DTO（Data Transfer Objects），与数据库或socket通信时常用到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter7 Error Handling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用异常，而不是错误码（errno或return code），可以让代码更清晰，分离异常处理和程序逻辑。这让我想到UNP的头文件，作者Steven封装了所有网络相关系统调用（connect -&amp;gt; Connect, listen -&amp;gt; Listen），才得以让异常处理不扰乱代码逻辑。&lt;/li&gt;
&lt;li&gt;先写单元测试，再写try-catch-finally块，最后写主体逻辑&lt;/li&gt;
&lt;li&gt;未检查的异常，好处是：限制你必须catch它。但是，这不是可靠程序的必要条件（C#,C++,Python,Ruby都没有），而且底层的一次改动（比如抛出新的异常了），会导致上面好几层的函数都要重新改写异常说明符（如果到了上面第n层才catch的话），这破坏了封装！&lt;/li&gt;
&lt;li&gt;抛异常的时候，只有调用堆栈还不够，尽量提供详细的上下文，比如抛出该异常时的局部变量、第几轮循环等。&lt;/li&gt;
&lt;li&gt;可以定义包裹类，来包裹第三方API，例如把原先抛出三种异常的代码，包裹之后只抛出一种异常。好处：&lt;br /&gt;
(1)减少依赖，即当第三方API更换时，你只需该wrapper，应用代码可以不动 &lt;br /&gt;
(2)测试时方便模拟出第三方库的调用...&lt;strong&gt;啥意思???? &lt;/strong&gt; &lt;br /&gt;
(3)设计一组更符合自己使用习惯的新的接口&lt;/li&gt;
&lt;li&gt;一种场景，定义一个异常类就行了，可以通过错误信息来区分不同错误。使用多种异常类的情况：你想捕获一种异常，而放行另一种异常！！！&lt;/li&gt;
&lt;li&gt;不要用异常应付正常现象的特殊情况，用SPECIAL CASE PATTERN&lt;/li&gt;
&lt;li&gt;不要返回null，会导致太多null检查，且容易漏掉检查。用异常，或special case object（比如空列表）&lt;/li&gt;
&lt;li&gt;不要传入null，因为如果可能接收null，需要做异常处理（抛出InvalidArgumentException异常，再catch）。。。&lt;strong&gt;我感觉很多时候都没法避免啊，如果其他程序员调用该函数的时候传入null了咋办？？？放着不管？？？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (1)</title><link href="http://particle128.com/posts/2014/12/cleanCode(1).html" rel="alternate"></link><updated>2014-12-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-05:posts/2014/12/cleanCode(1).html</id><summary type="html">&lt;h3&gt;Chapter1 Clean Code&lt;/h3&gt;
&lt;p&gt;通过一个“坏代码毁了一个初创公司”的例子，讲了messy code的危害，不禁让我想到VPC的第一版。然后，列举了多个名人对clean code的推崇和理解，这些名人包括C++之父、UML创始人、程序员修炼之道作者、wiki之父...&lt;/p&gt;
&lt;h3&gt;Chapter2 Meaningful Names&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用表明意义（intention-revealing）的名字，而不是简单的名字+注释。比如&lt;code&gt;elapsedTimeInDays&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免误导信息（disinformation）。尽量少自己定义缩略形式，如果不是List别用&lt;code&gt;accountList&lt;/code&gt;（用&lt;code&gt;accounts&lt;/code&gt;,或&lt;code&gt;bunchOfAccounts&lt;/code&gt;,或&lt;code&gt;accountGroup&lt;/code&gt;），别用小写的l和大写的O&lt;/li&gt;
&lt;li&gt;做有意义的区分。避免用&lt;code&gt;a1,a2,..&lt;/code&gt;来区分多个同类元素，避免用&lt;code&gt;a,an,the,data,info&lt;/code&gt;修饰变量名，来做字面的区分&lt;/li&gt;
&lt;li&gt;用可以发出音的名字。别用&lt;code&gt;genymdhms (generation year,mon,day,hour,min,sec)&lt;/code&gt;，换成&lt;code&gt;generationTimestamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用可搜索的名字。魔数不要用，简单的单字母变量少用。名字的长度应该对应它所在作用域的大小，即短名字仅可以出现在很小的作用域上，比如for循环中的&lt;code&gt;i,j,k&lt;/code&gt;，意义明确的短小函数中的&lt;code&gt;sum&lt;/code&gt;。当然，如果有很好表示的明确意义，还是用有意义的变量来代替&lt;code&gt;i,j,k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不需要加类似&lt;code&gt;m_&lt;/code&gt;的前缀&lt;/li&gt;
&lt;li&gt;接口不要用&lt;code&gt;IShapeFactory&lt;/code&gt;，直接用&lt;code&gt;ShapeFactory&lt;/code&gt;，然后使用&lt;code&gt;ShapeFactoryImp&lt;/code&gt;。目的：用户不需要关心自己处理的是接口还是实现，名字中暴漏更少的信息。&lt;/li&gt;
&lt;li&gt;类名，名词或名词短语，避免添加&lt;code&gt;Manager,Processor,Data,Info&lt;/code&gt;这类没信息量的名字&lt;/li&gt;
&lt;li&gt;方法名，动词或动词短语&lt;/li&gt;
&lt;li&gt;如果能用解决方案域的名字（Solution Domain Names），就不用问题域的名字（Problem Domain Names），因为这样更容易让程序员理解，而不需要首先咨询专业人员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;起名是一件很难的事情，需要不断练习。要在开发、测试和维护中，修改代码中欠佳的名字，别担心这会让其他人困惑，这是非常值得的。&lt;/p&gt;
&lt;h3&gt;Chapter3 Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个函数应当短到只有2~4行，缩进级别不应该超过两层（即，最多两重循环）&lt;/li&gt;
&lt;li&gt;一个函数只做一件事。界定的两种方法：&lt;br /&gt;
(1) 能否用一个TO语句描述，看描述出来是否在同一个抽象层次 (2) 能不能从一个函数中提取出另一个不同名的函数&lt;/li&gt;
&lt;li&gt;函数在源文件中的顺序：上面的函数引用下面的函数。&lt;/li&gt;
&lt;li&gt;不应该在代码中出现switch语句，switch结构肯定会很长。用抽象工场（可以包含switch，以便根据另一个对象的类型或根据一个字符串，决定创建什么类）+多态（根据类型动态选择对应的函数）替代。&lt;/li&gt;
&lt;li&gt;给函数起一个描述性的名字，比如&lt;code&gt;includeSetupAndTeardownPages&lt;/code&gt;。别怕长：长的描述性名字，好于短的不明其意的名字，好于长的描述性注释。别怕花时间选取名字+改动：现代IDE很容易全局替换名字，改名也常常带来有价值的重构代码。&lt;/li&gt;
&lt;li&gt;函数参数尽量少，不要超过3个参数。参数越少，越利于函数的理解和测试(需要测试参数的所有组合)。&lt;/li&gt;
&lt;li&gt;单参函数尽量保持三种形式之一，其余形式要考虑是不是需要重构：1、关于参数的一个判断，如&lt;code&gt;fileExists&lt;/code&gt;；2、将参数转换成别的，如&lt;code&gt;fileOpen&lt;/code&gt;；3、参数引起了一个事件，无返回值，如&lt;code&gt;passwordAttemptFailedNtimes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要传标记（boolean类型），这显然违背了“只做一件事”原则，因为它至少做了两件事（true时..false时..）。在上层用if判断，然后调用不同函数，比如&lt;code&gt;renderForSuite()&lt;/code&gt;和&lt;code&gt;renderForNonSuite()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数不要有副作用（side effect），比如改变成员变量，改变全局变量，改变参数，等。如需改变，写在名字上，或拆成两个函数&lt;/li&gt;
&lt;li&gt;不要值-结果参数，容易让人迷惑，需要再去看函数原型——double-take(再看一眼)&lt;/li&gt;
&lt;li&gt;优先使用异常，而不是错误码，防止混合错误处理逻辑和正常逻辑，进而导致代码不清晰。把可能出现异常的语句放到一个函数中，单独定义一个，仅仅包含try-catch-finally的函数，调用前面的函数——错误处理和正常逻辑分开。&lt;/li&gt;
&lt;li&gt;用异常层次结构，而不是错误码（error class/enum，其他类需要import），解决&lt;code&gt;dependency magnet&lt;/code&gt;，即增加新的异常/错误时，不需要重新编译和部署&lt;/li&gt;
&lt;li&gt;一开始先写出长的、复杂的、有重复的、随意命名的函数，之后再按照本章的方法拆分和提炼。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;目标是，写源代码，就像写小说，函数调用的意义都很清晰，让读者读起来很流畅，不需要跳到函数原型甚至函数注释或源码中才能理解。&lt;/p&gt;
&lt;h3&gt;Chapter4 Comments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;写注释前，仔细考虑能否把注释的东西表达在代码里。因为，注释非常容易do evil（因为没能随着代码进行更新）。&lt;/li&gt;
&lt;li&gt;很多时候，写一个函数就可以免去注释了，比如&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// check to see if the the employee is eligible for full benefits&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;HOURLY_FLAG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;65&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;应当改成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEligibleForFullBenefits&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;加注释的时机：&lt;br /&gt;
1.版权声明(&lt;code&gt;all rights reserved&lt;/code&gt;)
2.提供信息&lt;br /&gt;
3.解释意图&lt;br /&gt;
4.澄清意思&lt;br /&gt;
5.警告可能的结果&lt;br /&gt;
6.善用TODO注释和javadoc&lt;/li&gt;
&lt;li&gt;不要加这类注释：&lt;br /&gt;
1.冗余的注释（从函数名或函数本身，很容易知道函数的意图）&lt;br /&gt;
2.关闭括号的注释（语句太多才需要关闭括号注释，考虑拆开它）&lt;br /&gt;
3.注释掉的代码、标注代码修改者、标注代码修改记录（这类可以用版本控制软件如git来杜绝）&lt;br /&gt;
4.太多信息的注释（简要描述，提到关键字即可，别长篇大论）&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>大规模分布式存储系统-笔记（2）</title><link href="http://particle128.com/posts/2014/04/distriStore2.html" rel="alternate"></link><updated>2014-04-26T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-26:posts/2014/04/distriStore2.html</id><summary type="html">&lt;h2&gt;Chapter2 单机存储系统&lt;/h2&gt;
&lt;h3&gt;2.1硬件基础&lt;/h3&gt;
&lt;h4&gt;CPU架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;SMP（对称多处理）:经典的CPU架构，一个计算机上汇集了一组CPU（一个CPU往往包括不止一个核），对称工作、无主次或从属关系，共享相同的物理内存和总线。&lt;br /&gt;
  某些CPU还通过超线程技术（Hyper-Threading Technology），在一个核心上同时执行两个线程。  &lt;/li&gt;
&lt;li&gt;NUMA（非一致存储访问）:克服SMP中多CPU对总线资源的竞争，一个NUMA包括多个NUMA节点，一个NUMA节点就是一个SMP结构（n个CPU，1个内存）  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IO总线&lt;/h4&gt;
&lt;p&gt;Intel的主板，一般为南、北桥架构  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;北桥芯片：CPU，内存，高端SSD (高速IO)  &lt;/li&gt;
&lt;li&gt;南桥芯片：网卡，硬盘，中低端SSD  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;网路拓扑&lt;/h4&gt;
&lt;p&gt;数据中心网络拓扑结构，主要分为  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三层结构：核心层、汇聚层、接入层。一个接入层交换机下的服务器部署在一个机架内  &lt;/li&gt;
&lt;li&gt;三级CLOS网络：Google设计的扁平化拓扑结构（从wiki上看图，感觉挺复杂的）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输时延  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个数据中心内部，网络来回的时延为0.5ms  &lt;/li&gt;
&lt;li&gt;杭州和北京两个数据数据中心之间，网络来回的时延大约40ms  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;性能参数&lt;/h4&gt;
&lt;p&gt;比较重要的参数  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存访问：               100ns  &lt;/li&gt;
&lt;li&gt;千兆网络发送1MB数据：    10ms  (1Gbit/s=0.1GB/s=100MB/s，1MB/(100MB/1000ms)=10ms)  &lt;/li&gt;
&lt;li&gt;SATA磁盘寻道：           10ms  &lt;/li&gt;
&lt;li&gt;SATA磁盘顺序读取1MB数据：20ms （SATA带宽100MB/s，寻道+访问=10ms+1MB/(100MB/1000ms)=20ms）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外：&lt;br /&gt;
SSD（固态硬盘）因为随机读取延迟小（磁盘的随机读取，需要耗费大量的寻道时间），并且提供很高的IOPS（每秒读写次数），在缓存和一些性能要求较高的关键业务上的应用越来越广。  &lt;/p&gt;
&lt;p&gt;存储系统的性能包括两个维度 : 吞吐量 , 访问延时&lt;br /&gt;
磁盘和SSD的访问延时差别很大，但是吞吐量差别不大。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘：大块顺序访问的存储系统，保存冷数据  &lt;/li&gt;
&lt;li&gt;SSD：随机访问较多或者对延时比较敏感的关键系统，保存热数据  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.2 单机存储引擎&lt;/h3&gt;
&lt;p&gt;存储引擎相当于存储系统的发动机.&lt;br /&gt;
存储引擎就是哈希表、B树、LSM树等数据结构在磁盘、SSD等持久化介质的实现。根据采用数据结构不同，分成：哈希存储引擎，B树存储引擎，LSM树存储引擎  &lt;/p&gt;
&lt;h4&gt;哈希存储引擎&lt;/h4&gt;
&lt;p&gt;Bitcask是&lt;a href="http://docs.basho.com/riak/1.2.0/tutorials"&gt;Riak&lt;/a&gt;（排名第三的键值数据库key-value store，elang实现，前两名是redis和memcached）的默认后台存储引擎。  &lt;/p&gt;
&lt;p&gt;特点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只支持追加操作，磁盘中的数据文件包括active data file和older data file。当active data file达到一定大小，就会变成older data file，并且建立新的active文件用来追加数据。  &lt;/li&gt;
&lt;li&gt;磁盘中数据的格式：&lt;code&gt;crc,timestamp,key_sz,value_sz,key(变长),value(变长)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;内存中的数据结构：&lt;code&gt;key&lt;/code&gt; -&amp;gt; &lt;code&gt;file_id,value_sz,value_pos,timestamp&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;定期合并：删除和更新后，原来的记录会变成垃圾数据，这时候需要合并older data file。基于时间戳，把同一个键下的旧记录或设置为无效的记录删除，只保留最新的记录。  &lt;/li&gt;
&lt;li&gt;快速恢复：内存中的哈希表，每次都在磁盘上保存一份，叫索引文件（hint file）。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增：先在磁盘中追加一条记录，再更新内存的哈希表  &lt;/li&gt;
&lt;li&gt;删：更新磁盘中对应记录的value为无效，更新内存  &lt;/li&gt;
&lt;li&gt;改：增加一条新的记录，更新内存  &lt;/li&gt;
&lt;li&gt;查：通过内存哈希表找到文件号、value位置、value长度，直接read指定的文件在指定的偏移多少字节即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有键都保存在内存中，需要保证键的范围不够大。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;B树存储引擎&lt;/h4&gt;
&lt;p&gt;MySQL InnoDB是&lt;a href="http://dev.mysql.com/"&gt;MySQL&lt;/a&gt;(排名第二的数据库，第一是oracle)的一个存储引擎  &lt;/p&gt;
&lt;p&gt;缓冲区的管理方式：LIRS&lt;br /&gt;
是LRU替换算法的一种改进，被用在MySQL InnoDB和Oracle Touch Count中。将缓冲池分为两级，数据首先进入第一级，如果数据在较短时间内被访问两次或以上，则成为热点数据进入第二级，每一级内部还是采用LRU替换算法。&lt;br /&gt;
目的：防止之前的热点数据，被一次数据库遍历操作全部剔除出缓冲区。  &lt;/p&gt;
&lt;h4&gt;LSM树存储引擎&lt;/h4&gt;
&lt;p&gt;LSM树，即log structured merge tree， LevelDB采用。PS:erlang版本的eLevelDB是Riak的可选后台存储引擎。  &lt;/p&gt;
&lt;p&gt;特点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对数据的修改增量保存在内存的MemTable中，因此修改操作比较快。  &lt;/li&gt;
&lt;li&gt;当MemTable大小达到上限，LevelDB将其冻结为“不可变MemTable”，即只可读的MemTable；同时重新生成一个MemTable，用于接收到达的写入请求。  &lt;/li&gt;
&lt;li&gt;写入操作：先写到磁盘中的操作日志，再更新内存中的MemTable。  &lt;/li&gt;
&lt;li&gt;合并操作(minor compaction)：后台线程将不可变MemTable中的数据排序后写入磁盘，形成SSTable文件。SSTable文件中的记录按照主键排序，每个文件有最小和最大的主键值，这些数据元信息保存于“清单文件”中。SSTable文件根据写入时间，分成多个层次，新写入的放入0层，旧的在1层，更旧的在2层，依次类推。  &lt;/li&gt;
&lt;li&gt;合并操作(major compaction)：当某个层级下的SSTable文件数目超过上限，合并该层中的某些文件到高层级中。  &lt;/li&gt;
&lt;li&gt;读取操作（LevelDB只支持随机读取单条记录）：按如下顺序读取，（1）内存中MemTable，（2）内存中的不可变MemTable，（3）从新到老读取磁盘中的SSTable文件。  &lt;/li&gt;
&lt;li&gt;当内存没有命中时，读取操作比较费时，需要在内存和各个层次文件中查找。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;小结（by myself）&lt;/h4&gt;
&lt;p&gt;几乎存储引擎都会先更新磁盘中的log，再写入内存。
Q:为什么不直接写入磁盘中的数据文件，再写入内存，都是一次磁盘io和一次内存访问？
A:我感觉，因为log文件总是需要的（转储时，数据库失败恢复时），所以必须要写log，而只写log不写磁盘中的数据文件，不会有任何影响，所以减少一次磁盘访问，就只写log和内存。&lt;/p&gt;
&lt;h3&gt;2.3数据模型&lt;/h3&gt;
&lt;p&gt;数据模型相当于存储系统的外壳.&lt;br /&gt;
包括:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件模型，比如unix树状的文件系统，GFS，TFS等  &lt;/li&gt;
&lt;li&gt;关系模型，比如关系型数据库oracle,mysql  &lt;/li&gt;
&lt;li&gt;键值模型，比如redis  &lt;/li&gt;
&lt;li&gt;表格模型，比如Google Bigtable，HBase  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL(键值模型或表格模型)与SQL(关系模型)对比  &lt;/p&gt;
&lt;p&gt;在海量数据的场景中，SQL存在缺点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务：事务的多个操作可能在不同主机上，为了保证原子性，需要“两阶段提交协议”（two-phase commit protocol,2PC）。该协议性能很低，而且不能容忍服务器故障。  &lt;/li&gt;
&lt;li&gt;多表连接：关系数据库讲究范式，为了达到更高级别的范式，需要拆分表格，这可能导致多个表在不同主机上，连接性能比较低。  &lt;/li&gt;
&lt;li&gt;性能：B树存储引擎，在某些特定的情形下不如LSM树和hash表。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，也有其优势：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准：SQL语言标准化工作很好  &lt;/li&gt;
&lt;li&gt;运维：关系数据库有成熟的运维工具和大量运维人员  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="distributed"></category><category term="storage"></category></entry><entry><title>大规模分布式存储系统-笔记（1）</title><link href="http://particle128.com/posts/2014/04/distriStore1.html" rel="alternate"></link><updated>2014-04-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-15:posts/2014/04/distriStore1.html</id><summary type="html">&lt;h2&gt;Chapter1 概述&lt;/h2&gt;
&lt;h3&gt;分布式存储特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可扩展：随着集群规模增大，整体性能表现为线性增长  &lt;/li&gt;
&lt;li&gt;低成本：构建在普通PC上，实现自动容错、自动负载均衡  &lt;/li&gt;
&lt;li&gt;高性能  &lt;/li&gt;
&lt;li&gt;易用：提供易用的外部接口，也具备完善的监控和运维工具  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鸡汤：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般来讲，工程师如果能够深入理解分布式存储系统，理解其他互联网后台架构不再会有任何困难。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;分布式存储分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非结构化数据：文档、图片、视频等  &lt;/li&gt;
&lt;li&gt;结构化数据：数据库中的表  &lt;/li&gt;
&lt;li&gt;半结构化数据：HTML文档，模式结构和内容混在一起  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分布式存储系统分类&lt;/h3&gt;
&lt;p&gt;1、分布式文件系统&lt;br /&gt;
存储非结构化数据，可以用作分布式数据库或分布式表格系统的底层存储  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储BLOB，Facebook Haystack以及Taobao File System  &lt;/li&gt;
&lt;li&gt;存储大文件，Google File System，分布式表格系统Google Bigtable的基础  &lt;/li&gt;
&lt;li&gt;存储定长块，Amazon的Elastic Block Store，分布式数据库Amazon RDS的基础  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、分布式键值系统&lt;br /&gt;
存储关系简单的半结构化数据，只提供基于主键的CRUD功能，一般用作分布式缓存  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amazon Dynamo  &lt;/li&gt;
&lt;li&gt;Taobao Tair  &lt;/li&gt;
&lt;li&gt;redis  &lt;/li&gt;
&lt;li&gt;memcached  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一致性哈希(consistent hashing)是分布式缓存常用的技术&lt;/p&gt;
&lt;p&gt;3、分布式表格系统&lt;br /&gt;
存储关系较为复杂的半结构化数据，除了CRUD功能，还支持主键的范围查找  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Bigtable  &lt;/li&gt;
&lt;li&gt;Amazon DynamoDB  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、分布式数据库&lt;br /&gt;
存储结构化数据，是关系型数据库的扩展，提供SQL关系查询语言，多表关联、嵌套子查询等。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Spanner  &lt;/li&gt;
&lt;li&gt;阿里的OceanBase  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有很火的NoSQL数据库，克服关系数据库扩展、并发、性能方面的缺陷。  &lt;/p&gt;</summary><category term="distributed"></category><category term="storage"></category></entry><entry><title>Rereading Programming Pearls(6)</title><link href="http://particle128.com/posts/2014/02/pp6.html" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-02-20:posts/2014/02/pp6.html</id><summary type="html">&lt;h2&gt;Column6 Perspective on performance&lt;/h2&gt;
&lt;h3&gt;Design Levels&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;problem definition&lt;br /&gt;
Good specifications are quite important.&lt;br /&gt;
Good error recovery may make a compiler slightly slower, but it usually decreases its overall time by reducing the number of compilations.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;system structure&lt;br /&gt;
Decomposition of a large system into modules is probably the single most important factor in determining its performance.&lt;br /&gt;
After sketching the overall system, you should do a 'back-of-the-envelop' estimate to ensure the performance, because efficiency is much easier to build into a new system than to retrofit into an existing one.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;algorithms&lt;br /&gt;
The keys to a fast module.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;code tuning  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;system software&lt;br /&gt;
Is a new database system faster for the queries?&lt;br /&gt;
Would a different operating system be better suited to the system?&lt;br /&gt;
Are all possible compiler optimizations are enabled?  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hardware&lt;br /&gt;
general-purpose computers -&amp;gt; special-purpose computers&lt;br /&gt;
adding a floating point accelerator  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Principles&lt;/h3&gt;
&lt;p&gt;Simple design can't be overemphasized:&lt;br /&gt;
&lt;em&gt;The cheapest, fastest and most reliable components of a computer system are thoses that aren't there.&lt;/em&gt;  &lt;/p&gt;</summary><category term="algorithm"></category><category term="cpp"></category></entry><entry><title>Rereading Programming Pearls(7)</title><link href="http://particle128.com/posts/2014/02/pp7.html" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-02-20:posts/2014/02/pp7.html</id><summary type="html">&lt;h2&gt;Column 7 The back of the envelope&lt;/h2&gt;
&lt;h3&gt;rules of thumb&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;rule of 72&lt;br /&gt;
Used for estimating the growth of any exponential process.&lt;br /&gt;
&lt;em&gt;Assume that you invest a sum of money for y years at an interest rate of r percent per year. The financial version of the rule says that if r x y=72, then your money will roughly double.&lt;/em&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tom Duff's rule&lt;br /&gt;
&lt;em&gt;PI seconds is a nanocentury&lt;/em&gt;&lt;br /&gt;
It is to say, a year equals to 3.14 x 10^7s  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;safety factors&lt;/h3&gt;
&lt;p&gt;In calculating our real-time software system, we ought to derate them by a factor of 2, or 4, or 6 to compensate for our ignorance of the problem at hand.  &lt;/p&gt;
&lt;h3&gt;Little's law&lt;/h3&gt;
&lt;p&gt;The average number of things in a system is the product of the average rate at which things leave the system and the average time each one spends in the system. If there is a gross slow balance, the exit rate is also the entry rate.  &lt;/p&gt;</summary><category term="cpp"></category><category term="algorithm"></category></entry><entry><title>MoreEffectiveC++(4)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(4).html" rel="alternate"></link><updated>2013-12-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-14:posts/2013/12/MoreEffectiveCpp(4).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;技术Techniques,Idioms,Patterns&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item25 构造函数、非成员函数的虚化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这一条目所指的“虚化”，并不是C++语法意义上的虚化，而是“动态调用”的意思。  &lt;/li&gt;
&lt;li&gt;3种语义上的虚化：&lt;br /&gt;
1.虚构造函数&lt;br /&gt;
根据输入（磁盘、网络、终端），可产生不同类型的对象，保存于&lt;code&gt;list&amp;lt;Base*&amp;gt;&lt;/code&gt;中&lt;br /&gt;
2.虚拷贝构造函数&lt;br /&gt;
定义虚函数clone，返回一个指针，指向调用者副本（&lt;code&gt;return new TextBlock(*this);&lt;/code&gt;），复制构造函数通过基类指针调用不同的clone&lt;br /&gt;
3.虚非成员函数&lt;br /&gt;
定义虚函数print，参数和返回值都是ostream&amp;amp;，定义非成员函数&lt;code&gt;inline ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s,const Base&amp;amp; c){return c.print(s);}&lt;/code&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item26 限制一个类所能产生的对象数量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;杂类知识：&lt;br /&gt;
1.不能在类成员变量里定义自身类型的对象，否则编译器报错&lt;code&gt;incomplete type&lt;/code&gt;。但是可以在类成员函数（包括inline构造函数）中定义该类类型的对象。&lt;br /&gt;
2.希望该类不能实例化对象，声明protected ctor；希望该类不能被继承和实例化对象，声明private ctor。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:The above method can only restrict the construction of objects on the stack. Because you can define a static/friend function, in which new an object and return a pointer to that.&lt;br /&gt;
3.基类指针、引用指向派生类对象，必须是public继承，private和protected继承都会报错&lt;code&gt;'Base' is an inaccessible base of 'Derived'&lt;/code&gt;。一般允许当作基类的类都要定义virtual dtor，但是如果该基类只被private或protected继承的话，不需要定义虚析构函数。  &lt;/li&gt;
&lt;li&gt;限制对象数量，方法如下：&lt;br /&gt;
(1)声明private ctor，友元/静态成员函数定义如下  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;thePrinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Printer&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;评价：仅限于只允许一个对象的情况&lt;br /&gt;
(2)类中定义静态数据成员count，定义一个异常类TooManyObject，构造函数计算count并抛出异常&lt;br /&gt;
评价：允许多个对象；但是，继承或包含该类的类的定义，也会造成count累积抛出异常。&lt;br /&gt;
(3)同上，另外构造函数私有化，提供友元/静态成员函数&lt;code&gt;makePrinter(){return new Printer()}&lt;/code&gt;。&lt;br /&gt;
评价：允许多个对象，不会出现上述问题，因为直接就不让继承该类或定义该类的对象了；但是，只能产生heap上的对象，需要手动delete或放到智能指针里。&lt;br /&gt;
(4)定义计数类模版  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;//每个class类型有一个计数器（maxObjects），所以定义成模版  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;  
&lt;span class="nl"&gt;protected:&lt;/span&gt;  
    &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//protected构造函数，防止实例化  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;maxObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//不定义maxObjects，让用户自己定义，比如const size_t Counted&amp;lt;Printer&amp;gt;::maxObjects=10;  &lt;/span&gt;
&lt;span class="c1"&gt;//私有继承，语义上是：implemented in terms of；功能上是：防止基类指针/引用访问派生类对象  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item27 要求，或禁止对象产生于堆上&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为什么需要对象产生于堆上：&lt;br /&gt;
需要一种对象，可以在作用域离开之前撤销自己，即&lt;code&gt;delete this&lt;/code&gt;的功能。  &lt;/li&gt;
&lt;li&gt;为什么需要对象禁止在堆上产生：&lt;br /&gt;
嵌入式系统中堆上的资源比较有限  &lt;/li&gt;
&lt;li&gt;要求对象产生于堆上：&lt;br /&gt;
1.private/protected dtor,public ctors&lt;br /&gt;
2.定义&lt;code&gt;public void destory const(){delete this;}&lt;/code&gt;&lt;br /&gt;
这样，只能通过Obj* po=new Obj;调用，只能通过po-&amp;gt;destory()释放。因为定义类的对象（Obj o;）的时候会检查ctor和dtor的可访问性，有一个不可访问就会编译出错。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：&lt;br /&gt;
1.private ctors也可以限制构造对象，但是构造函数比较多，都需要一一定义为private，不如析构函数方便&lt;br /&gt;
2.如果需要保证继承，将dtor定义为protected.  &lt;/li&gt;
&lt;li&gt;禁止对象产生于堆上：&lt;br /&gt;
定义private限定的operator new，operator delete，operator new[]，operator delete[]&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;:基类的operator new私有化，那么派生类如果不在public里重新定义operator new，调用Derived *pd=new Derived;就会出错。只要Derived类中存在operator new，即使不可访问（private或protected），new操作符也不会转而调用全局作用域的operator new。  &lt;/li&gt;
&lt;li&gt;没有具备移植性的正确的办法，可以判断一个对象位于堆内。&lt;br /&gt;
1.定义类内static bool isOnHeap，类内operator new设置isOnHeap，构造函数判断isOnHeap的值，并在最后恢复isOnHeap为false&lt;br /&gt;
缺点：线程不安全；new一个数组会出错，即使定义了operator new&lt;a href="分配一次，构造多次，第二个构造中isOnHeap为false"&gt;&lt;/a&gt;&lt;br /&gt;
2.根据进程在内存中的布局（栈位于最高地址，向下增长；静态存储区位于最低地址，向上增长；堆位于静态存储区上，向上增长）  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//栈顶，最低地址  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//只有堆地址或静态存储区才小于栈地址  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺点：布局依赖操作系统实现，不具备移植性；无法区分静态和堆上的对象  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法明确确定位于堆上，但是可以比较容易的判断是否可以delete&lt;br /&gt;
1.定义全局operator new，分配空间的同时，保存这个地址在一个全局list里。全局operator delete判断全局list里是否存在该地址&lt;br /&gt;
缺点：污染其他代码；效率；Base1* pb=new Derived()，多重继承下基类地址可能不同于派生类对象地址，造成判断错误&lt;br /&gt;
2.定义abstract mixin base class（抽象混合式基类），把operator new,operator delete，list都保存于其中  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;HeapTrack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//解决上述第3个问题，把基类this指针转换成派生类对象地址  &lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rawAddr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="cm"&gt;/*判断list中是否包含rawAddr*/&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：派生类中的基类函数，参数this的类型为指向基类类型的指针常量。否则一个类被多个类继承，该类的所有函数就要有多份重载的代码。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(5)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(5).html" rel="alternate"></link><updated>2013-12-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-14:posts/2013/12/MoreEffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item28 Smart pointer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;智能指针相比于内置指针的优势：&lt;br /&gt;
1.构造和析构：分别防止wild指针（默认实参是0）和内存泄露（dtor内delete对象）&lt;br /&gt;
2.复制和赋值：可以定义出3种语义：深复制、浅复制(加引用计数、或转移控制权)、不允许复制&lt;br /&gt;
3.解引用(dereference)：包括&lt;code&gt;-&amp;gt;&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;操作符(都是const函数)，可以实现出lazy fetching（数据库中的对象的访问）  &lt;/li&gt;
&lt;li&gt;志记工作最好使用一个类的构造函数和析构函数(自动调用)来标明开始和结束，而不是显示调用两个函数。这对异常更加稳健。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;作为参数，必须引用传递，否则调用之后，原&lt;code&gt;auto_ptr&lt;/code&gt;对象中的指针为0，不能访问了。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：除了内置类型、STL迭代器、函数对象，其余对象最好都用引用传递参数  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的operator=操作符，需要在开始处判断&lt;code&gt;if (this==&amp;amp;rhs)&lt;/code&gt;，因为之后会&lt;code&gt;delete rhs&lt;/code&gt;。&lt;br /&gt;
不需要判断，只调整语句顺序的情况：&lt;br /&gt;
1.new+delete都有的函数:deep copy&lt;br /&gt;
2.new+delete都没有的函数:复制值  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的对象，如果保存的不是new分配的堆对象，释放的时候会段错误，编译没有错误。  &lt;/li&gt;
&lt;li&gt;pt是一个对象，&lt;code&gt;pt-&amp;gt;display()&lt;/code&gt;会被编译器翻译成&lt;code&gt;(pt.operator-&amp;gt;())-&amp;gt;display()&lt;/code&gt;，(1)返回的对象keyi调用&lt;code&gt;-&amp;gt;&lt;/code&gt;操作符，(2)返回a pointer。  &lt;/li&gt;
&lt;li&gt;提供功能，测试智能指针是否为null&lt;br /&gt;
1.添加成员函数&lt;code&gt;isNull()&lt;/code&gt;：不直观，无法调用if(ptn)或if(ptn==0)或if(!ptn)&lt;br /&gt;
2.重载&lt;code&gt;operator bool()&lt;/code&gt;，或&lt;code&gt;opertor!()&lt;/code&gt;：前者3种形式都满足，但是可能允许不同类型的指针互相比较，后者则只能实现第3种语义&lt;br /&gt;
3.转换操作符&lt;code&gt;operator T*()&lt;/code&gt;：3种形式都满足，但是允许用户delete SmartPtr类型对象，会导致内存泄露。&lt;br /&gt;
总结：可以使用第二种方法，但是定义const get()成员函数返回原始指针。  &lt;/li&gt;
&lt;li&gt;要实现&lt;code&gt;SmartPtr&amp;lt;Base&amp;gt;&lt;/code&gt;的指针或引用，指向&lt;code&gt;SmartPtr&amp;lt;Derived&amp;gt;&lt;/code&gt;对象：&lt;br /&gt;
1.特化&lt;code&gt;SmartPtr&amp;lt;Derived&amp;gt;&lt;/code&gt;，并定义如下转换操作符:  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointee&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺点：必须所有派生类，而且必须给每一个派生类特化版本定义到所有基类（包括间接基类）的转换函数，因为不允许2次类类型转换.&lt;br /&gt;
2.在SmartPtr模版里定义如下成员模版：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointee&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：不仅适用于派生体系，只要raw pointer可以隐式转换，包裹在外面的SmartPtr都可以隐式转换，比如non-const指针转成const指针；non-void指针转成void指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_con&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_void&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base_of_T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//此处函数参数必须为常量引用，因为转换操作符返回一个临时对象  &lt;/span&gt;
&lt;span class="c1"&gt;//(临时对象：源码中不可见的对象，比如函数返回值、异常对象、表达式结果对象(比如1+2))  &lt;/span&gt;
&lt;span class="c1"&gt;//临时对象不能传递给非常量引用，因此编译器不允许调用转换操作符  &lt;/span&gt;
&lt;span class="c1"&gt;//这是C++对函数参数的一个语义限制，因为非常量引用在函数中可能被修改  &lt;/span&gt;
&lt;span class="c1"&gt;//而如果该修改作用在临时对象上，函数返回之前会被销毁，无法传递给程序，所以不允许.  &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base_of_T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;  
&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;再次强调，非常量引用不能指向临时对象&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：以上两种实现中，都含有SmartPtr的构造函数，参数是原始指针。原始指针出现在继承体系的两个对象中，所以不能使用auto_ptr的构造和析构函数，否则会出现多次delete同一块内存的情况，应当使用reference counting。&lt;br /&gt;
&lt;em&gt; 派生类指针，转换成距离自己更近的基类指针的代价更小，不会造成二义性。&lt;br /&gt;
&lt;/em&gt; const T * const 对应的智能指针版本就是：&lt;code&gt;const SmartPtr&amp;lt;const T&amp;gt;&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item29 Reference counting(引用计数)&lt;/h2&gt;
&lt;p&gt;略  &lt;/p&gt;
&lt;h2&gt;Item30 Proxy classes(代理类)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代理类的使用场景&lt;br /&gt;
1.抑制单参构造函数所引起的隐式类类型转换&lt;br /&gt;
在不支持explicit的情形下，可以通过代理类模拟explicit的行为。&lt;br /&gt;
思路:类类型转换只能进行一次，让参数进行一次，那么所要限制的类本身就不能隐式类型转换了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//代理类，用来代理Array构造函数的参数  &lt;/span&gt;
            &lt;span class="nl"&gt;public:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.构造出多维数组类型，且使用起来像arr[1][2]&lt;br /&gt;
C++标准中不支持每维都是变量的多维数组（C99中好像支持），自定义类类型Array2D。&lt;br /&gt;
C++中又不能重载operator[][]函数，所以通过代理类模拟Array2D[1][2]的访问方式。&lt;br /&gt;
思路:Array2D的operator[]返回返回一个代理类对象Array1D，Array1D支持operator[]返回一个实际对象  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array2D&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;Array1D&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//代理类，用来代理第一维的operator[]的返回值  &lt;/span&gt;
            &lt;span class="nl"&gt;public:&lt;/span&gt;  
                &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;Array1D&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//Array1D是函数内局部对象，所以不返回引用  &lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Array1D&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;:如果可以接受array(1,2)这种访问二维数组的方式，可以重载operator(int idx1,int idx2)函数&lt;br /&gt;
3.区分operator[]的读写行为  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CharProxy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//写  &lt;/span&gt;
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//写  &lt;/span&gt;
                &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//读  &lt;/span&gt;
            &lt;span class="nl"&gt;private:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;theString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;CharProxy&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//省略const版本  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;代理类有其限制  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;=&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//&amp;amp;不可以  &lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="c1"&gt;//传递给reference-to-non-const出错，因为是代理类的临时对象而不是引用  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有些限制可以通过重载操作符来实现，非常麻烦。而传递参数的问题则没法避免。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(3)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(3).html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-06:posts/2013/12/MoreEffectiveCpp(3).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;效率Efficiency&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item16 80-20 principal&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Most programs' performance bottle-neck is inclined to high counter-intuition. If you just improve programs here and there, it won't help a lot.  &lt;/li&gt;
&lt;li&gt;The accurate way to do this is to use program profiler(程序分析器).  &lt;/li&gt;
&lt;li&gt;Offer as much data as possible to the profiler, to find the real bottle-neck.  &lt;/li&gt;
&lt;li&gt;Make sure that every group of data is representative(典型的，可重现的).  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item17 consider to use Lazy Evaluation(缓式评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First of all, let me quote a sentence：  &lt;blockquote&gt;
&lt;p&gt;从效率的观点来看，最好的运算是从未被执行的运算。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Lazy evaluation means you should write your class in the way that calculation should be made only when it's urgent.&lt;br /&gt;
Three usages:&lt;br /&gt;
1.reference counting&lt;br /&gt;
Maybe some copy behaviour is no use.  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//need not malloc and copy,just assign a pointer  &lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConvertToUpper&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//need to malloc and copy  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.lazy fetching&lt;br /&gt;
Maybe a large table only need a small part.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LargeObject&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;LargeObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//just assign private pointers to 0  &lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;field1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//connect to the database and fetch data  &lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;field2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;oid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fieldValue1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filedValue2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.lazy expression evaluation&lt;br /&gt;
Maybe you just need to calculate some parts.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//just store two pointers to m2 and m3,and a enum indicating it&amp;#39;s addition  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//only calculate the fourth line//define operator[]  &lt;/span&gt;
&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//have to change m1,which has a pointer to m2.//overload operator+  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Don't over do it.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item18 consider to use Over-Eager Evaluation(超急评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Two usages:&lt;br /&gt;
1.caching  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="nf"&gt;CubicleNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Cubicle&lt;/span&gt; &lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//访问数据库耗时，访问缓存快速  &lt;/span&gt;
    &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*get info from the databse and update cubes*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//more portable than it-&amp;gt;second}  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.prefetching&lt;br /&gt;
when it needs x spaces, allocate 2x spaces.
因为系统调用（operator new中malloc）耗时，所以尽量一次分配更多的空间。调用进程内函数快速。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trade space for time.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item19 understand the sources of Temporary Objects&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++中的临时对象是在栈上分配的匿名对象或不可见对象。&lt;/li&gt;
&lt;li&gt;匿名对象举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;不可见对象两种情况：&lt;br /&gt;
1.隐式类型转换得到的对象。
&lt;strong&gt;Note&lt;/strong&gt;:reference-to-non-const参数不能接受需要隐式类型转换的对象，因为参数可能会在函数中被修改，而修改仅仅作用于临时对象，C++禁止这种行为，编译失败，报错&lt;code&gt;invalid initialization of non-const reference of type ‘std::string&amp;amp; {aka std::basic_string&amp;lt;char&amp;gt;&amp;amp;}’ from an rvalue of type ‘char*’&lt;/code&gt;&lt;br /&gt;
2.返回对象。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item20 降低返回值临时对象的成本return value optimization(RVO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;书上说在return表达式中，返回匿名临时对象（比如&lt;code&gt;return Rational(lhs.num()*rhs.num(),lhs.den()*rhs.den())&lt;/code&gt;），可以让编译器进行返回值优化（消除匿名临时对象以及返回值临时对象的构造和析构函数成本。把函数中return语句后面的内容提到调用者作用域中，&lt;code&gt;Rational c=a*b;&lt;/code&gt;中仅有c的构造成本）。  &lt;/li&gt;
&lt;li&gt;注释又说“1996年ISO/ANSI标准委员会又宣布，返回命名对象和匿名对象都可以借助RVO被优化去掉。”后者可能在编译器下具备更好的优化性能。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item21 消除参数临时对象的成本use overload&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以重载一堆函数，来代替隐式类型转换，来消除参数临时对象的构造和析构成本。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:每个重载操作符，都必须获得至少一个“用户定制类型”的自变量。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item22 操作符复合形式效率&amp;gt;独身形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果编译器无法进行RVO，那么operator+运算，会构造并析构两个对象：局部对象和返回值临时对象。替换成类内成员函数operator+=，则无需构造这两个对象。  &lt;/li&gt;
&lt;li&gt;可行的方案是：类内定义operator+=，类外定义模版operator+（使用对象的operator+=）。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:匿名对象比命名对象容易被消除，所以尽量选择前者。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item23 考虑使用其他程序库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用benchmark(性能评估软件)，判断某个程序库在特定软件里，性能如何，然后做出取舍。  &lt;/li&gt;
&lt;li&gt;iostream比stdio的速度慢20%~200%，程序大小也大很多，但是如果io不是瓶颈，不需要用stdio代替iostream，毕竟类型安全。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item24 了解虚函数等的成本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;看完Inside C++ Object Model回来看，现在看的不是很透彻。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(2)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(2).html" rel="alternate"></link><updated>2013-12-03T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-03:posts/2013/12/MoreEffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自增自减操作符，两原则：&lt;br /&gt;
1.postfix increment和decrement操作符，应该返回const对象，理由是：不允许进行两次后置++，防止用户把比较操作符写成赋值操作符而通过编译。  &lt;blockquote&gt;
&lt;p&gt;设计类的一条无上宝典就是：一旦有疑虑，试看int行为如何并遵循之。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.后自增和自减应该调用前自增和自减，而不是自己写函数，这样只需要维护前自增。  &lt;/p&gt;
&lt;h2&gt;Item7&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要重载&amp;amp;&amp;amp;，||和，操作符，因为无论定义成员或非成员函数，都无法模拟C++中这3个操作符的行为模式（短路，求值顺序）。  &lt;/li&gt;
&lt;li&gt;for语句头包括3个部分，第1部分是语句，所以可以定义多个变量。第3部分是表达式，所以只能用逗号隔开多个表达式，而不能使用定义变量。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item8&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;placement new类似于new，首先调用operator new，然后调用对象构造函数，然后返回内存指针。&lt;br /&gt;
不同点，是placement new调用的operator new的原型和实现如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//第一个参数不提供名字，防止编译器警告。  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;placement new构造的对象，可能位于operator new分配的内存，也可能不是。如果不确定是不是，就不要调用delete来释放，否则可能未定义。因为delete析构对象之后调用operator delete释放内存，而这段内存如果是malloc分配的，或者是静态的内存，用operator delete释放都会出问题。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异常Exception&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item9&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;利用析构函数(smart pointer处理单个对象，vector处理对象数组)避免资源泄露，绝不使用操纵局部资源的指针。&lt;br /&gt;
因为即使加了try和catch语句块包裹可能出现异常的代码，也会把代码变得支离破碎，而且delete会出现两遍（正常执行序列的最后，catch中throw到上一层之前）  &lt;/li&gt;
&lt;li&gt;C++加入异常的概念，意义：&lt;br /&gt;
保证错误的发生绝不会被忽略，而C语言中置errno或返回错误代码的方法，都可能因为调用者的不检查而使错误不被发现。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item10 在构造函数中阻止资源泄露(resource leak)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对象未构造完全(构造函数中抛出异常)，不会调用其析构函数，但是对象的成员变量会保证释放（如果是类类型，自动调用其析构）。在ctor中动态分配资源可能因为异常的出现，泄露了。&lt;br /&gt;
原因：&lt;br /&gt;
析构函数如果需要在构造不完全的对象上自动执行，就得记录构造函数执行到的位置，代价太大。  &lt;/li&gt;
&lt;li&gt;构造函数动态分配资源的情况下，防止资源泄露的解决办法&lt;br /&gt;
1.构造函数中try+catch&lt;br /&gt;
2.类中使用auto_ptr成员代替指针成员  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item11 禁止异常流出dtor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;析构函数调用时机&lt;br /&gt;
1.退出作用域&lt;br /&gt;
2.stack unwinding时&lt;br /&gt;
3.delete&lt;br /&gt;
4.手动调用  &lt;/li&gt;
&lt;li&gt;禁止异常流出的原因：&lt;br /&gt;
1.避免在stack unwinding时，析构函数抛出的异常导致terminate函数执行，中止程序。&lt;br /&gt;
考虑上线的软件，因为1个异常就down机了，这绝不是人们想看到的。&lt;br /&gt;
2.协助确保dtor完成了所有事情。&lt;br /&gt;
考虑析构函数有多条语句，第一条语句执行中抛出异常，后面的语句没法执行，但是可能很重要，比如释放对象资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item12 区分异常和函数调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如下示例：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;  
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//抛出的是类型为Base的异常对象。只有在基类指针或引用指向派生类对象，且调用虚函数的情况下才会看动态类型，其余都是静态类型。  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;异常对象是抛出对象的副本，是一个临时对象，一般临时对象不能给非常量引用赋值。但是catch字句中non-const引用也可以捕获，这是一个特例。  &lt;/li&gt;
&lt;li&gt;异常和函数调用区别：&lt;br /&gt;
1.总会被复制，需要支持复制构造&lt;br /&gt;
2.允许的类型转换很少(非const到const，派生类到基类(指针引用对象都可)，指针到void*，数组到数组指针，函数到函数指针)&lt;br /&gt;
3.按catch子句出现的顺序匹配，而不是最佳匹配  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item13 以引用方式捕获异常&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原因：&lt;br /&gt;
1.by-pointer:不知道是全局和静态对象，还是动态对象，所以不知道要不要delete；和语言本身可能抛出的异常(bad_alloc等)不符合&lt;br /&gt;
2.by-value:切割对象，无法多态；复制对象成本高&lt;br /&gt;
3.by-reference:没上面的问题  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item14 异常说明符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;try和catch后面的语句必须用大括号包围，即使只有1条语句。  &lt;/li&gt;
&lt;li&gt;当抛出exception specification中没有出现的异常时，unexpected函数会被系统调用，默认调用terminate中止程序。&lt;br /&gt;
就像不希望析构函数抛出异常一样，必须防止任何中止程序(很可能是需要一直运行的服务程序)的行为，即使有错误发生。&lt;br /&gt;
注意：&lt;br /&gt;
1.不要给模版函数提供异常说明。因为模版的类型实参千变万化，无法预料抛出异常的情况。&lt;br /&gt;
2.需要调用没有异常说明的函数，自己也不要给出异常说明。&lt;br /&gt;
3.不使用默认版本的unexcepted函数：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一种方式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;span class="c1"&gt;//第二种方式  &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;;}&lt;/span&gt;&lt;span class="c1"&gt;//重抛，默认抛出bad_exception  &lt;/span&gt;
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：采用了上面任一种方式后，需要在函数的异常说明符中加入UnexpectedException或bad_exception，否则还是会terminate。  &lt;/p&gt;
&lt;h2&gt;Item15 understand exception handling's cost&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;即使从未使用exception处理机制，程序为了支持exception，也需要放置一些数据结构占用空间，维护这些数据结构占用时间。  &lt;/li&gt;
&lt;li&gt;try语句，以及异常说明，会导致代码膨胀和速度下降5%~10%（一些测试结果，并未很准确）。异常的真正抛出，会比正常函数返回，慢3个数量级（同上，不准确）。  &lt;/li&gt;
&lt;li&gt;代价很大，所以仅在非用不可的时候才使用，不要像写python那样轻易使用。  &lt;/li&gt;
&lt;li&gt;如果确保自己的程序中没有用到exception机制，并且确保调用的标准库没有用到，例如没有try catch throw关键字，那么可以通过编译器的选项禁止。&lt;br /&gt;
g++下的禁止方式是&lt;code&gt;-fno-exceptions&lt;/code&gt;。如果有异常抛出（new无法分配等），直接调用std::abort()进行中止。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(1)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(1).html" rel="alternate"></link><updated>2013-12-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-02:posts/2013/12/MoreEffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有实现bool类型的编译器，替代方案：&lt;br /&gt;
(1)enum bool{false,true};&lt;br /&gt;
缺点：无法int赋值给bool变量&lt;br /&gt;
(2)typedef int bool;&lt;br /&gt;
const bool false=0;&lt;br /&gt;
const bool true=1;&lt;br /&gt;
缺点：无法重载bool和int参数的函数  &lt;/li&gt;
&lt;li&gt;C++中内存泄露，不一定只是new出的对象中的数据成员泄露了，还可能在构造函数(ctor)中创建了其他资源，也泄露了。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基础议题Basics&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有null reference，所以有时候使用引用可能比使用指针更有效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//使用指针  &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//使用引用  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;const_cast用于改变constnest和valatileness  &lt;/li&gt;
&lt;li&gt;reinterpret_cast与编译器息息相关，不具备移植性。最常见用途：转换函数指针  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  
&lt;span class="n"&gt;FuncPtr&lt;/span&gt; &lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;经典语录&lt;blockquote&gt;
&lt;p&gt;让转型动作既丑陋又不易键入，或许未尝不是件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要以多态方式处理数组，因为数组对象总是会涉及指针算术运算，而指针位置的移动是按照指针类型的对象大小来算的，而不是指向实际对象大小。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//pb[i]是*(pb+i)的简写，代表pb+i*sizeof(Base)  &lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//同样不行，相当于循环中从后向前调用pb[j].~Base();  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不提供默认构造函数，会有3个限制：&lt;br /&gt;
1.不方便定义数组，以普通方式（&lt;code&gt;X a[N]&lt;/code&gt;）定义的数组调用默认构造函数&lt;br /&gt;
解决：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一个方法，仅用于静态数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)};&lt;/span&gt;   
&lt;span class="c1"&gt;//第二个方法，动态数组，需要额外空间保存指针数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//或 X* pX[3];  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//第三个方法，动态数组，不需要额外空间  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.不适于很多基于模版的容器类(template-based container class)&lt;br /&gt;
因为很多容器类都有单参构造函数，参数是容器的size，所以里面可能调用的&lt;code&gt;data=new T[size];&lt;/code&gt;。&lt;br /&gt;
但是设计良好的模版类，应该不依赖默认构造函数，像vector，可能使用上面3种方法的后两种解决的。&lt;br /&gt;
3.虚基类如果没有默认构造函数，对于派生类来说非常不方便。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果提供默认构造函数，可能产生没有被完全初始化的对象，如果如果不在乎上面的3个限制（不需要面对数组，不需要存入默认容器，不需要做虚基类），就不提供默认构造函数。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作符operators&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注意右尖括号中间加空格，否则会因为词法分析是用的贪心算法，两个尖括号会组成了一个词法单元。&lt;br /&gt;
&lt;code&gt;static_cast&amp;lt;Array&amp;lt;int&amp;gt; &amp;gt;(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量不用conversion operator，因为很可能在你没意识到的情况下隐式调用了。&lt;br /&gt;
解决：&lt;br /&gt;
显示定义一个函数，比如&lt;code&gt;double asDouble() const&lt;/code&gt;。这样虽然写起来很麻烦，但是可以防止很多错误。  &lt;blockquote&gt;
&lt;p&gt;越有经验的C++程序员越会避免使用类型转换操作符，比如string类型没有隐式转换成char *的conversion operator，而是包含&lt;code&gt;c_str()&lt;/code&gt; 函数。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;尽量不要使用conversion constructor，道理同上。&lt;br /&gt;
解决：&lt;br /&gt;
1.explicit&lt;br /&gt;
2.用代理类模拟,例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(7)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(7).html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/MoreEffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 32 在未来时态下发展程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;面向对象方法应用于系统构造的一个强大力量就是，它支持日后的变化  &lt;/li&gt;
&lt;li&gt;请为每一个类处理复制和赋值动作，即使这样的动作暂时没有人使用。如果这些函数不易完成，请将其声明为private  &lt;/li&gt;
&lt;li&gt;没有virtual destructor的String类，不能用于当作基类(因为当作基类，就有delete指向派生对象的基类指针的可能性)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 33 将非尾端(non-leaf)类设计为抽象类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑这样一个继承体系&lt;br /&gt;
具体类Animal -&amp;gt;派生Lizard和Chicken&lt;br /&gt;
可能出现部分赋值（partial assignment）的问题：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//Animal部分赋值，Lizard部分没有赋值  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;解决方法：&lt;br /&gt;
1.operator=变成虚函数从而利用多态实现派生类的赋值  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//C++允许返回值不同，但是参数类型必须相同，否则就是在Lizard中重载了operator=操作符，没有实现多态  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;*pa=*pb&lt;/code&gt;这种情况可以利用多态，即根据pa实际指向的对象，调用对应的&lt;code&gt;virtual operator=&lt;/code&gt;&lt;br /&gt;
问题：允许了如下情形  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Chicken&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//异型赋值  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决：&lt;br /&gt;
operator=函数里用dynamic_cast转型； 同时定义一个重载函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="c1"&gt;//原virtual operator=(const Animal&amp;amp;)里dynamic_cast进行判断，防止异型赋值  &lt;/span&gt;
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//重载一个普通版本，降低Lizard对象之间赋值的成本  &lt;/span&gt;
        &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.将Animal中的opeartor=设为protected&lt;br /&gt;
这样做，直接不允许了进行&lt;em&gt;pa=&lt;/em&gt;pb这种行为，但是同时也限制了Animal对象之间的赋值。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;终极解决方法：&lt;br /&gt;
将Animal当作和Lizard、chicken一样的类，然后共同继承自抽象类AbstractAnimal类，该类几乎和原Animal一样即可（相同的成员函数，相同的数据成员）。&lt;br /&gt;
AbstractAnimal的operator=设为protected。&lt;br /&gt;
这样就限定了&lt;em&gt;pa=&lt;/em&gt;pb这种行为，而且没有AbstractAnimal对象之间的赋值问题。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：仅仅定义纯虚函数，还是可以&lt;code&gt;*pa=*pb&lt;/code&gt;这类部分赋值(更常用的说法是slicing)，因为这并没有实例化抽象类，只是把派生类切割成基类部分，然后进行了赋值。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纯虚函数的意义是：使所在类为抽象类；使该函数必须被派生类重定义(否则派生类还是抽象类)。&lt;br /&gt;
一般纯虚函数可以不给予实现，但是如果析构函数是纯虚函数，必须给予实现（即使是空函数也是实现），因为派生类的析构会调用它。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么时候需要抽象出抽象类？&lt;br /&gt;
答：&lt;br /&gt;
1.具体类被派生时。这可以防止刚才遇到的赋值问题，还有Item3讲到的基类数组参数指向派生类数组的问题（当基类是抽象类时，就不会想要使用基类数组参数了）。&lt;br /&gt;
2.不要在一开始就定义一个抽象类，在前面的发生发生后才做。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要派生第三方类库中的具体类，怎么办？&lt;br /&gt;
答：&lt;br /&gt;
1.派生具体类，但是小心基类指针解引用后的部分赋值问题，还有不要将派生类数组传入基类数组作为参数的函数。&lt;br /&gt;
缺点：容易出错&lt;br /&gt;
2.找找这个类库中有没有上层的抽象类，然后继承自它&lt;br /&gt;
缺点：需要实现很多本来可以继承的东西&lt;br /&gt;
3.将该具体类的对象当作自己要定义的类的数据成员&lt;br /&gt;
缺点：不能享受继承的一些特性：多态&lt;br /&gt;
4.直接用这个具体类，然后加一些非成员函数在外面。&lt;br /&gt;
缺点：代码不够清爽，不好维护。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item34 在同一个程序里结合C++和C&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;extern "C"的使用&lt;br /&gt;
作用：阻止name mangling（名称重整）&lt;br /&gt;
1.C++程序使用C语言写的库函数，需要声明成  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用时不会mangling  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.C++程序写一个供C语言调用的库，需要声明成  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//实现时不会mangling  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.C或C++要使用C语言写的库函数，加入如下头文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;&lt;span class="c1"&gt;//C++预处理器符号，C语言程序自动跳过该extern &amp;quot;C&amp;quot;块  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="cp"&gt;#endif  &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="cp"&gt;#ifdef __cplusplus  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="cp"&gt;#endif  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;statics的初始化&lt;br /&gt;
静态对象包括：全局对象(program scope)，类静态对象(class scope)，namespace内对象(namespace scope)，文件内静态对象(file scope)&lt;br /&gt;
C++会在main函数之前，加入一段对静态对象的构造语句，称为static initialization&lt;br /&gt;
同时，会在main函数之后，加入一段对静态对象的析构语句，称为static destruction&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：anonymous namespace的出现，相当于取代了文件静态对象;函数内静态对象不属于“静态对象”的范畴，它的初始化是在第一次调用的时候，而不是main之前。&lt;/li&gt;
&lt;li&gt;new和delete，malloc和free必须成对&lt;br /&gt;
否则结果未定义  &lt;/li&gt;
&lt;li&gt;数据结构兼容性&lt;br /&gt;
不能传递的有：&lt;br /&gt;
对象，&lt;br /&gt;
成员函数指针&lt;br /&gt;
可以兼容传递的有：&lt;br /&gt;
普通指针（指向对象、非成员函数/静态成员函数），&lt;br /&gt;
内置类型变量，&lt;br /&gt;
某些struct对象（满足：不含有虚函数，不继承自其他对象）  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(6)</title><link href="http://particle128.com/posts/2013/11/MoreEffectiveCpp(6).html" rel="alternate"></link><updated>2013-11-29T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-29:posts/2013/11/MoreEffectiveCpp(6).html</id><summary type="html">&lt;p&gt;&lt;em&gt;感受&lt;/em&gt;：这一章几乎用了一天时间阅读和消化，面向对象设计思想很薄弱，对作者设计时考虑的全面性很是叹服，需要以后要多思考和实际参与设计来锻炼设计能力。  &lt;/p&gt;
&lt;h2&gt;Item31: 让函数根据一个以上的对象类型决定如何虚化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;问题背景：&lt;br /&gt;
假设要设计一款游戏，SpaceShip、SpaceStation还有Asteroid继承自抽象基类GameObject，3个对象两两互相碰撞的情形各不相同。&lt;br /&gt;
需要定义一个碰撞函数，假设是processCollision(GameObject&amp;amp; obj1,GameObject&amp;amp; obj2)，能根据要碰撞的两个对象的类型决定碰撞行为(shipHitStation,stationHitShip等6种)。&lt;br /&gt;
因为游戏在版本更新中，可能不断增加新的GameObject子类，所以该方法要可以扩展。  &lt;/li&gt;
&lt;li&gt;虚函数调用动作被称为message dispatch(消息分派)，processCollision根据两个参数而虚化被成为double-dispatch(双重分派)，更一般的是multiple dispatch(多重分派)  &lt;/li&gt;
&lt;li&gt;解决方法：  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.double-RTTI（书中没提到）&lt;br /&gt;
直接在processCollision里对两个参数都进行RTTI，即调用typeid确定实际类型，借助if-else或switch结构，进行&lt;code&gt;static_cast&lt;/code&gt;转型后，调用实际碰撞函数。&lt;br /&gt;
&lt;strong&gt;注意：因为typeid已经确定了对象的实际类型，用static_cast一定不会出错。如果不完全确定类型，用dynamic_cast转型，万一出错可以抛出异常。&lt;/strong&gt;&lt;br /&gt;
优点：&lt;br /&gt;
如果实际碰撞函数位于类外的话，这种方法不需要修改既有类的定义（SpaceShip等），也就不需要重新编译了.&lt;br /&gt;
缺点：&lt;br /&gt;
该函数看起来有点乱，随着GameObject子类的增加，函数会逐渐膨胀，假设该游戏是个大型网游，可能有几千几万的类型，函数简直无法维护.  &lt;/p&gt;
&lt;p&gt;2.虚函数+RTTI&lt;br /&gt;
碰撞第一个对象用虚函数实现虚化（动态绑定），第二个对象用typeid确定类型并调用类内函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;type_info&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objectType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;objectType&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//process...  &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;&lt;span class="c1"&gt;//健壮程序都要考虑  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
利用虚函数代替了一个RTTI，代码较上一个简洁;&lt;br /&gt;
也不需要修改既有类的定义，只编译既有类对应的文件，而不需要编译使用既有类的文件（头文件没变）&lt;br /&gt;
缺点：&lt;br /&gt;
collide位于类内，每次新增一个GameObject子类，都要修改既有类的collide实现;&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道;&lt;br /&gt;
collide也会膨胀，虽然没0方案这么厉害，仍然不好维护;  &lt;/p&gt;
&lt;p&gt;3.double虚函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;SpaceShip:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//step1  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//step2  &lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//step2  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//第一步动态调用的函数  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//第二步根据参数动态调用  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
充分利用虚函数来去掉手动使用RTTI，代码简洁&lt;br /&gt;
缺点：&lt;br /&gt;
collide位于类内，每次新增一个GameObject子类，都要修改修改既有类的定义（增加一个collide函数），重新编译既有类和所有使用既有类的文件(头文件变了);&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道  &lt;/p&gt;
&lt;p&gt;4.自行仿真虚表(用映射来仿真，而不是vptr)，实质是虚函数+RTTI&lt;br /&gt;
第一步仍然用虚函数collide，第二步用预先定义好的map映射，根据参数的实际类型调用对应的函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;SpaceShip:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//用来仿真虚表的映射。因为C++标准没有定义type_info对象的name()成员函数返回的名字  &lt;/span&gt;
        &lt;span class="c1"&gt;//（可能是&amp;quot;SpaceShip&amp;quot;或&amp;quot;class SpaceShip&amp;quot;等），  &lt;/span&gt;
        &lt;span class="c1"&gt;//所以更好的做法是map&amp;lt;const type_info*,HitFuncPtr&amp;gt;，  &lt;/span&gt;
        &lt;span class="c1"&gt;//因为每一个类型只有一个type_info对象被构造，地址唯一。  &lt;/span&gt;
        &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="nf"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//类属函数，所以声明static  &lt;/span&gt;

        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hitSpaceShip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;spaceShip&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObejct&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//健壮程序都要考虑  &lt;/span&gt;
    &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//用static是保证该函数在使用前先初始化了，在main结束后才销毁  &lt;/span&gt;
    &lt;span class="c1"&gt;//用auto_ptr是因为动态分配的HitMap，所以销毁的时间跟static应该一样  &lt;/span&gt;
    &lt;span class="c1"&gt;//如果initializeCollisionMap使用局部static，返回一个有引用给collisionMap，就不需要auto_ptr包裹了  &lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;autp_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;collisionMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//!!!只能把初始化语句放到一个函数中，实现只执行一次的目的  &lt;/span&gt;
&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HitMap&lt;/span&gt; &lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitMap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phm&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SpaceShip&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hitSpaceShip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意：不要将void func(Derived&amp;amp;)函数用reinterpret_cast强制类型转换成void func(Base&amp;amp;)之后调用。&lt;br /&gt;
多继承(包括菱形继承)情况下，基类引用（实质：指针）和派生类引用不一定相等，实际传入的地址是派生对象中某个基类的地址，但是函数中却认为这个地址是派生类的地址，所以之后取得的任何成员都有错误，因为成员是通过基地址的偏移取得的。&lt;/strong&gt;&lt;br /&gt;
优点：&lt;br /&gt;
虽然同第2种解法一样：结合虚函数和RTTI.但是RTTI是用映射完成的，代码简洁如第3种解法&lt;br /&gt;
缺点：&lt;br /&gt;
hitXXX位于类内，每次新增一个GameObject子类，都要修改修改既有类的定义（增加一个hitXXX函数），重新编译既有类和所有使用既有类的文件(头文件变了);&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道;  &lt;/p&gt;
&lt;p&gt;5.仿真虚表，完全使用非成员函数&lt;br /&gt;
用两个类型名的pair映射实际碰撞函数，实质是double-RTTI，只是用映射的方法使代码的维护更加方便  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//匿名namespace的每样东西对起所在编译单元（文件）而言都是私有的，相当于所有函数声明为static  &lt;/span&gt;
&lt;span class="c1"&gt;//如果在匿名namespace中声明但没有定义一个函数，需要在同一编译单元中另一个匿名namespace中给予实现  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//所有碰撞函数，lookup和initializeCollisionMap函数都在这里  &lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;processCollision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;phf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj2&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
不需要重新编译既有文件，只需要修改processCollision定义所在的文件;&lt;br /&gt;
速度比方法1快，由线性探查(if-else或switch)改为map形式查找（二叉树之类的）&lt;br /&gt;
PS:&lt;br /&gt;
如果想要动态登记和撤销实际碰撞函数的映射，可以再定义一个CollisionMap类，里面包含&lt;code&gt;addEntry(const string&amp;amp; type1,const string&amp;amp; type2,HitFuncPtr func)&lt;/code&gt;和&lt;code&gt;removeEntry(...)&lt;/code&gt;等函数，就可以更加灵活的修改映射，而不需要去动processCollision定义所在文件内函数的代码。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>EffectiveC++笔记汇总</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp.html" rel="alternate"></link><updated>2013-10-31T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-31:posts/2013/10/EffectiveCpp.html</id><summary type="html">&lt;p&gt;笔记汇总：  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html"&gt;EffectiveC++(1)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html"&gt;EffectiveC++(2)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html"&gt;EffectiveC++(3)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html"&gt;EffectiveC++(4)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html"&gt;EffectiveC++(5)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(6).html"&gt;EffectiveC++(6)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html"&gt;EffectiveC++(7)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html"&gt;EffectiveC++(8)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html"&gt;EffectiveC++(9)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html"&gt;EffectiveC++(10)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html"&gt;EffectiveC++(11)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html"&gt;EffectiveC++(12)&lt;/a&gt;  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(2)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html" rel="alternate"></link><updated>2013-10-18T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-18:posts/2013/10/EffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item 05: Know what functions C++ silently writes and calls&lt;/h2&gt;
&lt;p&gt;1.默认生成的4种函数，都是public+inline类型的。  &lt;br /&gt;
2.复制构造函数原型：&lt;code&gt;Empty(const Empty&amp;amp;);&lt;/code&gt; 赋值操作符原型：&lt;code&gt;Empty&amp;amp; operator=(const Empty&amp;amp;);&lt;/code&gt; 为了和内置类型的赋值操作意义相同，返回左值的引用  &lt;br /&gt;
3.唯有这4个函数被调用时，才被产生出来。  &lt;br /&gt;
4.默认产生的析构函数是non-virtual的，除非base class是virtual的。  &lt;br /&gt;
5.3种情况下，赋值操作符不会自动生成：含有const成员，含有ref成员，base class的赋值操作符号是private（这时候，子类无法调用父类的赋值操作符）。    &lt;/p&gt;
&lt;h2&gt;Item 06: Explicitly disallow the use of compiler-generated functions you do not want&lt;/h2&gt;
&lt;p&gt;1.使拷贝构造函数和赋值操作符不可用，两种方式：&lt;br /&gt;
(1)声明为private，且不给予实现。 不论类外（编译错误），还是类内或友元（链接错误），都不能访问这些函数。&lt;br /&gt;
注：此方法可以让任何类成员函数，不能被访问。如果是构造函数，则不能构造对象。&lt;br /&gt;
(2)父类的成员函数是private的。  不论什么继承方式，都在子类中不可见。而拷贝构造和赋值操作都需要调用父类的同类方法，此时编译器无能为力只能不自动生成。访问这些函数将导致编译错误。&lt;br /&gt;
注：同上一item的第5点  &lt;/p&gt;
&lt;h2&gt;Item 07： Declare destructors virtual in polymorphic base classes&lt;/h2&gt;
&lt;p&gt;1.delete父类指针或引用的时候，如果不是virtual析构函数，结果是未定义的。很可能的结果是，只调用了父类的析构函数，对象局部销毁，会造成内存泄露。&lt;br /&gt;
因此，多态基类，一定要定义虚析构函数。&lt;br /&gt;
2.不用于多态基类时，最好不要加上virtual属性，否则会增加一个指针的大小。&lt;br /&gt;
为实现virtual机制，对象需要携带一个vptr(虚表指针)，指向vtbl（虚表，函数指针的数组），用来在运行期间动态确定哪个virtual函数被真正调用。&lt;br /&gt;
3.C++不提供“禁止继承”的机制，Java中final class，或C#中sealed class提供此机制。&lt;br /&gt;
4.尽量不要继承STL容器等包含non-virtual析构函数的类，因为一旦使用多态机制，结果未定义或内存泄露。&lt;br /&gt;
5.需要抽象基类，并且手头没有纯虚函数时，定义纯虚析构函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//声明  &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//定义  &lt;/span&gt;
&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt; &lt;span class="c1"&gt;//之所以需要这个，是因为子类析构时需要调用父类析构函数，不定义会链接错误  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 08: Prevent exceptions from leaving destructors&lt;/h2&gt;
&lt;p&gt;1.析构函数抛出2个异常，可能导致程序终止，或未定义行为。使用标准库容器（set,list）或数组，很容易造成这种情况。所以一定不要让析构函数抛出异常。&lt;br /&gt;
2.正确的做法：提供用户调用可能抛出异常的函数，同时在析构函数里调用该函数，但是捕获其异常。这样用户不仅可以自己捕获异常，也能享受万一忘记调用close，析构函数帮助其close的好处。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;  
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
          &lt;span class="n"&gt;try&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
          &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*记录该事件；要么结束程序要么吞下异常*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(1)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/EffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;【补充概念】&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;类型安全&lt;/strong&gt;：&lt;br /&gt;
&lt;em&gt;MSDN上的权威解释&lt;/em&gt;：类型安全，意味着每个变量、函数参数和函数返回值存储到可接受的数据，并且，涉及不同类型的值“的操作有意义”和不导致数据丢失、位组合的解释不正确或内存损坏。&lt;br /&gt;
&lt;em&gt;简单理解&lt;/em&gt;：编译器会帮助程序员检查程序中是否使用了合适的类型，即如果程序员使用了不正确的类型，编译器会报错，而不会把错误留到运行时。&lt;br /&gt;
printf，memcpy，#define 宏定义函数就不是类型安全的。&lt;br /&gt;
(1) printf("The meaning of life is %s",42);  》》》类型安全的cout&lt;br /&gt;
(2) SomeClass a;AnotherClass b;&lt;br /&gt;
   memcpy((void&lt;em&gt;)&amp;amp;a,(void&lt;/em&gt;)&amp;amp;b,sizeof(b)); 》》》类型安全的copy constructor&lt;br /&gt;
(3) #define max(a,b) ((a)&amp;gt;(b)?(a):(b))  &lt;br /&gt;
   max(15,"abc");max(a++,b); 》》》类型安全的template inline函数（同样效率，函数可预料行为，类型安全）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Item 02: Prefer const, enum, and inline to #define&lt;/h2&gt;
&lt;p&gt;1.除非我有一个很好的理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。&lt;br /&gt;
2.头文件里定义字符串常量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//或 char const * const str=&amp;quot;hello&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺第1个const，&lt;code&gt;warning： deprecated conversion from string constant to ‘char*’&lt;/code&gt; 
缺第2个const，如果两个源文件引用该头文件，会&lt;code&gt;multiple definition&lt;/code&gt;的错误&lt;br /&gt;
3.类关键字：&lt;br /&gt;
一般情况，只允许声明处出现一次：explicit,static,virtual,默认实参&lt;br /&gt;
特殊的2个，inline：出现在任一处都行，一般写在定义处；const：两处都要出现。&lt;br /&gt;
4.&lt;code&gt;#define&lt;/code&gt;宏定义完全可以被代替。const代替常量宏，template inline函数代替函数宏。&lt;br /&gt;
此外，static const可以定义类属常量，这是#define做不到的。&lt;br /&gt;
5.static const类属常量，如果是整数类型（char，short，int，bool等），可以在声明时直接赋值，只要不取地址都可以直接使用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果非整数类型（如double），如果需要取地址，如果编译器比较旧，需要在源文件中定义，给初值。&lt;br /&gt;
如果非要在编译时使用，编译器还不允许，可以使用enum hack的方法  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.需要一组常量的时候，可以使用枚举，用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;March&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;April&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//枚举类型可以被枚举值赋值&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Third&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//整数类型也可以被枚举值赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 03: Use const whenever possible&lt;/h2&gt;
&lt;p&gt;1.const可作用于任何作用域范围的对象、函数参数、函数返回类型、成员函数本身。&lt;br /&gt;
2.函数返回类型+const的意义，限制返回值再被赋值：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;防止  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过编译&lt;br /&gt;
3.将const作用于成员函数，保证该成员函数可以被const对象调用。&lt;br /&gt;
4.const成员函数可以"重载"非const成员函数。虽然const成员函数也可以被non-const对象调用，但是重载后，定义const和non-const对象，调用的同一个函数原型，效果就不一样了。如果返回引用类型或非内置类型，一个可以被赋值，一个不可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原理：&lt;br /&gt;
重载函数的确定，先找到candidate函数（名字相同），再找到viable函数（参数列表符合），再确定best match。&lt;br /&gt;
const成员函数内隐藏的this指针是&lt;code&gt;const type *&lt;/code&gt; 类型，而非const成员函数的则是&lt;code&gt;type *&lt;/code&gt; 。因此，const重载的实质是参数类型不同。&lt;br /&gt;
所以，非const对象优先调用非const函数（最佳匹配），没有的时候才调用const函数。&lt;br /&gt;
5.函数返回内置类型，不能做左值；函数返回自定义类型，或引用类型（内置或自定义），可以做左值。&lt;br /&gt;
6.被mutable声明的变量，即使在const成员函数内，也可以修改。这样可以实现概念上的const函数，而不是bitwise上的const函数。&lt;br /&gt;
举例：类里保存cache缓冲区的指针。每次调用length()函数读取cache缓冲区大小的时候，都要重新计算一下。
7.重复代码：编译时间、维护、代码臃肿问题。&lt;br /&gt;
在operator[]函数里调用const operator[]函数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;                      &lt;span class="c1"&gt;//C++中仅有这一种方式  &lt;/span&gt;
     &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;//也可以用const_cast代替,不转换成const对象会无限递归调用自己，段错误~  &lt;/span&gt;
     &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 04: Make sure that objects are initialized before they're used.&lt;/h2&gt;
&lt;p&gt;1.类成员变量中的自定义类型，在构造函数语句执行之前，已经调用过默认构造函数初始化自身了。所以，为了效率，应该使用初始化列表，然后构造函数语句体为空。代价（默认构造函数+赋值操作）&amp;gt;代价（1个构造函数）。&lt;br /&gt;
类成员变量中的内置类型，构造函数语句执行之前一般不会初始化，而且初始化和赋值效率相同，所以放在哪里一样。代价（1次初始化）=代价（1次赋值）。&lt;br /&gt;
2.内置类型为const或引用，必须初始化，不能赋值。&lt;br /&gt;
3.static对象，包括global对象，namespace作用域内对象，类内静态对象，函数内静态对象（local static对象）。&lt;br /&gt;
寿命：从运行中被构造出来，直到main()结束自动调用析构。&lt;br /&gt;
4.&lt;br /&gt;
原理：C++对定义于不同编译单元内的non-local static对象的初始化相对次序，没有明确定义。&lt;br /&gt;
导致的问题：先构造的对象，在构造函数中引用了后构造的对象，此时该对象还没有初始化。&lt;br /&gt;
解决：以函数调用（返回local static对象的引用），替代直接访问non-local static对象。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;getobj&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;C1&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++保证，函数内local static 对象会在该函数被调用期间，首次遇上该对象的定义式时被初始化。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Python学习笔记-subprocess模块</title><link href="http://particle128.com/posts/2013/10/py-subprocess.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/py-subprocess.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;subprocess是python的一个内置模块，用来产生子进程，和子进程通过pipe通信。&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;3个便捷函数&lt;/h3&gt;
&lt;p&gt;如果仅仅想要调用一个子进程完成一个任务，不需要父进程与其通信，并且等待子进程退出的话，选择便捷函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 返回returncode，0成功，非0出错。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。不同于`check_all`的唯一一点是，异常的output属性是子进程的输出，`check_all`引发的异常的output属性则是None。因为子进程的output被放到异常对象的output里，所以参数没有stdout。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;args是调用的命令和参数，可以是字符串，或字符串列表（带参数）。  &lt;/li&gt;
&lt;li&gt;是省略的一些关键字参数，不常用。  &lt;/li&gt;
&lt;li&gt;stdin,stdout,stderr是标准io，默认不重定向，可以给他们重定向到subprocess.PIPE，或文件对象（open函数的返回），或文件描述符。&lt;br /&gt;
注意：需要和子进程进行PIPE通信，不要用这三个函数。因为父进程在调用这三个函数的时候会阻塞，所以没法去都去PIPE里的信息或向管道传递信息。  &lt;/li&gt;
&lt;li&gt;shell设置为True的话，args指定的字符串将作为shell的参数，调用shell。  &lt;/li&gt;
&lt;li&gt;universal_newlines如果设置为True，那么stdout和stderr都会使用统一的换行符\n，而不区分操作系统。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Popen类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;preexec_fn&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_fds&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;startupinfo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;creationflags&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：&lt;br /&gt;
bufsize设置缓冲区大小，默认是0表示无缓冲，即每次write都直接执行io操作，而不是先放到缓冲区里，等待某个时机（换行符，或缓冲区满时才执行真正的io）&lt;br /&gt;
方法： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 检查进程是否中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 等待进程中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 和进程交互，发送数据到stdin，在stdout和stderr接收数据。前提是构造函数中对应io设置成PIPE  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# returns a tuple (stdoutdata, stderrdata)  &lt;/span&gt;
&lt;span class="c"&gt;# 发送信号给进程  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此外还有terminate（），kill（）函数&lt;br /&gt;
stdin，stdout，stderr，pid，returncode属性  &lt;/p&gt;</summary><category term="python"></category><category term="subprocess"></category></entry><entry><title>Python学习笔记-ConfigParser模块</title><link href="http://particle128.com/posts/2013/10/python-configparser.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/python-configparser.html</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;配置文件可以有很多种格式，windows下常用ini格式，网络上常用xml和json格式，分别可以调用的python模块如下：&lt;br /&gt;
ini——ConfigParser模块&lt;br /&gt;
xml——xml.etree.ElementTree模块&lt;br /&gt;
json——json模块  &lt;/p&gt;
&lt;h3&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/2/library/configparser.html"&gt;link&lt;/a&gt;&lt;br /&gt;
点评：&lt;br /&gt;
前面的文字讲的很晕，没有上下文的情况下就各种说，还不如直接来几个例子。不过我还是硬着头皮看完了。  &lt;/p&gt;
&lt;h3&gt;ini文档的格式&lt;/h3&gt;
&lt;p&gt;1.注释的开始标记是semicolon 和 number sign。semicolon开头的注释可以嵌入在ini文件的行内（和其他文本用一个空白符隔开），number sign开头的注释只能用在单独的一行中。&lt;br /&gt;
2.[section]中可以使用option=value或option: value&lt;br /&gt;
3.可以在value中包含格式化字符串，来自同section，或DEFAULT section，或初始化的时候传入的内容。&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;[My&lt;/span&gt; &lt;span class="err"&gt;Section]&lt;/span&gt;  
&lt;span class="err"&gt;foodir:&lt;/span&gt; &lt;span class="err"&gt;%(dir)s/whatever&lt;/span&gt;  
&lt;span class="na"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;frob  &lt;/span&gt;
&lt;span class="err"&gt;long:&lt;/span&gt; &lt;span class="err"&gt;this&lt;/span&gt; &lt;span class="err"&gt;value&lt;/span&gt; &lt;span class="err"&gt;continues&lt;/span&gt;  
   &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;the&lt;/span&gt; &lt;span class="err"&gt;next&lt;/span&gt; &lt;span class="err"&gt;line&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类层次关系&lt;/h3&gt;
&lt;p&gt;import ConfigParser&lt;br /&gt;
class ConfigParser.RawConfigParser([defaults[, dict_type[, allow_no_value]]])&lt;br /&gt;
——》ConfigParser （增加value中格式化字符串）&lt;br /&gt;
——》 SafeConfigParser（更加健全的格式化字符串）&lt;br /&gt;
符号——》表示派生出。  &lt;/p&gt;
&lt;h3&gt;成员方法&lt;/h3&gt;
&lt;p&gt;示例： config=ConfigParser.SafeConfigParser()&lt;br /&gt;
读写配置文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expanduser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;~/.myapp.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt; &lt;span class="c"&gt;#打开多个文件，忽略打开失败的文件，返回打开成功的文件列表  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readfp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="c"&gt;# 判断配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 读取配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;MySection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;带类型判断的变种，类型不对会抛出异常：&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getfloat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getboolean&lt;/span&gt;  
&lt;span class="n"&gt;sections&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#返回section列表  &lt;/span&gt;
&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回option列表  &lt;/span&gt;
&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回(option，value)列表  &lt;/span&gt;
&lt;span class="c"&gt;# 修改配置文件内容：  &lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;frob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;遇到的问题&lt;/h3&gt;
&lt;p&gt;问题：&lt;br /&gt;
配置文件中有一行 XL=10101。但是，get函数返回的option总是xl&lt;br /&gt;
原因：&lt;br /&gt;
&lt;a href="http://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser.optionxform"&gt;link&lt;/a&gt;&lt;br /&gt;
RawConfigParser有一个成员方法：optionxform(option)&lt;br /&gt;
Transforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures.The default implementation returns a lower-case version of option.&lt;br /&gt;
意思是，ConfigParser会自动调用optionxform函数，处理输入文件中的选项字段，或输出时指定的选项字段，默认是将其转变成小写。&lt;br /&gt;
文档中的解决方案是  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cfgparser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="o"&gt;...&lt;/span&gt;  
&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optionxform&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="c"&gt;#直接改成str，意味着不区分大小写。但是这对于含有中文option的配置文件并不合适。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#调用的时候转换成小写  &lt;/span&gt;
&lt;span class="n"&gt;new_url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;originUrl&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;?q=0|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TYPE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()],&lt;/span&gt;&lt;span class="n"&gt;EMPTY&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SORT&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="ConfigParser"></category><category term="python"></category></entry><entry><title>程序员的自我修养 笔记</title><link href="http://particle128.com/posts/2013/10/ziwoxiuyang.html" rel="alternate"></link><updated>2013-10-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/ziwoxiuyang.html</id><summary type="html">&lt;h2&gt;Chapter 2&lt;/h2&gt;
&lt;p&gt;所谓“编译”（gcc 1.cpp），实际上包括预处理，编译，汇编，链接。&lt;br /&gt;
gcc命令实际是后台程序的包装，包装了cc1预处理，as汇编，ld链接器&lt;br /&gt;
[1]预处理   主要处理预处理指令（#开头的），主要工作如下：&lt;br /&gt;
宏展开; 头文件插入 ; 删除注释 ； 添加行号和文件标识 。 &lt;br /&gt;
gcc -E 1.cpp -o 1.i             阅读.i文件，可以查看宏展开是否正确&lt;br /&gt;
[2]编译  把源文件生成汇编代码 (调用cc1)&lt;br /&gt;
gcc -S 1.i -o 1.s   或直接gcc -S 1.cpp -o 1.s&lt;br /&gt;
[3]汇编   把汇编代码转化成机器指令，即目标文件 (调用as)&lt;br /&gt;
gcc -c 1.s -o 1.o  或直接 gcc -c 1.cpp -o 1.o&lt;br /&gt;
[4]链接  把目标文件、库链接起来，生成可执行文件（调用ld）&lt;br /&gt;
gcc 1.o -o 1  或直接 gcc 1.cpp -o 1&lt;br /&gt;
简记：ESc   iso  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程&lt;/strong&gt;：&lt;br /&gt;
前端：跟机器无关&lt;br /&gt;
词法分析、语法分析、语义分析（给语法树的节点添加类型，主要工作是：声明和类型的匹配，类型的转换）、中间语言生成（包含优化，比如生成三地址码）&lt;br /&gt;
后端：跟机器有关&lt;br /&gt;
目标代码生成、优化  &lt;/p&gt;
&lt;h2&gt;Chapter 3       目标文件（统称）&lt;/h2&gt;
&lt;p&gt;[1] linux下目标文件和可执行文件的格式均为ELF格式。具体分类：&lt;br /&gt;
relocatable file：目标文件（.o）、静态链接库（.a）&lt;br /&gt;
executable file：可执行文件（无后缀）&lt;br /&gt;
shared object file：动态链接库（.so）&lt;br /&gt;
[2] ELF文件中数据和指令分别存放在不同的段里。原因如下：&lt;br /&gt;
（1）程序被装载后，数据和指令被映射到两个不同的虚存区域（一个可读写，一个只读），这样可以防止修改指令。&lt;br /&gt;
（2）现代cpu的cache分为指令缓存和数据缓存，提高cpu缓存命中率。&lt;br /&gt;
（3）系统中运行同一个程序的多个副本时，可以共享指令部分，但是数据部分必须一个副本拥有一份。&lt;br /&gt;
[3] 程序的指令部分放在.text段中，初始化的全局数据和局部i静态数据放在.data段中，未初始化的全局数据和局部静态数据放在.bss段中（虚拟的，不占用空间）。&lt;br /&gt;
[4] 查看目标文件中各种信息的方式：&lt;br /&gt;
objdump -h  显示各个段的基本信息&lt;br /&gt;
objdump -x  显示各个段的基本信息，显示符号表、重定位表的信息&lt;br /&gt;
objdump -s  将段的内容以16进制打印，   -d  显示指令段反汇编之后的汇编代码&lt;br /&gt;
readelf -h  查看ELF文件头 &lt;br /&gt;
readelf -S  查看段表（section header）&lt;br /&gt;
readelf -s  查看符号表&lt;br /&gt;
[5] 文件头&lt;br /&gt;
包含段表地址（相对于文件头）、段表大小、段表字符串表的索引（所有段从0开始编辑索引）&lt;br /&gt;
[5] 符号表&lt;br /&gt;
在链接中，函数和变量统称为符号（symbol），函数名和变量名就是符号名。&lt;br /&gt;
符号表中存在 定义在本目标文件中的全局符号(&lt;code&gt;global_var&lt;/code&gt;)，以及，在本目标文件中引用的全局符号(printf,&lt;code&gt;extern_var&lt;/code&gt;)。&lt;br /&gt;
[6] 字符串表（包括字符串表strtab和段表字符串表shstrtab）&lt;br /&gt;
表中就是一个接一个的存放字符串（以\0结尾），在符号表和段表中的某些需要用字符串来表示的信息（比如符号名、段名），是通过字符串在字符串表中的偏移来引用的。&lt;br /&gt;
[7] C++支持函数重载，即相同函数名的函数，可以根据参数列表（个数、类型）来区分。C++支持命名空间（类也属于），在不同命名空间可以有同样名字的符号。为了支持这一点，C++中的符号名（函数、全局变量）需要进行“名称修饰”，修饰后的名称叫“修饰后名称”（Decorated Name）。目标文件中的符号名即为修饰后名称。&lt;br /&gt;
&lt;code&gt;int N::C::func(int)&lt;/code&gt; 在gcc下的修饰后名称为&lt;code&gt;_ZN1N1C4funcEi&lt;/code&gt;，&lt;code&gt;_Z&lt;/code&gt;开头，N和E标识命名空间开始和结尾，i是参数&lt;br /&gt;
断开方式为：&lt;code&gt;_Z N 1N 1C 4func E i&lt;/code&gt;。数字标识后面的命名空间有几个字符。&lt;br /&gt;
在VC++下的修饰后名称为&lt;code&gt;?func@C@N@@AAEHH@Z&lt;/code&gt;。&lt;br /&gt;
函数返回的变量类型，并没有加入符号的修饰后名称中，所以，不能通过函数返回类型进行重载。&lt;br /&gt;
[8] C中没有名称修饰（name mangling）的概念，所有符号定义的名称（func）即为目标文件中的符号名称（func）。&lt;br /&gt;
C++中为了兼容使用C的库，头文件需要添加&lt;code&gt;extern "C" { void *memset(void*, int , size_t); }&lt;/code&gt;。&lt;br /&gt;
该关键字表明，后面的符号不使用“名称修饰”。这样，在C++中调用C的库memset可以正常使用，否则修饰后的名称和C语言库中未修饰的名称不一致，会提示链接错误。&lt;br /&gt;
[9] 强符号：函数、初始化的全局变量                 弱符号：未初始化的全局变量、用&lt;code&gt;__attribute__((weak))&lt;/code&gt;修饰的变量/函数&lt;br /&gt;
选择多次定义的全局符号    规则如下：&lt;br /&gt;
（1）不允许强符号多次定义&lt;br /&gt;
（2）多个文件中只有一个强符号，则选择强符号&lt;br /&gt;
（3）都是弱符号，选择空间最大的&lt;br /&gt;
[10] 强引用：默认             弱引用：用&lt;code&gt;__attribute__((weakref))&lt;/code&gt;修饰的引用&lt;br /&gt;
强引用的符号，链接时找不到，报链接错误;&lt;br /&gt;
弱引用的则不报错，使用地址0给那个未找到的符号赋值，运行时调用的话会出错。&lt;br /&gt;
[11] 调试信息在目标文件中占的空间（多了需要.debug开头的段），往往比代码和数据大的多，发布之前去除：strip  a.out  &lt;/p&gt;
&lt;h2&gt;Chapter4     静态链接&lt;/h2&gt;
&lt;p&gt;[1] .bss段在可执行文件中不占用空间，但是在装载后，要占用虚拟地址空间。&lt;br /&gt;
.bss段内的数据起初都是0,所以文件不必分配空间，但是运行中可能赋值，所以内存中需要空间。&lt;br /&gt;
[2] &lt;code&gt;ld a.o b.o -e main -o ab&lt;/code&gt;，-e参数表明main函数作为程序入口，否则ld链接器默认&lt;code&gt;_start&lt;/code&gt;作为入口。&lt;br /&gt;
[3] 链接两步：1.空间与地址的分配（合并目标文件[比如符号表合并成全局符号表]，分配虚拟地址）  2.符号解析与重定位（符号表中的und类型的符号在全局符号表中查找，修正代码中的地址）&lt;br /&gt;
第一步：链接之后，段表中各个段的属性VMA（Virtual Memory Address）被分配了虚拟内存地址。链接之前该属性均为0.链接之后，符号表中符号的value值变为虚拟内存地址。链接之前为想对于段的偏移。&lt;br /&gt;
第二步：链接之后，代码中的地址（外部函数和变量的引用）由默认值（0之类的）修正为实际的虚拟内存地址。&lt;br /&gt;
[4] 静态库，即目标文件的打包。ar -t libc.a可以查看包含的目标文件&lt;br /&gt;
链接库的过程：搜索库（xx.a）中所有目标文件（xx.o）的符号表，把被引用的符号存在的那个目标文件包含进可执行文件。如果被引用目标文件，还引用了其他目标文件的符号，再递归包含其他目标文件。&lt;br /&gt;
[5] 静态运行库libc.a里面一个目标文件只包含一个函数，比如printf.o，strlen.o等。&lt;br /&gt;
原因：链接器在链接静态库的时候，是以目标文件为单位的，引用了哪些目标文件中的符号（当然包括间接引用的符号），就链接哪些目标文件，库中其余的目标文件都丢弃。函数独立成目标文件，有利于减少目标文件的大小。  &lt;/p&gt;
&lt;h2&gt;Chapter7     动态链接&lt;/h2&gt;
&lt;p&gt;[1] dl好处：节省磁盘和内存空间（多个可执行文件都引用同一个模块的话，内存和磁盘上只需要保留一份）; 使软件更新之后发布更加方便（只下载并覆盖更新了的模块，而不是整个软件）。&lt;br /&gt;
[2] 动态链接，是把链接的过程推迟到了程序装载的时候，但是性能的损失不大，利远大于弊。&lt;br /&gt;
[3] &lt;code&gt;gcc -fPIC -shared -o xxx.so xxx.c&lt;/code&gt;  其中-shared表示共享对象，-fPIC（position independent code）表示地址无关代码，这是动态链接中的一种机制。&lt;br /&gt;
[4] &lt;code&gt;gcc -o -L/path/to/libyyy.so Program Program1.c ./xxx.so -lyyy&lt;/code&gt; &lt;br /&gt;
注意，动态链接库xxx.so，libyyy.so也要作为输入文件之一。这样链接器对Program1.c中引用的外部符号，就可以进行特殊处理，使它成为一个对动态符号的引用。否则ld会报错：未定义的引用。&lt;br /&gt;
gcc或ld，如果显示加上-static参数，-lyyy会查找libyyy.a，属于静态链接。ld如果使用-dynamic-linker参数（默认），-lyyy会查找最新版本的libyyy.so.x.y.z，属于动态链接。（静、动态链接查找目录包括：标准库目录，-L参数指定的目录，&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录）&lt;br /&gt;
注意：：但是编译动态库的时候，可以不加它所依赖的共享库，因为动态库不会直接执行。但是所有调用该动态库的程序，在编译的时候都要加上动态库所依赖的库。最标准的做法是，编译动态库的时候，也加上它所依赖的库。&lt;br /&gt;
[6] ldd xxx.so  查看共享对象的依赖&lt;br /&gt;
[7] 显式运行时链接，即调用动态链接器提供的api在程序中进行链接装载。好处是，减少程序的启动时间，支持插件的动态加载、删除和更新等。&lt;br /&gt;
api：dlopen（可以通过参数设置延迟绑定，当通过dlsym加载的函数第一次被使用时才进行绑定，而不是当模块被加载时就完成所有函数的绑定）,dlsym,dlclose,dlerror  &lt;/p&gt;
&lt;h2&gt;Chapter8    linux共享库的组织&lt;/h2&gt;
&lt;p&gt;[1] 共享库，动态链接库，共享对象，可以看作是同一个概念&lt;br /&gt;
[2] 版本命名：libname.so.x.y.z。&lt;br /&gt;
主版本号x表示库的重大升级，不同主版本号的库之间不兼容。&lt;br /&gt;
次版本号y表示库的增量升级，增加一些新的接口符号，但是原符号保持不变，向后兼容。&lt;br /&gt;
发布版本号z表示库的一些错误修正和性能改进，接口符号完全保持不变，互相兼容。&lt;br /&gt;
[3] Linux和Solaris系统中，采用SO-NAME的命名机制。每个共享库都对应一个SO-NAME，即共享库名去掉次版本和发表版本号之后的名字（xx.2.1.12 -&amp;gt; xx.2）。&lt;br /&gt;
共享库管理程序ldconfig，会自动在标准库目录（/usr/lib,/lib）和/etc/ld.so.conf配置文件中制定的目录（包括/usr/local/lib）下搜索，建立以"SO-NAME"为名的软链接，指向目录中主版本号相同、其他版本号最新的共享库。&lt;br /&gt;
当系统中安装或更新一个共享库时，需要运行ldconfig一下，以便更新"SO-NAME"的软链接，指向最新版本的共享库。&lt;br /&gt;
[4] 动态链接的模块所依赖的模块的路径保存在.dynamic段里面（编译的时候写入的，所以编译需要把共享库也作为输入文件）。.dynamic里如果保存的模块路径是绝对路径，动态链接器直接去加载即可。如果保存的是相对路径，依次搜索下面几个目录：&lt;br /&gt;
0)  传递给ld的参数-rpath指定的目录&lt;br /&gt;
1）&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录  &lt;br /&gt;
2）/etc/ld.so.cache指定的库路径（ldconfig执行的时候，除了建立SO-NAME软链接外，还在ld.so.cache中保存这些软链接的信息，方便动态链接器查找共享库）。（包括/usr/local/lib目录下的库）&lt;br /&gt;
3）/usr/lib，/lib。&lt;br /&gt;
[5] 环境变量&lt;code&gt;LD_PRELOAD&lt;/code&gt;里指定的文件会在动态链接器按照固定规则搜索共享库之前装载，无论程序是否依赖他们。由于“全局符号介入”机制，这里面的库中定义的符号，会让后来再加载的库中定义的同名符号失效。&lt;br /&gt;
[6] &lt;code&gt;gcc -W1,-soname,my_soname&lt;/code&gt;，-W1参数表示将指定参数传递给链接器。-soname参数指定共享库的SO-NAME，否则建立的共享库没有SO-NAME，ldconfig不会理睬这个库。  &lt;/p&gt;</summary><category term="link"></category><category term="load"></category></entry><entry><title>Effective C++学习笔记(10)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(10).html</id><summary type="html">&lt;h2&gt;Item 39: Use private inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.私有继承和复合(composition)意义相同：根据某物实现出（is-implemented-in-terms-of）。&lt;br /&gt;
2.除非必要，尽量用复合实现这种语义。&lt;br /&gt;
3.可以考虑使用private继承的情况：&lt;br /&gt;
（1）需要需要访问protected成员&lt;br /&gt;
（2）需要重写virtual函数。（替代策略:可以派生一个类，重写virtual函数。然后包含这个类的对象）&lt;br /&gt;
（3）如果需要包含的是一个空类对象，用private继承，节省空间。&lt;br /&gt;
Empty Class是指，只包含typedef，enum，statice成员变量和non-virtual函数的类。因为不含非静态成员变量和虚函数，所以一般不需要内存空间。&lt;br /&gt;
注：&lt;br /&gt;
1)类中包含一个空类对象的时候，大多数编译器至少需要1个字节的内存空间。&lt;br /&gt;
2)继承自空类对象，不需要任何内存空间。&lt;br /&gt;
4.尽量复用已有代码，所以平时注意积累自己的工具箱，设计的越通用越好，随时可以拿来复用。  &lt;/p&gt;
&lt;h2&gt;Item 40: Use multiple inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.多重继承尽量不用，因为它比单一继承复杂，比如引起二义性（ambiguity），还有可能需要虚继承（虚基类）&lt;br /&gt;
合理用途：&lt;br /&gt;
public继承一个接口类，private继承一个协助实现的类（需要复用它的一些成员，但是需要重写virtual）。&lt;br /&gt;
2.二义性例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base1:public&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base2:private&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="c1"&gt;//using Base1::checkOut;  //解决二义性的方法1  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

     &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
      &lt;span class="c1"&gt;//d.Base1::checkOut();  //解决二义性的方法2  &lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++首选确定对调用而言的最佳匹配（此处两个checkOut都是最佳匹配），之后才检查其可取用性。&lt;br /&gt;
所以，虽然private明显不能用，编译器还是返回错误：request for member 'checkOut' is ambigous。&lt;br /&gt;
解决：见程序注释。&lt;br /&gt;
3.钻石型多重继承，如果不希望最上层基类的成员在下层派生类中有多个副本，需要使用虚继承。&lt;br /&gt;
虚基类：所有派生自基类的类都采用virtual继承，该基类就被成为virtual base class&lt;br /&gt;
例子：STL中basic_ios ——&amp;gt;basic_istrem，basic_ostrem——&amp;gt;basic_iostrem&lt;br /&gt;
4.虚基类的初始化责任由继承体系的最底层（most derived）类负责。这样才可以避免虚基类被初始化多次。&lt;br /&gt;
5.虚继承有代价，所以一般不要用：虚继承的派生类占内存多，虚基类访问速度慢。&lt;br /&gt;
6.如果非要使用虚基类，尽量不要在里面放置数据，做一个接口类。类似与C#和Java中的Interfaces。  &lt;/p&gt;
&lt;h2&gt;Item 41: Understand implicit interfaces and compile-time-polymorphism&lt;/h2&gt;
&lt;p&gt;1.OOP的世界，显式接口（类的public接口，函数原型）和运行期多态 （virtual调用）。&lt;br /&gt;
Generic Programming，除了上面两者之外，还有隐式接口（typename需要支持的操作），和编译期多态（具现化）。&lt;br /&gt;
2.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;someWidget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;隐式接口是：w.size()&amp;gt;10 &amp;amp;&amp;amp; w!=someWidget返回bool类型。&lt;br /&gt;
可能w.size()返回数值型，或w有operator&amp;gt;成员，或opeartor&amp;gt;函数第一个参数接受T类型（或隐式转化成T类型），&lt;br /&gt;
可能operator&amp;amp;&amp;amp;被重载，返回一个bool类型。。。  &lt;/p&gt;
&lt;h2&gt;Item 42: Understand the two meaning of typename.&lt;/h2&gt;
&lt;p&gt;1.嵌套从属类型名称(nested dependent type name)需要在前面加typename，以表明它是类型名，否则编译器会假设它不是类型，而是一个变量。&lt;br /&gt;
举例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译期默认const_iterator是T中的静态变量，x可能全局变量之类的，它们做相乘。。。&lt;br /&gt;
声明其为类型：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//函数模版  &lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;Nested&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//类模版  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.两个特例不能加typename：&lt;br /&gt;
（1）继承的基类列表（base class list）&lt;br /&gt;
（2）构造函数成员初始化列表（member initialization list）  &lt;/p&gt;
&lt;h2&gt;Item 43: Know how to access names in templatized base classes&lt;/h2&gt;
&lt;p&gt;1.跟模版没关的一个话题：&lt;br /&gt;
当需要在派生类定义一个函数，是对基类函数的扩充，但是基类函数是non-virtual函数，这时候就用一个不同的名字。比如Base::sendClear()，Derived::sendClearMsg()&lt;br /&gt;
2.模版派生类，调用模版基类的函数时，不能不加任何修饰符的调用，因为编译期拒绝向模版基类的定义中寻找这个函数的声明。否则会在编译期"解析该模版类的定义式"时就报错。&lt;br /&gt;
原因：模版基类（templatized base class）可能存在特化版本，而这个特化版本中没有定义模版派生类要调用的那个函数。编译期在检查模版定义式的时候，没法确定具体是什么类型来具现化这个模版派生类。&lt;br /&gt;
解决：&lt;br /&gt;
（1）this-&amp;gt;修饰函数&lt;br /&gt;
（2）using Base&lt;T&gt;:: 引入相应名字&lt;br /&gt;
（3）Base&lt;T&gt;::修饰函数（最差的解决方法，因为会关闭virtual绑定行为）&lt;br /&gt;
3.编译器诊断模版相关的东西，分两个阶段&lt;br /&gt;
（1）解析模版的定义式。如上一条所列，可能报错。&lt;br /&gt;
（2）用实参具现化模版。如果this引入了基类的函数，但是基类相应特化版本的确不含有那个函数，这时候报错。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(11)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(11).html</id><summary type="html">&lt;h2&gt;Item 44: Factor parameter-independent code out of templates&lt;/h2&gt;
&lt;p&gt;1.类模版成员函数函数，只有被使用时才被具现化。类似类的合成版本的构造/复制构造/赋值操作符/析构函数。&lt;br /&gt;
2.模版的时候减少了源代码量，但是可能导致目标代码增加，因为每具现化一个版本，就多一份目标码。&lt;br /&gt;
策略：把与模版参数（类型参数或非类型参数）无关的代码，剥离出模版类。&lt;br /&gt;
（1）非类型参数&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SquareMatrix&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//方形矩阵  &lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化一次invert  &lt;/span&gt;
&lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化第二次invert，内容和第一次的代码重复了（只是把10换成5）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义一个不含有非类型参数的基类SquareMatrixBase，含有invert函数。SquareMatrix只要调用基类invert即可。这样上面的例子就会只有1个版本的invert（基类的invert函数）。&lt;br /&gt;
（2）类型参数&lt;br /&gt;
例如：大多数平台，所有指针类型都有相同的二进制表述，模版的类型参数是指针类型的（比如vector&lt;char*&gt;，vector&lt;Date*&gt;），其成员函数应该调用唯一一份底层实现（操作void*指针的函数）。  &lt;/p&gt;
&lt;h2&gt;Item 45: Use member function templates to accept all compatible types&lt;/h2&gt;
&lt;p&gt;1.以TR1::shared_ptr为例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//由“内置指针类型”构造，但是不能隐式转换，只能通过C-style类型转换或reinterpret_cast转换（尚未验证？？？）  &lt;/span&gt;
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
          &lt;span class="p"&gt;{...}&lt;/span&gt; &lt;span class="c1"&gt;//由“任意兼容类型的shared_ptr指针”构造，可以隐式转换。如果Y和U不兼容，成员初始化列表会报错  &lt;/span&gt;
         &lt;span class="c1"&gt;//赋值操作符也要定义成员函数模版，略  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本，而不是调用上面的构造函数模版  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本。  &lt;/span&gt;
         &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 46: Define non-member functions inside templates when type conversions are desired&lt;/h2&gt;
&lt;p&gt;1.希望函数所有实参接受隐式类型转换，需要定义成非成员函数；希望模版函数被自动具现化，需要声明在类内。所以需要友元函数，且定义在类内。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//需要实现这个  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="c1"&gt;//如果定义在类外的话，不能通过编译。因为“模版实参推导过程中不进行隐式类型转换”，所以int不会通过non-explicit构造函数，隐式转换成Ratioanl&amp;lt;int&amp;gt;，使模版函数operator*以int为实参具现出来。函数在类内则不同：oneHalf的定义，以int具现出来一个Rational类，编译器产生了该友元函数的声明，且该函数不是模版函数，所以接受隐式类型转换。  &lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//在类模版内，可以把Rational&amp;lt;T&amp;gt;（模版名+参数名）简写成Rational（模版名）   &lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;//如果实现在外面的话，会链接错误。  &lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.很多编译期强迫把所有模版的定义式放进头文件里，比如模版函数的实现。  &lt;/p&gt;
&lt;h2&gt;Item 47: Use traits classes for information about types&lt;/h2&gt;
&lt;p&gt;1.STL迭代器分类&lt;br /&gt;
（1）input：istream_iterator&lt;br /&gt;
（2）output：ostream_iterator&lt;br /&gt;
（3）forward：slist（单链表，STL不包含该结构）&lt;br /&gt;
（4）bidirectional：set，multiset，map，multimap，list（双向链表）&lt;br /&gt;
（5）random_access：vector，deque，string&lt;br /&gt;
2.typeid确定一个变量的类型是运行期行为，“重载函数的最佳匹配”相当于编译期的类型确定，而且有if-else功能。&lt;br /&gt;
3.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//定义类型  &lt;/span&gt;
     &lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//引用T定义的类型  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//对指针的特化版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//随即访问指针的重载版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数不需要形参，因为没有用到  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数传入一个未命名对象，类型后跟一对括号  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 48: Be aware of template metaprogramming&lt;/h2&gt;
&lt;p&gt;1.TMP的主要意义：（1）完成一些其他方法没法实现的功能（2）将运行期的工作转移到编译期，可以提高程序执行效率。&lt;br /&gt;
2.##Item47中提到的do_advance方法，就是模版元编程里的if-else用法。用typeid没法实现（非random access iterator 没法编译通过iter+=d这句话）。&lt;br /&gt;
3.循环的用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//变量在enum里，递归调用自身  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//循环结束条件：特化模版  &lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//使用：  &lt;/span&gt;
&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(12)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(12).html</id><summary type="html">&lt;p&gt;关于new和delete的东西，笔记不够详尽，因为新知识比较多，不太方便记录笔记。发现相关知识漏洞的时候，再去查看Cpp Primer和Effective Cpp相关章节。  &lt;/p&gt;
&lt;h2&gt;Item 49: Understand the behavior of the new-handler&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;std::set_new_handler()&lt;/code&gt;可以绑定一个&lt;code&gt;new_handler&lt;/code&gt;（类型为&lt;code&gt;void (*)()&lt;/code&gt;），即new获取不到所需内存时调用的客户定制函数。如果不设置函数，或设置null，直接抛出异常&lt;code&gt;std::bad_alloc&lt;/code&gt;。&lt;br /&gt;
2.获取&lt;code&gt;new_handler&lt;/code&gt;函数的方式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.new_handler应该具备以下一种功能：&lt;br /&gt;
（1）让更多内存可被使用。否则::operator new会无限循环调用非空的new_handler。例如程序开始分配一个内存池，动态分配不到资源的时候释放一些资源出来。&lt;br /&gt;
（2）安装另一个可以释放更多内存的new_handler函数。&lt;br /&gt;
（3）卸除new_handler，这样::operator new就会直接throw std::bad_alloc()异常了。&lt;br /&gt;
（4）抛出bad_alloc异常。不等operator new抛，自己就抛了。&lt;br /&gt;
（5）调用exit或abort直接退出程序。  &lt;/p&gt;
&lt;h2&gt;Item 50: Understand when it makes sense to replace new and delete&lt;/h2&gt;
&lt;p&gt;重写operator new和operator delete的原因：&lt;br /&gt;
（1）检查所分配内存上的运用错误：每次new的时候，在要分配空间的前后多分配一段内存，存放签名。delete的时候检查签名是否正确。如果前面的签名错了，发生了underrun（数据写到分配内存的前面了）；如果后面的签名错了，发生了overrun（ditto）。&lt;br /&gt;
（2）收集动态分配内存的使用情况：每次new的时候都要统计一些信息，比如分配了多少，等等&lt;br /&gt;
（3）加快速度：定制版本处理的情况比通用版本少，所以速度往往更快。&lt;br /&gt;
（4）降低空间开销：通用版本往往会分配额外一些内存来保存一些信息。小型对象分配器：Boost的Pool&lt;br /&gt;
（5）弥补缺省allocator非最佳齐位（alignment）：好多编译器上的new都声称保证16bit齐位，double变量需要32bit齐位，才能获得最佳的访问速度。&lt;br /&gt;
（6）获得非传统的行为：比如delete释放的时候，空间覆盖为0.  &lt;/p&gt;
&lt;h2&gt;Item 51:Adhere to convention when writing new and deletes(固守常规)&lt;/h2&gt;
&lt;p&gt;1.自定义operator new的时候，需要注意的几点&lt;br /&gt;
（1）尽量和::operator new行为一致，即while(true)下循环尝试分配内存，如果new_handle非0就调用，否则bad_alloc&lt;br /&gt;
（2）用户分配大小为0的空间  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator new的参数  &lt;/span&gt;
     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）基类的operator new，需要首先执行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//如果new派生类的话，使用全局版本的operator new  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.自定义operator delete的时候，需要注意的几点&lt;br /&gt;
（1）用户delete一个空指针  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//ptr是operator delete的参数  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）基类的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator delete的第二个参数  &lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 52: Write placement delete if you write placement new.&lt;/h2&gt;
&lt;p&gt;1.placement new，C++ Primer上翻译为定位new，理解为：特定位置（第二个参数指定的指针位置）上的new比较好。&lt;br /&gt;
2.编写placement new的时候，也要编写对应版本的placement delete。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则，可能内存泄露。&lt;br /&gt;
因为，new表达式执行中，如果第一步operator new分配内存成功，但是构造函数抛出异常，C++运行期系统需要保证内存不发生泄露，就会自动调用&lt;strong&gt;对应版本&lt;/strong&gt;的operator delete释放内存。如果找不到对应版本的operator delete，就会造成内存泄露。&lt;br /&gt;
3.global作用域定义了3种形式的operator new和对应3种形式的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;nothrow_t&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应delete版本就是第一个参数换成void*，全部不抛出异常。&lt;br /&gt;
4.定义于类内的operator new，不管是placement还是非placement，都会掩盖全局的3个版本。如果需要使用，重写这6个函数：函数体只是调用全局作用域的版本。&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：&lt;strong&gt;不能在类内简单的using ::operator new，否则报错using-declaration for non-member at class scope。&lt;/strong&gt;只能using基类的被覆盖的名字，不能using全局的，但是可以用作用域限定符(::)调用全局的函数。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(8)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(8).html</id><summary type="html">&lt;h2&gt;Item 30: Understand the ins and outs of inlining.&lt;/h2&gt;
&lt;p&gt;1.inline（函数体代替函数调用）的好处：&lt;br /&gt;
（1）没有函数调用的开销，速度快。&lt;br /&gt;
（2）使编译器能对起进行outlined的函数所不具备的优化，因为上下文更明显了。&lt;br /&gt;
坏处：&lt;br /&gt;
（1）可能导致代码膨胀，如果inline函数内语句比较多的话。&lt;br /&gt;
（2）如果inline函数是程序库的一部分，对它的改动，需要使用者重新编译。（outline的话，直接链接即可，动态链接的话，使用者甚至不知道函数库的修改）&lt;br /&gt;
（3）大部分调试器不能调试inline函数。&lt;br /&gt;
2.inline是对编译器的申请，不是强制。&lt;br /&gt;
如下情况编译器”可能“拒绝inline（gcc -Winline会发出不能inline的警告，但是我尝试了递归和循环，没有发出警告）：&lt;br /&gt;
（1）函数太过复杂（包含递归或循环）。&lt;br /&gt;
（2）函数中调用virtual函数，因为多态是运行期行为，而inline是编译期行为。&lt;br /&gt;
如下情况提供outline版本：&lt;br /&gt;
（1）通过函数指针调用inline函数。因为如果inline函数没有outline版本的话，就没有函数地址了。&lt;br /&gt;
3.除了显示inline，类成员函数和友元函数定义与class内，也是inline函数&lt;br /&gt;
4.inline函数的函数体，通常应定义于头文件内，保证编译时可以用函数体替换函数调用。因为大多数C++编译器实现中，inling行为是编译行为。&lt;br /&gt;
5.构造和析构不适合inline。因为里面有编译器加入的代码（比如构造数据成员，出错就析构之前构造的成员），往往代码量不小，导致代码膨胀。  &lt;/p&gt;
&lt;h2&gt;Item 31: Minimize compilation dependencies between files.&lt;/h2&gt;
&lt;p&gt;1.降低文件间的编译依赖性（低耦合）的好处：&lt;br /&gt;
实现有所改变的时候，如果接口（类的public成员）没有改变，那么客户代码不用重新编译。&lt;br /&gt;
2.C++中类的定义，并没有“将接口从实现中分离”做的很好。因为类定义中，私有成员也会出现在头文件中。&lt;br /&gt;
类定义的头文件中仅仅包括前置声明（class Date;），然后在源文件中定义（Date Person::theBirthDate;）是行不通的。因为编译时，需要知道一个类型占据多大的内存，而编译器不会去查看源文件中的具体实现，仅仅查看头文件的类定义，所以必须在类定义中出现。&lt;br /&gt;
3.编译依赖性比较大的例子：&lt;br /&gt;
（0）具象类（concrete class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Date.h&amp;quot; &lt;/span&gt;&lt;span class="c1"&gt;//引入类型定义式  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Address.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;theName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;theBirthDate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="n"&gt;theAddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：Date或Address的修改，Person需要重新编译，继而Person的客户也要重新编译。Person实现的修改（比如增加或减少了成员变量），Person客户要重新编译，即使接口没有改变。&lt;br /&gt;
两种解决办法：&lt;br /&gt;
（1）句柄类（handle class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：大部分都是前置声明  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//实现细节隔离到了PersonImpl中，所以PersonImpl的实现改变后，不影响Person的客户  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//类型声明式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//使用对象的指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：需要引入一些头文件中的类型定义  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Person.h&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;PersonImpl&amp;quot;   &lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)){}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只靠"类型声明式"(class Date)就可以定义该类型的引用或指针；必须提供"类型定义式"(#include "Date.h")才可以定义该类型的对象。  &lt;/li&gt;
&lt;li&gt;声明一个函数，如果函数的参数或返回值是某自定义类型的（比如Date），只包含其类型声明式即可（class Date）。  &lt;/li&gt;
&lt;li&gt;程序库作者应该提供两种头文件：类型声明式(datefwd.h)和类型定义式(Date.h)。客户在声明包含该类型的函数时，只需包含datefwd.h即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）接口类（interface class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//抽象类   &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//全部是纯虚函数  &lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//工厂函数，返回智能指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;RealPerson.h&amp;quot;  &lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RealPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较（个人观点）：&lt;br /&gt;
（1）易用性&lt;br /&gt;
handle class更易用： Person p1(...); string name=p1.getName()&lt;br /&gt;
interface class不好用：std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(...)); string name=pp-&amp;gt;getName();&lt;br /&gt;
（2）扩展性&lt;br /&gt;
handle class没法扩展。&lt;br /&gt;
interface class方便扩展，基类可以有多个相同接口的派生类。比如create中增加一个参数，可以选择create哪个派生类。&lt;br /&gt;
4.句柄和接口类，会速度降低、内存消耗增大，但是的确可以带来松耦合的好处。&lt;br /&gt;
原则：开发过程中，用句柄和接口类；当它们导致的性能损失比较严重时，改成具象类。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(9)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(9).html</id><summary type="html">&lt;h2&gt;Item 32: Make sure public inheritance models "is-a"&lt;/h2&gt;
&lt;p&gt;1.C++OOP最重要的规则是：公有继承模型，建模的是‘is-a’关系，基类有的特性派生类一定具有。&lt;br /&gt;
2.没有通用的设计，有些地方看似很合理的设计，在一些情形下却不能使用：&lt;br /&gt;
企鹅是鸟，但是鸟可以飞；正方形是矩形，但是矩形可以在不改变宽的情况下修改高&lt;br /&gt;
3.修改”企鹅-&amp;gt;鸟“设计：&lt;br /&gt;
（1）class Bird; class Penguin :public Bird; class FlyingBird: public Bird; //在Bird里不定义fly()，在FlyingBird里定义&lt;br /&gt;
（2）class Bird; class Penguin :public Bird; //在Bird里定义fly()，但是在Penguin里实现fly()中导出一个错误。&lt;br /&gt;
比较：前者更优，编译期错误。  &lt;/p&gt;
&lt;h2&gt;Item 33: Avoid hiding inherited names.&lt;/h2&gt;
&lt;p&gt;1.派生类中的名字，会掩盖基类中的名字。即使派生类中的函数和基类的函数参数列表不同，不论函数是non-virtual或virtual或pure-virtual的，派生类对象也无法调用基类被掩盖的函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//错误！！！  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的目的，是防止派生类从遥远的基类中继承它并不清楚的同名重载函数。&lt;br /&gt;
2.一般公有继承，都要继承父类的所有成员，所以采取两种办法可以解决掩盖，实现重载：&lt;br /&gt;
（1）using声明式  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//引入base的所有func的名字，如果func函数包括多个重载版本，都引入派生类作用域  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）forwarding function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//之所以private inheritance，是因为公有继承的设计原则就是派生类拥有基类的一切特征  &lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;  
         &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt; &lt;span class="c1"&gt;//只引入base中的一个版本的func(int)，一般设计成inline，毕竟就一句。  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 34: Differentiate between inheritance of interface and inheritance of implementation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;class设计者，将接口函数设计成不同类型，就会限制派生类的行为：&lt;br /&gt;
（1）纯虚函数——&amp;gt;接口继承，希望只继承其接口。&lt;br /&gt;
注：纯虚函数也可以实现（在源文件中），除非要提供默认的行为供子类调用(Base::fly();)，否则一般不实现。&lt;br /&gt;
（2）虚函数——&amp;gt;接口和实现继承，提供默认实现，允许覆盖继承的实现。&lt;br /&gt;
派生类不重新定义，就默认使用的基类的版本；派生类重新定义，就可以实现多态。&lt;br /&gt;
（3）非虚函数——&amp;gt;接口和实现继承，不希望被覆盖。&lt;br /&gt;
非虚函数，应该在派生类和基类中有一致的行为，所以不应该被覆盖（名字掩盖的话，就using进来基类的名字）。&lt;br /&gt;
如果想覆盖基类，就把基类的函数定义成virtual。&lt;br /&gt;
2.任何类如果打算作为基类，都要拥有若干virtual函数（至少析构函数）。&lt;br /&gt;
3.任何函数如果不变性（invariant）大于特异性（specialization），就应该被定义成基类的非虚函数，不让子类覆盖（虽然遵守与否看子类守不守规矩）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 35: Consider alternatives to virtual functions.&lt;/h2&gt;
&lt;p&gt;正如上一个item所讲，虚函数的目的：提供默认实现，允许派生类覆盖。&lt;br /&gt;
public virtual的可选替代方案如下，实现了上面的两个目的：&lt;br /&gt;
（1）Template Method模式：NVI（non-virtual interface）手法&lt;br /&gt;
基类定义non-virtual函数healthValue()，调用private/protected virtual函数doHealthValue（每个派生类可以包含各自的实现）。&lt;br /&gt;
因为healthValue()有隐式this指针参数，所以根据调用对象的类型，可以执行不同类中定义的doHealthValue。&lt;br /&gt;
优点：避免代码重复。&lt;br /&gt;
healthValue函数，在调用doHealthValue的前面做一些准备工作（锁），在后面做一些清理工作。如果用public virtual的方法，每个派生类的函数都要有重复的准备和清理代码。&lt;br /&gt;
缺点：增加一个函数调用的开销。&lt;br /&gt;
（2）Strategy模式：非成员函数指针&lt;br /&gt;
基类有函数指针成员（healthFunc），构造函数中传入函数指针，比如int (*)(const GameCharacter&amp;amp;)，默认实参是一个缺省函数的指针。&lt;br /&gt;
优点：同一类型不同对象，可以有不同health函数；同一对象的行为也可以在运行时改变（提供setHealth函数）&lt;br /&gt;
缺点：非成员函数只能访问public成员，除非降低封装性，将其定义为友元函数，或private成员提供public访问方法。 &lt;br /&gt;
（3）Strategy模式：tr1::function&lt;br /&gt;
typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;&lt;br /&gt;
同上，但是支持函数指针、函数对象，和成员函数，且不需要函数完全匹配，兼容（参数和返回类型可以隐式转换）即可。&lt;br /&gt;
（4）Strategy模式：对象指针&lt;br /&gt;
类中包含，指向另一个继承体系的对象（包含一个healthFunc的函数）的指针，构造的时候传入。  &lt;/p&gt;
&lt;h2&gt;Item37: Never redefine a function's inherited default parameter values.&lt;/h2&gt;
&lt;p&gt;1.虚函数是dynamically bound，而默认参数statically bound。所以通过基类指针或引用访问派生类对象的成员函数，使用的基类的默认参数，和派生类的具体实现。&lt;br /&gt;
2.仅仅改变默认实参，不够成重载&lt;br /&gt;
3.派生类和基类中声明同样的默认参数，遵循默认参数不变的原则。但是代码重复，且有相依性（with dependencies），意味着一处修改就要多处修改。PS：貌似重复的代码大多都有相依性，所以杜绝复制粘贴，避免重复。&lt;br /&gt;
解决办法：NVI，仅在 base's non-virtual function上声明默认参数。  &lt;/p&gt;
&lt;h2&gt;Item 38: Model 'has-a' or 'is-implemented-in-terms-of' through composition.&lt;/h2&gt;
&lt;p&gt;1.复合(composition)还有一些同义词（synonym）：内含（containment），聚合（aggregation），内嵌（embedding）&lt;br /&gt;
2.复合，即对象包含在对象里面的情况。塑模两种情况&lt;br /&gt;
（1）has-a（包含）关系：应用域，比如人包含名字、地址&lt;br /&gt;
（2）is-implemented-in-terms-of（根据某物实现出）关系：实现域，比如set是根据linked list实现出的。&lt;br /&gt;
3.区分is-a和is-implemented-in-terms-of：&lt;br /&gt;
is-a的话，对基类为真的每一件事，对派生类也为真。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(7)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html" rel="alternate"></link><updated>2013-10-12T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-12:posts/2013/10/EffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 26: Postpone variable definitions as long as possible.&lt;/h2&gt;
&lt;p&gt;1.延后变量定义的意义是，有可能变量定义后，出现异常导致变量用不到，这样变量的构造和析构函数就白费了。所以，只在使用这个变量的代码之前定义它。&lt;br /&gt;
2.循环内变量的使用，是个特殊情况。但是仍然鼓励在循环内，变量使用前才定义变量。除非满足下面两点&lt;br /&gt;
(1)赋值成本比构造+析构成本低 (2)该段代码是效率敏感（performance-sensitive）的部分&lt;br /&gt;
因为：缩小变量的作用域，对于程序的可理解性和易维护性好。  &lt;/p&gt;
&lt;h2&gt;Item 27:Minimizing casting&lt;/h2&gt;
&lt;p&gt;1.C++风格类型转换中，&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;(expr)&lt;/code&gt;是唯一一个无法用旧式语法（C风格，函数风格）执行的动作，用来将基类的指针或引用转化为子类的指针或引用。&lt;br /&gt;
2.能用C++风格转型，就不用旧式语法。因为它们容易在代码中被辨识出来，因为简化了"找出类型系统在哪个地点被破坏"的过程。&lt;br /&gt;
3.显示构造：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//func的调用方式，包括3种强制类型转换的方式：  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle函数式类型转换，也理解为构造一个临时的Widget对象&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle标准类型转换  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//C++style类型转换  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.单一对象可能有一个以上的地址。Base&lt;em&gt;指向它和Derived&lt;/em&gt;指向它时的地址可能不同，这依赖于编译器将C++的对象如何布局。&lt;br /&gt;
而且，一旦多重继承，多个基类的指针指向同一个对象，地址一定是不一样的。&lt;br /&gt;
5.以上例子表明，类型转换并不仅仅是让编译器把某种类型视为另一种类型，其他什么也没做。&lt;br /&gt;
6.派生类虚函数中调用基类的版本，错误做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用onResize的不是this的base部分，而是强制类型转换所建立的临时对象  &lt;/span&gt;
&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//因为是虚函数，且是基类的引用，会调用自己，无穷递归。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WIndow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.应该尽量避免dynamic_cast，因为很多实现版本效率很低（比如调用多个strcmp，逐层比较class name）。&lt;br /&gt;
办法是，让父类定义空virtual函数，运用多态自动调用派生类的相应函数。&lt;br /&gt;
8.来自Cpp Primer：&lt;br /&gt;
dynamic_cast（成功返回相应指针或引用，失败返回NULL或抛出异常）：处理含有virtual函数的基类引用或指针，返回动态类型。&lt;br /&gt;
typeid（返回type_info对象，支持相等比较运算和name()方法）：处理含有virtual函数的基类，返回动态类型。  &lt;/p&gt;
&lt;h2&gt;Item 28:Avoid returning handles to object internals&lt;/h2&gt;
&lt;p&gt;1.以下句子编译可以通过，但是是错误的，因为这样的话外部就可以修改内部数据了，与const矛盾了。这是因为const成员函数实现的是bitwise const，而不是logical const  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="c1"&gt;//修改成：  &lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.引用、指针和迭代器都是所谓的handle，返回一个指向内部数据的handle，降低封装性，而且可能导致悬垂handle（即handle所指向的对象被销毁了，因为handle生存期可能比对象长）。&lt;br /&gt;
因此，尽量避免返回指向内部对象的handle，除非像string和vector的operator[]方法，不得不做的时候。  &lt;/p&gt;
&lt;h2&gt;Item 29: Strive for exception-safe code.&lt;/h2&gt;
&lt;p&gt;错误例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1.“异常安全”两个条件：&lt;br /&gt;
（1）不泄露任何资源&lt;br /&gt;
（2）不允许数据败坏&lt;br /&gt;
例子中，如果new出错（时刻注意，new分配内存的时候可能因为内存不足而抛出异常），mutex资源泄露，bgImage指针悬空。&lt;br /&gt;
“异常安全的函数”满足两个条件后，还分3个等级：&lt;br /&gt;
（1）基本承诺，即保证：任何事物在有效状态下，只是调用者不确切知道处于哪种状态。&lt;br /&gt;
（2）强烈保证，即保证：函数成功就完全成功；失败，就回到调用前的状态。&lt;br /&gt;
（3）不抛异常保证，即保证：只成功不失败，不抛出异常。&lt;br /&gt;
2.不抛出异常：只能靠程序保证。如下声明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只是告诉调用者，不打算抛出异常。但是“完全可能”抛出异常，那时候会有一个函数被调用（std::set_unexpected函数的参数绑定的异常处理函数，该函数会在抛出非声明的类型的异常时执行）。&lt;br /&gt;
3.强烈保证：&lt;br /&gt;
变换语句顺序有时候可以做到；copy-and-swap一般可以做到。&lt;br /&gt;
（1）变换语句顺序：delete 和 ++放到new后面。当然用对象管理资源更安全和简洁  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;ml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//reset的过程中，原image会delete  &lt;/span&gt;
     &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c1"&gt;//函数退出后，Lock析构会释放mutex  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）copy-and-swap：把打算修改的对象复制一份，然后修改副本，再把副本和原对象交换。&lt;br /&gt;
4.尽量让函数等级更高，但是不抛出异常很难保证，因为很多库函数都可能抛出异常；强烈保证可能耗费很大的代价，比如copy and swap方法，复制构造和赋值操作的代价。&lt;br /&gt;
权衡的过程：tradeoff。&lt;br /&gt;
但是，要在文档上说明清楚可能抛出的异常等，以及为什么没有实现安全级别更高的代码。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(5)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html" rel="alternate"></link><updated>2013-10-11T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-11:posts/2013/10/EffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item18:  Make interfaces easy to use correctly and hard to use incorrectly&lt;/h2&gt;
&lt;p&gt;1.促进接口被正确使用：&lt;br /&gt;
（1）接口一致性：stl中所有容器都具有size() 函数，而不像Java和.Net。&lt;br /&gt;
（2）与内置类型行为兼容：想想和int类比。&lt;br /&gt;
2.阻止接口被误用（！！！不正确的行为，编译都不能通过）：&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）建立新类型，防止调用顺序错乱，比如(2013,1,10)。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//定义Month,Day,Year类型（struct，只含一个val变量和一个explicit单个参数构造函数即可）  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）束缚对象值，防止无意义的值，比如(Month(13),Day(1),Year(2013))。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Date类中私有化构造函数。  &lt;/span&gt;
&lt;span class="c1"&gt;//只提供一系列静态函数供调用。static Month Jan() {return Month(1);}  &lt;/span&gt;
&lt;span class="c1"&gt;//不能定义static Month Jan(1);因为 非局部静态对象的初始化顺序未定义，万一d是全局的对象，构造时可能Jan对象尚未初始化。  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）消除对象的资源管理责任，防止忘记释放资源。&lt;br /&gt;
//提供智能指针对象，而不是原始资源&lt;br /&gt;
总结：C++中为了保证接口不被误用，可能会增加很多C语言程序员看起来感觉冗余的代码，比如增加Month，Day，Year 3个类，比如定义Month::Jan()等静态函数。但是的确起到了C语言没法起到的作用：&lt;br /&gt;
（1）没法，只能认真看接口原型。&lt;br /&gt;
（2）可以通过函数内语句判断合法性，但是就将错误推迟到了运行时。&lt;br /&gt;
（3）没法，只能提醒自己释放。  &lt;/p&gt;
&lt;h2&gt;Item19: Treat class design as type design&lt;/h2&gt;
&lt;p&gt;1.应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研究class的设计。&lt;br /&gt;
2.允许T1类型被隐式转换成T2类型：&lt;br /&gt;
（1）T1类内定义operator T2()函数。&lt;br /&gt;
（2）T2含有非explicit的构造函数，且函数参数只有一个T1类型的对象。&lt;br /&gt;
3.设计类时遵循的准则略，需要设计类时查阅该书。  &lt;/p&gt;
&lt;h2&gt;Item20: Prefer pass-by-reference-to-const to pass-by-value&lt;/h2&gt;
&lt;p&gt;1.传递对象的引用，好处：&lt;br /&gt;
（1）效率高。值传递会调用参数的复制构造函数（同时调用其基类和成员变量的复制构造函数），函数退出时还要调用它们的析构函数。&lt;br /&gt;
（2）易于优化。常量引用的实现是指针，编译器通常更愿意将其放入缓存器。即使class尽含有一个double变量，编译器也不视其为内置类型，拒绝将其放入缓存器。&lt;br /&gt;
2.传递“常量”引用，好处：&lt;br /&gt;
（1）调用者不必担心传入的实参被改变。&lt;br /&gt;
（2）const或non-const对象都可以传入，适用范围更广。&lt;br /&gt;
3.小型自定义类型也不要值传递，原因：&lt;br /&gt;
（1）复制构造函数不一定小型（比如可能要deep-copy）。&lt;br /&gt;
（2）不易于被编译器优化，放入缓存器。&lt;br /&gt;
（3）该自定义类型可能在之后的更新中，体积变大。&lt;br /&gt;
4.不适合引用传递的情况：&lt;br /&gt;
（1）内置类型：效率更高，见下图&lt;br /&gt;
&lt;img alt="ec5" src="http://particle128.com/images/ec5.png" /&gt;
（2）STL迭代器：类似指针，STL会保证其复制构造效率高，习惯值传递&lt;br /&gt;
（3）函数对象：实质是指针  &lt;/p&gt;
&lt;h2&gt;Item21: Don't try to return a reference when you must return an object.&lt;/h2&gt;
&lt;p&gt;函数返回对象的时候，也会执行一次构造和析构函数。为了减少这次的构造和析构，可能考虑返回引用。问题：&lt;br /&gt;
（1）指向局部变量：显而易见不行。&lt;br /&gt;
（2）指向动态分配的堆上的对象：内存泄露。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//两个new出来的对象都没有办法释放，因为接触不到new出的指针。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）指向静态变量：多线程问题，还有语义上瑕疵。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;//总是返回true，因为返回的都是同一个static对象  &lt;/span&gt;
&lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(6)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(6).html" rel="alternate"></link><updated>2013-10-10T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-10:posts/2013/10/EffectiveCpp(6).html</id><summary type="html">&lt;h2&gt;Item 22: Declare data members private&lt;/h2&gt;
&lt;p&gt;1.把变量声明成private，然后通过public函数访问。好处：&lt;br /&gt;
（1）语法一致性。public里都是函数，不用考虑是否需要加括号。&lt;br /&gt;
（2）更精确的访问控制。可以通过get和set设置变量的可都写属性。&lt;br /&gt;
（3）封装。对底层的机制提供很大的弹性，成员变量的修改，不影响客户的使用。（比如averageSoFar()函数，可以返回average变量，也可以直接计算平均值再返回。一个占空间，一个费时间，在不同环境可以选择不同的实现）&lt;br /&gt;
2.只有private有封装性，protected和public都没有封装性。&lt;br /&gt;
因为封装性与“当其内容改变时可能造成的代码破坏量”成反比，内容改变可以理解成把它从class中移除。&lt;br /&gt;
（1）public变量移除，所有使用它的客户代码都会破坏。&lt;br /&gt;
（2）protected变量移除，所有继承自该类的派生类都会破坏。  &lt;/p&gt;
&lt;h2&gt;Item 23: Prefer non-member non-friend functions to member functions.&lt;/h2&gt;
&lt;p&gt;1.正如上一个条款所述，越多代码可以访问一个数据，数据的封装性就越差。因为越多代码访问它，它改变时造成的破坏越大，导致数据的实现弹性变小。&lt;br /&gt;
2.成员函数，友元函数可以访问类内的private成员，enum和typedef等，而非成员函数都不能访问。所以，使用非成员函数，类内私有数据的封装性更好。&lt;br /&gt;
所以，对于只"调用一个类的public成员的函数"，让其在该类的同名命名空间（可以同该类的定义不在一个文件内）下，作为非成员函数较好。&lt;br /&gt;
3.标准库STL的组织方式：namespace std跨越多个文件，需要使用的机能只要添加相应的头文件（比如#include &lt;vector&gt;）即可。  &lt;/p&gt;
&lt;h2&gt;Item 24: Declare non-member functions when type conversions should apply to all parameters&lt;/h2&gt;
&lt;p&gt;隐式类型转换，只能作用在参数上，所以成员函数的调用者（*this）作为调用者不能转换。&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//支持以下操作：  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//explicit构造函数不具备的  &lt;/span&gt;
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt; &lt;span class="c1"&gt;//operator*作为成员函数不具备的  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 25: Consider support for a non-throwing swap.&lt;/h2&gt;
&lt;p&gt;1.关于修改std：&lt;br /&gt;
不能修改std命令空间内的任何东西，也不能添加新的函数、类或模版等新的东西到std内，std的内容由C++标准委员会决定。&lt;br /&gt;
虽然添加东西进std仍可以编译和执行，但是行为没有明确定义。所以要杜绝。&lt;br /&gt;
唯一可以在std内做的事情是:全特化std命名空间下已存在的模版。不能偏特化，因为偏特化相当于在std内增加模版。&lt;br /&gt;
2.类模版可以偏特化(partially specialize)或全特化(totally specialize)；函数模版只能全特化。&lt;br /&gt;
偏特化指的是只特化一部分模版参数，而不是全部。&lt;br /&gt;
3.std内有一个swap模版函数，实现如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用1次拷贝构造，两次赋值操作符。&lt;br /&gt;
对于一种类型的对象而言，这个swap函数代价太大：对象内含指针，指针指向真正存放数据的对象(pimpl技术)。&lt;br /&gt;
因为对这类对象而言，交换指针即可。但是其实现必须保证复制构造和赋值操作符都是深复制（当然也可以用智能指针代替，这里不考虑），所以直接在Widget上调用swap会非常低效。&lt;br /&gt;
例如：&lt;br /&gt;
WidgetImpl类：int a,b,c; double d1,d2;&lt;br /&gt;
Widget类：WidgetImpl *pImpl;&lt;br /&gt;
解决，两步：&lt;br /&gt;
【1】Widget内提供成员函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//使用using std::swap,而不是直接在下面的句子调用std::swap(...)&lt;/span&gt;
    &lt;span class="c1"&gt;//这样给编译器一个选择的余地，它会在WidgetImpl类所在命名空间(argument-dependent lookup)，&lt;/span&gt;
    &lt;span class="c1"&gt;//和当前命名空间或上层(normal lookup)，上分别进行名字查找来确定候选函数。&lt;/span&gt;
    &lt;span class="c1"&gt;//然后调用最合适的swap版本。最合适的版本是依据转换代价最小来确定的，而跟位于哪个作用域没有关系。  &lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//在这里是调用了stl中的swap（normal lookup的结果），因为WidgetImpl所在命名空间内没有&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【2】 std内特化swap  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:如果Widget是模版类，不能在std空间下定义swap，因为不支持偏特化函数，即使支持也不能添加到std里。这时候，在Widget定义所在的命名空间内定义一个模版swap函数&lt;code&gt;template&amp;lt;typename T&amp;gt;void swap(Widget&amp;lt;T&amp;gt;&amp;amp;a,Widget&amp;lt;T&amp;gt;&amp;amp;b){...}&lt;/code&gt;，可以保证在使用swap(w1,w2)的时候，至少候选函数中会包含这个版本，这得益于argument-dependent lookup。
4.下面来自CppPrimer的内容(第4中文版：P232和P571)：&lt;br /&gt;
重载函数中既有普通函数，又有函数模版，确定具体哪个函数被调用的过程：&lt;br /&gt;
(1)确定候选函数（candidate functions），即调用点声明可见的同名普通函数，和可实例化模板函数。&lt;br /&gt;
(2)确定可行函数（viable functions），排除普通函数中没法匹配的函数。&lt;br /&gt;
(3)寻找实参和形参的最佳匹配，即转换代价最小的匹配。&lt;br /&gt;
(4)如果上面寻找到的最佳匹配有二义，去掉模版函数再寻找最佳匹配。&lt;br /&gt;
转换代价由低到高：&lt;br /&gt;
(1)exact match精确匹配（类型一致，比如形参和实参都是int）&lt;br /&gt;
(2)promotion整型提升（比如short转化成int）&lt;br /&gt;
(3)standard conversion标准转换（除类型提升外的隐式转换，比如bool转化成int，short转换成long）&lt;br /&gt;
(4)class-type conversion类类型转换（含有one-parameter-non-explicit构造函数的类，用构造函数参数类型转化成类类型）  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(3)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html" rel="alternate"></link><updated>2013-10-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(3).html</id><summary type="html">&lt;h2&gt;Item 09: Never call virtual functions in constructions and destructions&lt;/h2&gt;
&lt;p&gt;1.derived class对象构造时，base class构造函数先被调用，在其中调用/间接调用的虚函数是是父类的版本。原因有二：&lt;br /&gt;
（1）父类构造时，子类成员变量尚未初始化，处于未定义状态，C++不允许调用子类virtual函数（几乎必然会访问成员变量）&lt;br /&gt;
（2）父类构造函数执行时，动态类型是父类。&lt;br /&gt;
同理，析构函数。&lt;br /&gt;
2.替代策略：对于每个子类都要调用的函数，不声明virtual&lt;br /&gt;
（1）每个子类构造函数分别调用相应函数。例如logTransaction()&lt;br /&gt;
（2）子类构造函数显示调用父类构造函数，传递参数上去。例如&lt;code&gt;BaseClass(createLogString(para))&lt;/code&gt;，其中createLogString是static成员，保证不会访问子类对象的成员变量。  &lt;/p&gt;
&lt;h2&gt;Item 11: Handle assignment to self in operator=&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
         &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
         &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：自我赋值安全性，异常安全性。&lt;br /&gt;
解决：&lt;br /&gt;
（1）证同测试 identity test  -》解决了自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;==&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  &lt;span class="c1"&gt;//测试是否是自我赋值  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//异常可能发生，比如内存不足，复制构造函数有异常抛出。如果外面捕获了该异常，并继续执行程序，那么pb将指向被释放了的空间，之后任何操作都会引起未定义行为。  &lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）调整语句顺序 -》解决异常安全性，同时解决自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//先构造，后删除  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）copy and swap -》解决异常安全性，同时解决自我赋值安全性&lt;br /&gt;
思想就是用参数构造一个临时对象，然后和类内对象交换。具体代码略。  &lt;/p&gt;
&lt;h2&gt;Item 12： Copy all parts of an object&lt;/h2&gt;
&lt;p&gt;1.如果类中新增了一个成员变量，一定记得同时修改构造函数、复制构造函数和赋值操作符，确保新成员变量被合理的初始化和赋值。&lt;br /&gt;
2.派生类定义的复制构造函数，和赋值操作符，需要调用基类的相应函数，否则前者隐式调用基类的默认构造函数，后者则不会调用基类的赋值操作符。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;),...&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//也可以使用if(this==&amp;amp;rhs)包裹函数体，跳过自我赋值。这需要权衡自我赋值的次数，以及增加这一条判断语句的代价。一般可以不加这句话。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：编译器合成的版本，会自动调用基类的复制构造和赋值操作，就像上面实现的一样。&lt;br /&gt;
3.重复代码放到私有函数init里，不要复制构造调用赋值操作符，或反过来。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(4)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html" rel="alternate"></link><updated>2013-10-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(4).html</id><summary type="html">&lt;h2&gt;Item 13: Use objects to manage resources&lt;/h2&gt;
&lt;p&gt;1.资源是指，使用完之后需要归还系统的东西。比如动态分配的内存，文件描述符，互斥锁，数据库连接，sockets。&lt;br /&gt;
2.尽管可以手动释放资源（比如delete），但是程序的修改（delete之前返回了），或客户的忘记，可能导致资源释放不了。&lt;br /&gt;
解决办法：用对象管理资源，利用对象在作用域范围之外会自动调用析构函数的机制，释放资源。&lt;br /&gt;
对于heap-based资源（资源new出来的，通过指针访问），有如下两种智能指针可用：&lt;br /&gt;
（1）std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &lt;br /&gt;
缺点：指向同一对象的auto_ptr，进行赋值或拷贝构造，会导致原ptr变成null。这样的目的，释放多次同一个资源。&lt;br /&gt;
（2）std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&lt;br /&gt;
注意：不存在上面的问题，因为是RCSP(引用计数智能指针)。&lt;br /&gt;
3.以上两种指针，都是在析构函数中使用delete，动态数组元素放入上面两个智能指针中，会导致释放不完全。&lt;br /&gt;
解决：&lt;br /&gt;
（1）使用vector代替动态数组。&lt;br /&gt;
（2）仍然使用动态数组，那么使用&lt;code&gt;boost::scoped_array&lt;/code&gt;，&lt;code&gt;boost::shared_array&lt;/code&gt;。  &lt;/p&gt;
&lt;h2&gt;Item 14: Think carefully about copying behavior in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.不是heap-based的资源，需要自己建立资源管理类。然后将需要管理的资源类放在一个大括号内，退出大括号析构函数负责释放资源。&lt;br /&gt;
2.资源管理类的复制行为：&lt;br /&gt;
（1）不希望复制：&lt;br /&gt;
private继承Uncopyable&lt;br /&gt;
（2）资源一个副本，引用计数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mutexPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第二个参数是删除器，引用计数为0时调用的函数。不带此参数默认行为是delete  &lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutext&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）资源多个副本：&lt;br /&gt;
每次复制资源都深拷贝。&lt;br /&gt;
（4）转移资源拥有权：&lt;br /&gt;
使用std::auto_ptr。  &lt;/p&gt;
&lt;h2&gt;Item 15: Provide access to raw resources in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.API往往访问原始资源，所以资源管理类要提供取得原始资源的办法。&lt;br /&gt;
2.标准库中两个智能指针的做法：&lt;br /&gt;
（1）显式访问：get()&lt;br /&gt;
（2）隐式访问：成员访问操作符 -&amp;gt; 和 .可以访问到原始资源的成员&lt;br /&gt;
3.自定义资源管理类的做法：&lt;br /&gt;
（1）显式访问：定义get() ，更安全&lt;br /&gt;
&lt;code&gt;FontHandle get() const {return f;}&lt;/code&gt;&lt;br /&gt;
（2）隐式访问：定义隐式转换函数 ，更方便&lt;br /&gt;
&lt;code&gt;operator FontHandle() const {return f;}&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item16: Use the same form in corresponding uses of new and delete&lt;/h2&gt;
&lt;p&gt;1.new执行过程：通过名为operator new的函数分配内存；在该块内存有一个或多个（new string[4]）构造函数被调用。&lt;br /&gt;
delete执行过程：在该内存有一个或多个（delete [] arr）析构函数被调用；通过名为operator delete的函数释放内存。&lt;br /&gt;
2.delete []一个对象，和delete一个数组，结果都未定义。因为数组在内存的布局可能是：起始地址放置数组大小（4B），之后是数组内容。&lt;br /&gt;
3.注意typedef定义的数组类型的释放:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非常容易引起混淆，所以最好不好定义数组类型，vector代替。  &lt;/p&gt;
&lt;h2&gt;Item17: Store newed object in smart pointers in standalone statements(standalone 独立的)&lt;/h2&gt;
&lt;p&gt;1.例子：&lt;br /&gt;
&lt;code&gt;processWidget(std::tr1::shared_ptr&amp;lt;Widget&amp;gt;(new Widget),priority());&lt;/code&gt; &lt;br /&gt;
问题：编译器的优化可能导致这种顺序的调用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;  
&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//如果抛出异常，new的资源就泄露了，因为没有指针指向它，没法释放  std::tr1::shared_ptr&amp;lt;Widget&amp;gt;构造函数  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决办法：独立语句中将动态分配的对象存入智能指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;tr1&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="nx"&gt;processWidget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Python学习笔记-字符串</title><link href="http://particle128.com/posts/2013/09/python-str.html" rel="alternate"></link><updated>2013-09-22T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-22:posts/2013/09/python-str.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;注意：str支持的操作，基本上unicode也支持。此外unicode还多两个函数unicode.isnumeric() unicode.isdecimal()&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;（一） 具备的操作&lt;/h3&gt;
&lt;p&gt;str作为序列元素，包含其他序列共同的操作：&lt;br /&gt;
1. “hello” [not] in "hello world"&lt;br /&gt;
2. "hello" + " world"&lt;br /&gt;
3. 5*"hello" 或 “hello”*5&lt;br /&gt;
4. "hello"[3]  "hello"[1:2]  "hello"[1:2:2]&lt;br /&gt;
5. len("hello")  min("hello")  max("hello")&lt;br /&gt;
6. "hello".index('o')   "hello".count('l')  &lt;/p&gt;
&lt;h3&gt;（二） 不具备的操作&lt;/h3&gt;
&lt;p&gt;str同tuple一样，属于不可变序列。可变序列包括list和bytearray。因此str不具备可变序列的操作：&lt;br /&gt;
1. s[i] = x    s[i:j] = t 【t是任何可迭代对象】 s[i:j:k] = t 【t需要和s[i:j:k]有相同数量的元素】&lt;br /&gt;
2. del s[i:j]    del s[i:j:k]   s.remove(x) =&amp;gt; del s[x]&lt;br /&gt;
3. s.insert(i, x)  s.append(x)  s.extend(t) 【t是任何可迭代对象】&lt;br /&gt;
4. s.reverse()    s.sort([cmp[, key[, reverse]]])&lt;br /&gt;
5. s.pop([i]) =&amp;gt; x = s[i]; del s[i]; return x  &lt;/p&gt;
&lt;h3&gt;（三） 字符串方法&lt;/h3&gt;
&lt;p&gt;str.capitalize()第一个字母大写 str.title() 每一个单词首字母大写&lt;br /&gt;
str.count(sub[, start[, end]])&lt;br /&gt;
str.endswith(suffix[, start[, end]])返回True或False 同理str.startswith&lt;br /&gt;
str.find(sub[, start[, end]]) 找不到返回-1 同理str.rfind&lt;br /&gt;
str.index(sub[, start[, end]])找不到raise ValueError 同理str.rindex&lt;br /&gt;
str.format(*args, **kwargs) 同格式化字符串&lt;br /&gt;
islower isupper isspace isdigit isalpha isalnum&lt;br /&gt;
str.ljust(width[, fillchar])左对齐，可以选择填充字节，默认空格。 同理str.rjust，str.zfill(width)相当于str.rjust(width,'0')&lt;br /&gt;
str.lower() str.upper() str.swapcase()交换大小写&lt;br /&gt;
str.partition(sep) 划分 'what the fuck'.partition('the') =&amp;gt; ('what ','the',' fuck') 同理rpartition&lt;br /&gt;
str.join(iterable) 把可迭代对象（比如序列）拼接成字符串，用str隔开每一个可迭代对象中的元素&lt;br /&gt;
str.translate(string.maketrans(from,to) [,deletechars]) 要么进行字母的替换，要么进行字母的删除（第一个参数为None），要么同时进行&lt;br /&gt;
str.strip([chars]) 默认去掉whitespace 同理str.lstrip str.rstrip &lt;br /&gt;
str.split([sep]) 默认whitespace作为分隔符  &lt;/p&gt;
&lt;h3&gt;（四） string方法&lt;/h3&gt;
&lt;p&gt;string.maketrans(from,to) 返回translation table（from中的字符被to中同一位置的字符替换），from和to长度要相同&lt;br /&gt;
string.capwords(s[,sep]) 比titile更加准确的首字母大写函数。先split([sep])，再capitalize()，再join()  &lt;/p&gt;
&lt;h3&gt;（五） 格式化字符串&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%(language)s&lt;/span&gt;&lt;span class="s"&gt; has &lt;/span&gt;&lt;span class="si"&gt;%(number)03d&lt;/span&gt;&lt;span class="s"&gt; quote types.&amp;quot;&lt;/span&gt;  &lt;span class="o"&gt;%&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;（六）字符串常量&lt;/h3&gt;
&lt;p&gt;string.digits&lt;br /&gt;
string.hexdigits&lt;br /&gt;
string.octdigits&lt;br /&gt;
string.lowercase&lt;br /&gt;
string.uppercase&lt;br /&gt;
string.whitespace&lt;br /&gt;
string.punctuation  &lt;/p&gt;</summary><category term="python"></category><category term="str"></category></entry><entry><title>Python学习笔记-logging模块</title><link href="http://particle128.com/posts/2013/09/python-logging.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/python-logging.html</id><summary type="html">&lt;h4&gt;Logging is a means of tracking events that happen when some software runs.&lt;/h4&gt;
&lt;h3&gt;1、各种消息机制的使用场合&lt;/h3&gt;
&lt;p&gt;终端输出来显示一些信息：print()&lt;br /&gt;
报告软件常规运行中出现的一些事件，比如状态变化或错误调查：logging.info()，&lt;br /&gt;
logging.debug()用来诊断错误&lt;br /&gt;
发布一个警告：logging.warning()或warnings.warn()&lt;br /&gt;
报告一个错误：raise an exception&lt;br /&gt;
不抛出异常的出错：logging.error(), logging.exception(), logging.critical()  &lt;/p&gt;
&lt;p&gt;logging有一个属性叫level或severity，只有不低于它的事件才会被捕捉。&lt;/p&gt;
&lt;p&gt;level由低到高依次是：&lt;br /&gt;
DEBUG，INFO，WARNING（默认等级），ERROR，CRITICAL  &lt;/p&gt;
&lt;h3&gt;2、基础用法&lt;/h3&gt;
&lt;p&gt;默认日志消息会输出到终端（sys.stderr），用法为：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;  
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; before you &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Look&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;leap!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一次性配置日志消息，用法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;example.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;filemode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(levelname)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;something happends.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;basicConfig参数：
filename指明日志消息输出到指定的文件中，默认输出到终端&lt;br /&gt;
filemode指明文件打开方式是只写，每次输出日志都会把原来的日志覆盖。默认是追加('a')&lt;br /&gt;
level指明追踪(track)的日志等级&lt;br /&gt;
format指明日志格式，里面的字典参数依次是：日期、等级名、日志消息。format里不支持：和\n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; basicConfig只能在调用logging.debug()等任意函数之前调用，否则无效。调用之后，所有的logging行为都按照配置，再次执行basicConfig也不能进一步修改配置。所以称之为one-off（一次性的）。&lt;/p&gt;
&lt;h3&gt;3、高级用法&lt;/h3&gt;
&lt;p&gt;比较好的习惯是logger=logging.getLogger(__name__) ，这样每个模块里logger的名字都是以自己模块的名字来命名的，从日志中可以看出是哪里导出的日志。&lt;/p&gt;
&lt;p&gt;logger=logging.getLogger()相当于获取根logger，即名字为root的logger  &lt;/p&gt;
&lt;p&gt;Logger常用方法：&lt;br /&gt;
setLevel()，addHandler()，removeHandler()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;Handler常用方法：&lt;br /&gt;
setLevel()，setFormatter()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;myFilter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;#其实可以不用继承，只要含有filter方法的类都可以&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;# record是LogRecord对象&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#使用msg属性或getMessage()方法都可以&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# zero for not logging&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# non-zero for logging&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;main.a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# main.a是该logger的name，即所有者，用点来分割命名空间。如果是main.a则是main的子类，继承关系影响level、handler，如果不设置level就按照父类的level进行设置，如果不设置handler，就由父类的handler捕获。&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 过滤该level以下的日志消息&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c"&gt;# 比level更细力度的过滤功能&lt;/span&gt;

&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/home/mashu/log.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StreamHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 文件level是INFO&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 终端level是DEBUG&lt;/span&gt;
&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)-15s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(name)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(levelname)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 设置日志消息的格式&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;first: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;second:test log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;third: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="logging"></category></entry></feed>