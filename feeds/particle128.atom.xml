<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>particle128's Blog</title><link href="http://particle128.com/" rel="alternate"></link><link href="http://particle128.com/feeds/particle128.atom.xml" rel="self"></link><id>http://particle128.com/</id><updated>2015-04-24T21:59:40+08:00</updated><entry><title>C++11专题：智能指针</title><link href="http://particle128.com/posts/2015/04/smart-ptr.html" rel="alternate"></link><updated>2015-04-24T21:59:40+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-24:posts/2015/04/smart-ptr.html</id><summary type="html">&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;C++从C语言那里引入了指针类型，即所谓内建指针（built-in pointer）。传统的动态内存分配和释放(new &amp;amp; delete)也都是基于指针的，容易出如下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;忘记delete，内存/资源泄露&lt;/li&gt;
&lt;li&gt;两次delete同一个指针，未定义&lt;/li&gt;
&lt;li&gt;delete之后的指针继续使用，未定义&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而且，这些问题，很难调试，比如你delete了一个指针之后，堆上的同一块区域后来又被分配出去，那么你下次delete可能没有运行时错误，但是堆上的空闲链表却被你破坏了，之后的程序可能出现非常诡异的问题。&lt;/p&gt;
&lt;h2&gt;意义&lt;/h2&gt;
&lt;p&gt;智能指针，如果&lt;em&gt;使用得当&lt;/em&gt;，可以防止以上三个问题，因为delete操作交给析构函数来进行(问题1、2)，并且析构之后的智能指针被自动置nullptr(问题3)。另外，通过不同类型的智能指针，可以实现普通指针不能实现的额外好处，比如共享资源(&lt;code&gt;shared_ptr&lt;/code&gt;)、专用资源(&lt;code&gt;unique_ptr&lt;/code&gt;)等。&lt;/p&gt;
&lt;p&gt;这里说的&lt;em&gt;使用得当&lt;/em&gt;是指，按照惯例来使用智能指针：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要用同一个内建指针初始化或reset多个智能指针&lt;/li&gt;
&lt;li&gt;不要delete get()返回的指针&lt;/li&gt;
&lt;li&gt;不要用get()返回的指针初始化或reset另一个智能指针&lt;/li&gt;
&lt;li&gt;get()返回的指针，在智能指针所指对象被释放后，就不能使用了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;用法&lt;/h2&gt;
&lt;h3&gt;shared_ptr&lt;/h3&gt;
&lt;p&gt;共享资源，带引用计数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;del&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; (string *ele) {delete ele;};
    // construct
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p1;
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p2(new string);
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; pd1(new string, del); // 此处不能用auto,auto只能推导复制构造!
    // copy construct
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p4(p2);
    shared_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p5 = make_shared&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(&amp;quot;1&amp;quot;);
    auto p6 = make_shared&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;();
    auto p7(p6);
    // assign
    p1 = p2;
    // reset：用内建指针初始化和reset的格式一致
    p1.reset();
    p1.reset(new string);
    p1.reset(new string, del);
    // unique
    if (!p1.unique()) { /*if the string pointed by p1 has other references*/
        p1.reset(new string(*p1));
    }
    *p1 += &amp;quot;1&amp;quot;; /*change the string refered by p1*/
    // swap
    swap(p1,p2);
    p1.swap(p2);
    // * -&amp;gt;
    int size = p1-&amp;gt;size();
    string s = *p1;
    // get
    string *ps = p1.get();
    // use_count
    int n = p1.use_count();

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;unique_ptr&lt;/h3&gt;
&lt;p&gt;专用资源，资源只能被一个指针引用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;deref&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;clone&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="n"&gt;del&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; (string *ele) {delete ele;};
    // construct
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p1;
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p2(new string);
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="na"&gt;decltype&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;del&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; pd1(new string, del); 
    // reset：用内建指针初始化和reset的格式一致
    p1.reset();
    p1.reset(new string);
    // swap
    swap(p1,p2);
    p1.swap(p2);
    // * -&amp;gt;
    int size = p1-&amp;gt;size();
    string s = *p1;
    // get
    string *ps = p1.get();
    // release
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; p3(p1.release());
    p2.reset(p1.release()); // p1 release之后指向nullptr
    p1 = nullptr;

    // 一般情况下，unique_ptr不能拷贝构造和赋值
    // 只有一个例外：当unique_ptr马上要被析构的时候
    unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt; ptr1 = clone(string(&amp;quot;123&amp;quot;)); // 最常见用法：函数返回
    string res = deref(unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(new string(&amp;quot;123&amp;quot;))); // string res1 = deref(p1); //不行
    auto ptr2((unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;())); // auto ptr2(p1); //不行
    ptr1 = unique_ptr&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;(); // ptr1 = p1; // 不行

    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;指向共享资源的指针，但是不增加引用计数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;memory&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="c1"&gt;// construct&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// copy construct&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;p3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;weak_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;p4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// assign&lt;/span&gt;
    &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;p3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// reset&lt;/span&gt;
    &lt;span class="nx"&gt;p3.reset&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// use_count&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.use_count&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// expired&lt;/span&gt;
    &lt;span class="nx"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.expired&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// use_count() == 0 时返回true&lt;/span&gt;
    &lt;span class="c1"&gt;// lock&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;p2.lock&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;sp1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="c++11"></category></entry><entry><title>To do list</title><link href="http://particle128.com/posts/2015/04/to-do-list.html" rel="alternate"></link><updated>2015-04-23T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-23:posts/2015/04/to-do-list.html</id><summary type="html">&lt;p&gt;好多书想看，好多课程想学，好多领域想涉入，每天却还是被焦虑、畏难所困扰，现在开始在blog写to-do-list监督自己！&lt;/p&gt;
&lt;h3&gt;next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sublime text&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4-25(Saturday)&lt;/h3&gt;
&lt;h3&gt;4-24(Friday)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C++11 10个特性 (3~4h)&lt;/li&gt;
&lt;li&gt;Intellij Idea和Tomcat搭配，Head First JSP&amp;amp;Servlet一章 (3h)&lt;/li&gt;
&lt;li&gt;知乎关注的问题 (0.5h)&lt;/li&gt;
&lt;li&gt;幸福公开课第一课，做笔记 (1.5h)&lt;/li&gt;
&lt;/ul&gt;</summary><category term="life"></category></entry><entry><title>C++11专题：constexpr类型</title><link href="http://particle128.com/posts/2015/04/constexpr.html" rel="alternate"></link><updated>2015-04-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-15:posts/2015/04/constexpr.html</id><summary type="html">&lt;p&gt;代码是最好的文档，所以，本系列主要在代码中讲解。&lt;/p&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;C++中的const变量，包括编译时常量（compile-time constants）和运行时常量（runtime constants）。其中，编译时常量又叫常量表达式（constant expression），只有初始化式也是常量表达式的const变量才是常量表达式。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;const变量不一定是常量表达式，所以，const变量不一定能用在一些需要常量表达式的地方，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 非常量表达式，后面的(1)~(4)均编译出错&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// （1）初始化数组大小，标准不支持，但是g++支持&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;: &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// （2）case表达式&lt;/span&gt;
    &lt;span class="nl"&gt;default:&lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;// （3）枚举类型初始化&lt;/span&gt;
&lt;span class="n"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// （4）模板非类型参数的实例化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;意义&lt;/h2&gt;
&lt;p&gt;有时候，我们想定义一个常量表达式，但是不好判断初始化式（const变量组成的表达式）是不是常量表达式，只能把初始化式中的const变量都&lt;em&gt;追踪&lt;/em&gt;一遍，因为可能编译过程非常耗时，不能轻易编译。因此，C++11增加了常量表达式类型（constexpr类型）。这样，只要我们确保初始化式完全由字面常量和constexpr常量构成，就可以确定初始化是常量表达式，而不用对初始化式中的每个变量进行追踪。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// c++11之前&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//若 const int a = 10 + fun()则x不是&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//需要追踪a，b，c，d才能搞清楚x是不是常量表达式&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// c++11&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;12&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mh"&gt;13&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//确保c和d是constexpr即可&lt;/span&gt;
&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;用法&lt;/h2&gt;
&lt;p&gt;constexpr只能修饰字面值类型（literal type，即算术/指针/引用类型），用常量表达式或constexpr函数返回值初始化，用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 字面类 要求&lt;/span&gt;
&lt;span class="c1"&gt;// 1) 是聚集类(aggregate class：所有成员都是public，没有构造函数、类内初始化、基类、虚函数)&lt;/span&gt;
&lt;span class="c1"&gt;// 2) 不是聚集类，但是满足如下4个条件&lt;/span&gt;
&lt;span class="c1"&gt;// (1) 成员都是字面类型&lt;/span&gt;
&lt;span class="c1"&gt;// (2) 至少包含一个constexpr构造函数（函数体为空）&lt;/span&gt;
&lt;span class="c1"&gt;// (3) 若含有类内初始化，内建类型成员用constexpr初始化，类类型用constexpr构造函数初始化&lt;/span&gt;
&lt;span class="c1"&gt;// (4) 使用默认析构函数&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;geta&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;getb&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
    &lt;span class="nl"&gt;private:&lt;/span&gt;
        &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;// constexpr函数 要求&lt;/span&gt;
&lt;span class="c1"&gt;// (1) 参数和返回值都是字面值类型（算术、指针和引用类型，或字面类类型）&lt;/span&gt;
&lt;span class="c1"&gt;// (2) 函数体只有一条执行语句，即return语句&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;geta&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getb&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// constexpr指针/引用指向的变量只能是全局变量或静态变量，编译时地址已知(data段)。&lt;/span&gt;
&lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 1. 用常量表达式初始化&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (1) 算术类型，包括bool,short,int,double...&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (2) 指针类型，const修饰指针，而不是char&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y1&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;z1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ry&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// (3) 引用类型&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rz&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ry1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rz1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 2. 用constexpr函数返回值初始化（必须满足constexpr函数的参数都是常量表达式）&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;constexpr&lt;/span&gt; &lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// int i=10, j=5; constexpr int f1 = fun(i, i); // 用非常量表达式调用constexpr函数，返回结果也不是常量表达式&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="c++11"></category></entry><entry><title>C专家编程-笔记(2)</title><link href="http://particle128.com/posts/2015/04/ExpertC(2).html" rel="alternate"></link><updated>2015-04-11T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-11:posts/2015/04/ExpertC(2).html</id><summary type="html">&lt;h3&gt;第五章  对链接的思考&lt;/h3&gt;
&lt;p&gt;&lt;img alt="5-1" src="http://particle128.com/images/expert_c_5_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第六章  运动的诗章：运行时数据结构&lt;/h3&gt;
&lt;p&gt;&lt;img alt="6-1" src="http://particle128.com/images/expert_c_6_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第七章  对内存的思考&lt;/h3&gt;
&lt;p&gt;&lt;img alt="7-1" src="http://particle128.com/images/expert_c_7_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第九、十章  再论数组、再论指针&lt;/h3&gt;
&lt;p&gt;&lt;img alt="9-1" src="http://particle128.com/images/expert_c_9_1.png" /&gt;&lt;/p&gt;</summary><category term="ExpertC"></category></entry><entry><title>The Clean Coder 笔记 (4)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(4).html" rel="alternate"></link><updated>2015-04-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-06:posts/2015/04/theCleanCoder(4).html</id><summary type="html">&lt;h3&gt;Chapter10 Estimation&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The Law Of Large Numbers.&lt;br /&gt;
If you break up a large task into many smaller tasks and estimate them independently, the sum of the estimates of the small tasks will be more accurate than a single estimate of the larger task. The reason for this increase in accurary is that the errors in the small tasks tend to integrate out.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把一个大任务分成一些小任务，分别估计，然后计算估计的总和，作为大任务的估计。&lt;/p&gt;
&lt;h3&gt;Chapter13 Teams and Projects&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;It makes no sense to tell a programmer to devote half their time to project A and the rest of their time to Project B.  &lt;/p&gt;
&lt;p&gt;Teams are harder to build than projects. Therefore, it is better to form persistent teams that move together from one project to the next and can take on more than one project at a time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Appendix A Tooling&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;There was day when I was known as a vi 'god', but those days are long gone. I use vi from time to time if I need to do a quick edit of a text file. But the amount of true coding I have done in vi in the last 10 years is vanishingly small.&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (3)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(3).html" rel="alternate"></link><updated>2015-04-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-05:posts/2015/04/theCleanCoder(3).html</id><summary type="html">&lt;h3&gt;Chapter6 Practicing&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Turnaround Time. &lt;br /&gt;
Doing anything quickly requires practice. Spinning around the code/test loop quickly requires you to make very quick decisions. Making decisions quickly means being able to recognize a vast number of situations and problems and simply know that to do to address them.&lt;br /&gt;
Speed depends on practice. We choose a repertoire of problem/solution pairs and execute them over and over again until we know them cold.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习的目的就是让我们更加熟练，让一些操作成为肌肉记忆，做决定或做动作的时候不再需要思考。跟打羽毛球一样...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kata.&lt;br /&gt;
The goal is to make the perfected movements automatic and instinctive so that they are there when you need them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kata是一种练习方式，通过这种练习，让一些操作凭直觉自动产生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Practice Ethics.&lt;br /&gt;
Since your practice time is your own time, you dont' have to use th same languages or platforms that you use with your employer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习时候，用一下自己工作中不常用的语言。当自己工作中的语言已经很熟悉了，用用别的语言，让自己成为多面手。&lt;/p&gt;
&lt;h3&gt;Chapter7 Acceptance Testing&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Premature Precision.&lt;br /&gt;
The problem is that things appear different on paper than they do in a working system. WHen the business actually sees what they specified running in a system, they realize that it wasn't what they wanted at all. Once they see the requirement actually running, they have a better idea of what they really want - and it's usually not what they are seeing.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过早的精确，往往是有害的。开发者想要精确的需求说明，以便进行时间估计。需求说明无论多么明确，最后还是会修改，因为说明里的需求和真正拿出来做出的东西，是有很大区别的。看到真正的效果，客户往往又觉得应该是另外一个样子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Acceptance Test.&lt;br /&gt;
We will define acceptance tests as tests written by a collaboration of the stakeholders and the programmers in order to define when a requirement is done.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;验收测试的定义。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Accpetance Tests And Unit Tests.&lt;br /&gt;
Unit tests and acceptance tests are documents first, and tests second. Their primary purpose is to formally document the design, structure, and behavior of the system. The fact that they automatically verify the design, structure, and behavior that they specify is wildly useful, but the specification is their true purpose.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试的作用，首先是程序文档，其次才是测试代码。&lt;/p&gt;
&lt;h3&gt;Chapter9 Time Management&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Meetings.&lt;br /&gt;
Professionals actively resist attending meetings that don't have an immediate and significant benefit.&lt;br /&gt;
Over the years I've developed a simple rule: When the meeting gets boring, leave.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;尽量减少开会时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Arguments, Disagreements.&lt;br /&gt;
Any argument that can't be settled in five minutes can't be settled by arguing. The reason it goes on so long is that there is no clear evidence supporting either side.&lt;br /&gt;
Some folks will be passive-aggressive. They'll agree just to end the argument, and then sabotage the result by refusing to engage in the solution. This is probably the worst kind of unprofessional behavior there is. Never, ever do this. If you agree, then you must engage.&lt;br /&gt;
How do you get the data you need to settle a disagreement? Sometimes you can run experiments, or do some simulation or modeling. But sometimes the best alternative is to simply filp a coin to choose one of the two paths in question.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最不专业的做法就是同意某人的意见，以便结束争论，但之后却不按照同意的方法做。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Priority Inversion.&lt;br /&gt;
Whatever the reason, you find ways to avoid doing the real work. You convince yourself that something else is more urgent, and you do that instead. This is called priority inversion.&lt;br /&gt;
Clearly this is unprofessional behavior. Professionals evaluate the priority of each task, disregarding their personal fears and desires, and execute those tasks in priority order.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要因为畏难而改变事情的优先级，这是不专业的表现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Messes.&lt;br /&gt;
At some point you realize that you made a wrong design choice when you started, and that your code doesn't scale well in the direction that the requirements are moving. This is the inflction point! You can still go back and fix the design. But you can also continue to go forward. Going back looks expensive because you'll have to rework the existing code, bug going back will never be easier than it it now.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专业开发者会尽早察觉mess，并尽一切可能修改它，而不是将就着在mess上继续，因为这样最终会更加糟糕。&lt;br /&gt;
但是事事不绝对，facebook在发现php性能问题的时候，并没有重头推倒用java，因为担心这会至少影响几个月网站的更新。而是，继续用php做，同时投入研发了php转C++的工具——HipHop，使php继续用于网站开发，又不影响性能。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (2)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(2).html" rel="alternate"></link><updated>2015-04-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-04:posts/2015/04/theCleanCoder(2).html</id><summary type="html">&lt;h3&gt;Chapter4 Coding&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Preparedness. &lt;br /&gt;
If you are tired or distracted, do not code. You'll only wind up redoing what you did. Instead, find a way to eliminate the distractions and settle your mind. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;累或者走神的时候，别写代码。先把糟糕的状态排除或者减轻了，再来写代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3 AM Code. &lt;br /&gt;
I remember feeling so good about myself for the long hours I was working. I remember feeling dedicated. I remember thinking that working at 3 AM is what serious professionals do. How wrong I was! &lt;br /&gt;
That code came back to bite us over and over again.&lt;br /&gt;
We never had time to rewrite this wad (so we thought) but we always seemed to have time to add another wart or patch to work around it.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作到凌晨3点，不是件值得标榜的事。写坏了代码，做一些补丁，似乎总有时间，但是重新写代码，却总是没有时间，这是件讽刺的事。重新写，精力消耗很大，还是一开始就不要把代码写坏。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flow Zone.&lt;br /&gt;
You will write more code in the Zone. The problem is that you lose some of the big picture while you are in the Zone, so you will likely make decisions that you will later have to go back and reverse.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;心流状态可以让你更加专注、提高产出，但是缺点是让你失去全局观，可能因此做出一些短视的决定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Interruptions&lt;br /&gt;
There will be interruptions that distract you and cause you to lose time. When they happen, remember that enxt time you may be the one who needs to interrupt someone else. So the professional attitude is a polite willingness to be helpful.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;别怕耽误时间，乐于助人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creative Input. &lt;br /&gt;
I learned a long time ago that creative output depends on creative input. I find that the thing that best primes the pump of creative output is science fiction. For you, it might be something else.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了本职工作，多涉猎些其他方面，找到属于自己的、能激发自己创造力的活动。作者是看科幻小说，需要多尝试才知道什么是最适合自己的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Debugging Time.&lt;br /&gt;
Nowadays I spend much less time debugging than I did ten years ago. It's about a factor of ten. I achieved this truly radical reduction in debugging time by adopting the practive of Test Driven Development(TDD).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试驱动开发，减少调试时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pacing Yourself.&lt;br /&gt;
When you are working on a problem, you somtimes get so close to it that you can't see all the options. You miss elegant solutions because the creative part of your mind is suppressed by the intensity of your focus. Sometimes the best way to solve a problem is to go home, eat dinner, watch TV, go to bed, and then wake up the next morning and take shower.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;放松一下，不要一直紧盯着问题，效果反而更好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Being Late.&lt;br /&gt;
Regularly measure your progress against your goal, and come up with three fact-based end dates: best case, normal case, and worst case. Be as honest as you can about all three dates. Do not incorporate hope into your estimates. Present all three numbers to your team and stakeholders. Update these numbers daily.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最好情况，最坏情况和常规情况都要考虑在内，不要在估计中参杂希望。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hope.&lt;br /&gt;
Hope is the project killer. Hope destroys schedules and ruins reputations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望的危害。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Overtime.&lt;br /&gt;
You are not likely to get 20% more work done by working 20% more hours. What's more, overtime will certainly fail if it goes on for more than two or three weeks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;加班产出不如平时，而且加班最多不能超过2~3周，否则会适得其反。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Help.&lt;br /&gt;
Programming is hard. The younger you are the less you believe this.&lt;br /&gt;
You have to carefully partition the system into small understandable units that have as little to do with each other as possible and that's hard.   &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;年龄越大，越知道编程有多难。把一个系统分成一些易于理解、相互独立的单元，就是其中一个难点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Helping Others.&lt;br /&gt;
When you help someone, sit down and write code together. Plan to spend the better part of an hour or more. It may take less than that, but you don't want to appear to be runshed. Resign yourself to the task and give it a solid effort. You will likely come away having learned more than you gave.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;帮助别人的时候，真的划分出一块时间来，别显得很匆忙。帮助别人的过程中，自己的提高更多。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Being Helped.&lt;br /&gt;
If is unprofessional to remain stuck when help is easily accessible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;能寻求帮助的时候，别让自己卡在某处。&lt;/p&gt;
&lt;h3&gt;Chapter5  Test Driven Development&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Design.&lt;br /&gt;
The problem with testing code is that you have to isolate that code. It is often difficult to test a function if that function calls other function. To write that test you've got to figure out some way to decouple the function from all the others. In other words, the need to test first forces you to think about good design. &lt;br /&gt;
If you don't write your tests first, there is no force preventing you from coupling the functions together into an untestable mass. If you write your tests later, you may be able to test the inputs and the outputs of the total mass, but it will probably be quite difficult to test the individual functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试驱动，意味着先写测试，再写代码。优点主要有：测试代码成为一种更好读的文档、测试详尽从而修改代码的底气更足、测试的力度小从而调试时间更短。除此之外，还有一个优点：利于生成更好的设计。一个函数往往会调用多个函数，为了方便测试，我们需要解耦这些函数依赖，从而使测试代码能够方便测试。&lt;br /&gt;
作者明确指出，写完代码再写测试，属于防御；写完测试再写代码，属于进攻。主张TDD。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Documentation&lt;br /&gt;
Have you ever used a third-party framework? Often the third party will send you a nicely formatted manual written by tech writers. Where's the first place you go in that manual? If you are a programmer, you go to the code examples.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单元测试，可以当做最好的文档。阅读第三方库的时候，第一个要查看应该是代码示例，而不是写得很规范的一页一页的文档。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>The Clean Coder 笔记 (1)</title><link href="http://particle128.com/posts/2015/04/theCleanCoder(1).html" rel="alternate"></link><updated>2015-04-03T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-03:posts/2015/04/theCleanCoder(1).html</id><summary type="html">&lt;h3&gt;Chapter1 Professionalism&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;QA Should Find Nothing.&lt;br /&gt;
Some folks use QA as the bug catchers. They send them code that they haven't thoroughtly checked. They depend on QA to find the bugs and report them back to the developers. Indeed, some companies reward QA based on the number of bugs they find. The more bugs, the greater the reward. Every time QA, or worse a user, finds a problem, you should be surprised, chagrined, and determined to prevent it from happening again.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让测试人员发现不了问题，是开发人员的职责。当QA或用户发现问题，我们应该有的反应不是“哦，我去看看”，而是“吃惊和失望”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do No Harm To Structure.&lt;br /&gt;
The only way to prove that your software is easy to change is to make easy changes to it. When do you make these easy changes? All the time! Every time you look at a module you make small, lightweight chagnes to it to improve its structure. Every time you read through the code you adjust the structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次看到代码结构不够清晰的地方，就改动它一下。这需要详尽的测试的支持，改完需要运行一遍所有的测试，否则改动会很危险。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Work Ethic. &lt;br /&gt;
You should plan on working 60 hours per week. The first 40 are for your employer. The remaining 20 are for you. During this remaining 20 hours you should be reading, practicing, learning, and otherwise enhancing your career. Perhaps you don't want to make that kind of commitment. That's fine, but you should not then think of yourself as a professional. Professionals spend time caring for their profession.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;成为专家，需要工作之余的付出，一周除了工作之外抽出20小时。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Continuous Learning. &lt;br /&gt;
Learn things that are outside your comfort zone. If you are a .NET programmer, learn Java. If you are Java Programmer, learn Ruby.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;持续学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Practice. &lt;br /&gt;
It is not enough to simply do your daily jonb and call that practice. Doing your daily job is performance, not practice. Practice is when you specifically exercise your skills outside of the performance of your job for the sole purpose of refining and enhancing those skills.   &lt;br /&gt;
A kata usually comes in the form of a simple programming problem to solve, such as writing the function that calculates the prime factors of an integer. The point of kata is to train your fingers and your brain. I'll do a kata or two every day, often as part of settling in to work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;练习，不是展示，工作上做的东西不属于练习。每天做点小程序题，锻炼手指和脑袋。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mentoring. &lt;br /&gt;
Nothing will drive facts and values into your head faster and harder than having to communicate them to people you are responsible for.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;教给别人知识的过程，是把知识内化最好、最快的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identify With Your Employer/Customer. &lt;br /&gt;
As you develop a system you need to put yourself in your employer's shoes and make sure that the features you are developing are really going to address your employers' needs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要仅仅想着完成上面交给的任务，而是站在老板的角度考虑需求。&lt;/p&gt;
&lt;h3&gt;Chapter2 Saying No&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Trying. &lt;br /&gt;
The worst thing Paula could do in response to Mike's manipulations is say "OK, we'll try." If you are not holding back some energy in reserve, if you don't have a new plan, if you aren't going to change your behavior, and if you are resonably confident in your original estimate, then promising to try is fundamentally dishonest. You are lying. And you are probably doing it to save face and to avoid a confrontation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;过去说过好多“我试试吧”，以后要改掉这个习惯。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every feature a client asks for will always be more complex to write than it is to explain.&lt;br /&gt;
The client will always extend the deadline. They will always want more features. They will always want change late.&lt;br /&gt;
What we have to realize is that saying yes to dropping our professional disciplines is not the way to solve problems. Dropping those disciplines is the way you create problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文中举了一个非常鲜活的例子。John很想把代码弄整洁，写出好的结构，但是开发了很多年后，发现，不论如何，都做不到这一点。因为每次经理或客户给的任务，他都一开始信心满满的答应。但是做着做着，就发现，功能远比想象中复杂、做出来的东西也许要改，最后时间紧任务重，不仅牺牲了家庭生活时间，还不得不把代码弄糟以求速度。作者认为，全是John的过错，他既然知道客户的需求随时可能变化，给的截止日期也总可以拖后，就不该逞英雄、作保证。专业的开发者会在必要的时候说不。&lt;/p&gt;
&lt;h4&gt;Chapter3 Saying Yes&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;What Does Commitments Sound Like? &lt;br /&gt;
The secret ingredient to recognizing real commitment is to look for sentences that sound like this: I will ... by ... (example: I will finish this by Tuesday.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;need/should/hope/wish/let's都不是承诺。真正的承诺是：我会在什么时间之前做完什么。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You can only commit to things that you have full control of. For example, if your goal is to finish a module that also depends on another team, you can't commit to finish a module that also depends on another team.  &lt;br /&gt;
If it can't be done, you can still commit to actions that will bring you closer to the target.&lt;br /&gt;
Something unexpected might happen, and that's life.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只对自己有完全控制、确定可以完成的事情做承诺。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Years of experience have taught us that breaking disciplines only slows us down.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不要盲目承诺，破坏纪律的逞能，最后只会让速度更慢。&lt;/p&gt;</summary><category term="theCleanCoder"></category></entry><entry><title>C专家编程-笔记(1)</title><link href="http://particle128.com/posts/2015/04/ExpertC(1).html" rel="alternate"></link><updated>2015-04-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2015-04-02:posts/2015/04/ExpertC(1).html</id><summary type="html">&lt;p&gt;这次写C专家编程的笔记，感觉每一章的联系性比较强，就不用一行一行的文字罗列了，尝试用Xmind的流程图和思维导图来呈现。&lt;/p&gt;
&lt;h3&gt;第一章  C:穿越时空的迷雾&lt;/h3&gt;
&lt;p&gt;&lt;img alt="1-1" src="http://particle128.com/images/expert_c_1_1.png" /&gt;
&lt;img alt="1-2" src="http://particle128.com/images/expert_c_1_2.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第二章  这不是Bug，而是语言特性&lt;/h3&gt;
&lt;p&gt;&lt;img alt="2-1" src="http://particle128.com/images/expert_c_2_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第三章  分析C语言的声明&lt;/h3&gt;
&lt;p&gt;&lt;img alt="3-1" src="http://particle128.com/images/expert_c_3_1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;第四章  令人震惊的事实：数组和指针并不相同&lt;/h3&gt;
&lt;p&gt;数组/指针在不同源文件中的定义和声明，应该形式一样。&lt;/p&gt;
&lt;p&gt;一个源文件下定义的数组int a[10]，在另一个源文件下声明，必须使用extern int a[]形式；&lt;br /&gt;
一个源文件下定义的指针&lt;code&gt;int *a&lt;/code&gt;，在另一个源文件下声明，必须使用&lt;code&gt;extern int *a&lt;/code&gt;形式。  &lt;/p&gt;
&lt;p&gt;原因：同样一条语句&lt;code&gt;a[0] = 1;&lt;/code&gt;，编译器对于a是数组和a是指针的处理方式不同。&lt;/p&gt;
&lt;p&gt;假设我们定义了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并且a在符号表中的内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var_name&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;var_address&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在外部用两种不同方式声明：&lt;/p&gt;
&lt;h4&gt;extern int a[]; a[1] = 1;&lt;/h4&gt;
&lt;p&gt;a是外部变量的声明，不分配空间，编译时用Undefined符号代替。&lt;br /&gt;
链接时，查找符号表，找到a，把符号表中a的地址123456当做数组首地址，把1赋给内存单元(123456+4)&lt;/p&gt;
&lt;h4&gt;extern int *a; a[1] = 1;&lt;/h4&gt;
&lt;p&gt;a是外部变量的声明，不分配空间，编译时用Undefined符号代替。&lt;br /&gt;
连接时，查找符号表，找到a，把符号表中a的地址123456当做指针地址，取(123456)内存单元中的内容，假设是654321，把该数值当做数组的首地址，然后把1赋给内存单元(654321+4)。&lt;/p&gt;</summary><category term="ExpertC"></category></entry><entry><title>写在2014年的最后一天</title><link href="http://particle128.com/posts/2014/12/2014-last-day.html" rel="alternate"></link><updated>2014-12-31T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-31:posts/2014/12/2014-last-day.html</id><summary type="html">&lt;p&gt;今天是12.31，2014年的最后一天。崔师兄喊着实验室的人，一起去知语山吃饭。聚餐期间，我们继续保持着三句不离本行的特色，“黑”师兄、“黑”师弟，气氛非常好。&lt;/p&gt;
&lt;p&gt;中间，我带领大家玩了一下“谁是卧底”，从分辨我们实验室的两大师兄，分辨Java和C++，到我们使用“谁是卧底”的安卓app，大家玩的不亦乐乎。有一次我是卧底，手里拿着“白富美”，大家手里的是“高富帅”，我在一轮还没说完的时候，就猜到了这个局面，之后，说了很多两者都一样的特质，比如“优越的生活条件”，“钱一般是从父母继承过来的”，等等…但是，xiaodong xu这货，没有啥证据就愣猜是我，还号召大家一起投我，明明其他人的说法中都有破绽，他还是坚持自己的想法。最终，我在硬撑了3轮（每一轮都竭尽全力地给自己辩护，找其他人的漏洞啊，容易吗我）之后，被他和他蛊惑了的群众投死了。事后才知道，他的确猜错了我的身份，以为我的底牌是“土豪”。&lt;/p&gt;
&lt;p&gt;这一年感觉过得很丰富，很快乐，很精彩，值得回忆的事情很多。这表明，我虽然可以接受两点一线的艰苦求学生活，但更喜欢更加丰富和精彩的生活。不知道是因为我的心态变得更好了，还是我的性格变得更开朗了，还是我的确这一年遇到了太多开心的事情和需要感恩的人，简单回忆一下2014，满是温暖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实习，遇到了人生导师+技术前辈+贵人——耗子哥，各种无节操开玩笑，和人生、技术的指导，让我受益良多。&lt;/li&gt;
&lt;li&gt;实习，遇到了专业“技术达人”和业余“相声演员”——焦义师兄，让我见识到了真正的全栈工程师。&lt;/li&gt;
&lt;li&gt;实习期间，和黄震、石博、小绿（到现在我还记不住他的名字）一起熬夜宵，回去路上侃大山，实在快活。&lt;/li&gt;
&lt;li&gt;实习临走之前，被李廷请客吃了烧烤，第一次吃海贝类的烧烤，还有绝佳的馒头片，太赞了。&lt;/li&gt;
&lt;li&gt;找工作期间，寄宿在王庚脚下的地下室招待所，生活的磨砺，和性格的磨砺。幸好有王庚在，要不然都无聊死了。&lt;/li&gt;
&lt;li&gt;回学校后，继续找工作，去北京终面微软，去上海ac面摩根斯坦利，认识很多优秀和有趣的人。&lt;/li&gt;
&lt;li&gt;找完工作，和实验室的一帮师弟师妹，偶尔一起聚餐、看电影、唱歌，真幸福！&lt;/li&gt;
&lt;li&gt;明年1.8还要和实验室的人，外加室友，一起去哈尔滨，想想就兴奋啊，哇哈哈~~~&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我是幸运的，能在短暂人生旅途中的这一段，有这么一帮人，陪我度过。&lt;/p&gt;
&lt;p&gt;刚刚查看了2013年的年终总结（没有放到网上），有些感触。突然意思到，当时只是一时兴起的写作，应该伴随我一生。回忆，是一件美好的东西，我需要记录下来生命中的点点滴滴，这是一笔财富。只不过，有些个人情感的东西，我暂时不想发布出来。说不定，等我年龄大了，就想公开了。&lt;/p&gt;
&lt;p&gt;游完哈尔滨，写个游记，放到博客上；大年初一，写个总结，自己留着。&lt;/p&gt;
&lt;p&gt;2014，再见；2015，我来了。&lt;/p&gt;</summary><category term="life"></category></entry><entry><title>Clean Code (6)</title><link href="http://particle128.com/posts/2014/12/cleanCode(6).html" rel="alternate"></link><updated>2014-12-28T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-28:posts/2014/12/cleanCode(6).html</id><summary type="html">&lt;h3&gt;Chapter17 Smells and Heuristics&lt;/h3&gt;
&lt;p&gt;这一章，是前面描述的内容的总结，列举了一些“不简洁代码”的表现。简单记录一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建工程，应当只需要一条命令；测试工程，也应该只需要一条命令。&lt;/li&gt;
&lt;li&gt;注释掉的代码，没有被调用的代码，不用担心，直接删掉就行。版本控制器会帮你管理。&lt;/li&gt;
&lt;li&gt;最小惊讶原则：你实现的函数，应当具有其他程序员凭直觉认定的，你这个函数应当具有的功能。比如&lt;code&gt;StringToDay&lt;/code&gt;函数，应当将字符串"Monday"转化成enum Day类型的对象，并且，支持缩写（"Mon"）、不缺分大小写（"monday"）。如果没有实现某些感觉上显而易见的功能，使用该函数的程序员就需要去看代码或文档。&lt;/li&gt;
&lt;li&gt;最重要的原则之一：去重复。不单单是代码的重复，还包括&lt;br /&gt;
1.大段的if/else或switch/case结构，用多态和抽象工场代替&lt;br /&gt;
2.相似的算法，用模板方法模式或策略模式代替&lt;/li&gt;
&lt;li&gt;将概念进行分层抽象，不要将代码写到错误的抽象层次上。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Isolating abstractions is one of the hardest things that software developers do, and there is no quick fix when you get it wrong.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;基类应对派生类一无所知，这是分离概念的要求。它们一般位于不同的jar文件中，当派生类替换时，基类不需要重新部署。例外：有限自动机，父类需要知道所有派生类的情况，父类和子类位于同一个jar文件中。&lt;/li&gt;
&lt;li&gt;接口越小越好，提供出来的公有函数越少越好。&lt;/li&gt;
&lt;li&gt;当两个模块之间没有依赖关系，不要仅仅因为一个模块需要使用另一个模块定义的一个东西时，建立了耦合。考虑一下，是不是我们把变量、常量、函数放错了地方？&lt;/li&gt;
&lt;li&gt;特性依恋（Features Envy），是指类A的方法使用了类B（参数或成员）的访问器或修改器。这种情况下，可以考虑把该方法实现在类B中。但是，以上解决方法，仅仅在不破坏其他方面的前提下，才成立。如果如下这种情况，就不能照顾特型依恋了，否则会破坏单一职责原则、打开闭合原则等。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;HourlyEmployeeReport&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;HourlyEmployee&lt;/span&gt; &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;reportHours&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Name: %s&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;Hours:%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
        &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getHours&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;尽可能不用选择器参数（selector argument）。因为这样的方法，往往需要加注释，用来说明每种选项对应代码部分的意义。应当拆成几个方法，方法名就自我解释了。&lt;/li&gt;
&lt;li&gt;连续的长表达式，匈牙利标记法（Hungarian notation，用变量类型的缩写作为变量名的开头），魔数，都会让作者的意图很难理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;m_otCalc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;iThsWkd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;iThsRte&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;iThsRte&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
          &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;iThsWkd&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;em&gt;变量/常量/方法应该放在哪儿？&lt;/em&gt;用最少惊讶原则，即放置在语义上最合理的地方，而不是实现起来最方便的地方。好处：让读者可以很容易猜到它们的位置。&lt;/li&gt;
&lt;li&gt;静态方法还是非静态方法？优先非静态方法。如果感觉静态比较好，考虑是否将来会用到多态，如果可能用到多态，还是得非静态。&lt;/li&gt;
&lt;li&gt;用解释性变量，分拆一个长的表达式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toLowerCase&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 而不是&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;headers&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toLowerCase&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;match&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;给date变量增加几天，命名：修改date本身，用&lt;code&gt;addDaysTo&lt;/code&gt;或&lt;code&gt;increaseByDays&lt;/code&gt;；不修改date，返回一个新的对象，用&lt;code&gt;daysLater&lt;/code&gt;或&lt;code&gt;daysSince&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;用常量取代魔数，例外：常量是众所周知的，出现在很清晰的代码上。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dailyPay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hourlyRate&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;circumference&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2014/12/cleanCode(5).html"&gt;Clean Code (5)&lt;/a&gt;里提到了一种解决时间耦合的方法。还有一种方法，用返回值和参数约束：先调用的方法的返回值，作为后调用的方法的参数。&lt;/li&gt;
&lt;li&gt;封装边界条件，比如出现了两次的&lt;code&gt;level+1&lt;/code&gt;，可以用&lt;code&gt;nextLevel = level+1&lt;/code&gt;代替。&lt;/li&gt;
&lt;li&gt;如果模块A与模块B合作，模块B与模块C合作，我们不希望A知道C的存在。换句话说，让直接合作者（本例中的B）提供所有的服务。否则，如果想在B和C之间插入一个新的模块Q，将需要大动干戈：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getB&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getC&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// 应该是&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getB&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;如果我们需要引入同一个模块的两个以上的类，用通配符，好处（1）简洁（2）不是强依赖，降低耦合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;全书总结&lt;/h3&gt;
&lt;p&gt;全书从代码层面和设计层面讲解了“简洁之道”，提到了很多我之前不知道的原则：SRP（单一职责原则）、OCP（打开闭合原则）、DRY（不要重复自己）、PLS（最少惊讶原则）...让我大开眼界。&lt;/p&gt;
&lt;p&gt;一年前，写paper的时候，我把实验代码封装成一些类，用继承和组合关系来关联它们。在这个过程中，我经常遇到一个让我头疼的问题，一个方法到底应该放在哪里：派生类还是基类？这个类还是那个类？引用一句Clean Code中的话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the most important decisions a software developer can make is where to put code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;clean code这本书里提到的一些坏味道（bad smell）和一些实践经验，给了我很好的指导。让我知道了哪些东西应该有（好的名字）、哪些东西不应该有（不言自明的注释）、代码应该有哪些功能、代码应该放在哪里（最少惊讶原则）。&lt;/p&gt;</summary><category term="cleanCode"></category></entry><entry><title>科普一下gitignore</title><link href="http://particle128.com/posts/2014/12/gitignore.html" rel="alternate"></link><updated>2014-12-19T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-19:posts/2014/12/gitignore.html</id><summary type="html">&lt;p&gt;给实验室的师弟们科普一下gitignore的用法&lt;/p&gt;
&lt;h3&gt;gitignore是干嘛的&lt;/h3&gt;
&lt;p&gt;当我们不想让git上传/管理特定于本地开发环境的文件时，我们可以添加这些东西到git工程根目录下的.gitignore文件中。当新增的文件匹配上了.gitignore中的一个模式，git会忽略该文件，即&lt;code&gt;git status&lt;/code&gt;不会提示他们处于untracked状态，之后的&lt;code&gt;git add .&lt;/code&gt;也不会添加该文件，除非你强制添加，即&lt;code&gt;git add -f .&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;gitignore使用的通配符，和shell里的通配符几乎是一样的。&lt;br /&gt;
一点除外：在被/隔开的表达式中出现的*，只匹配所有非/的字符，也就是不能通配目录。&lt;/p&gt;
&lt;h3&gt;gitignore的位置&lt;/h3&gt;
&lt;p&gt;有三处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git管理的工程目录下的.gitignore： 项目所有成员的环境下都需要排除的文件&lt;/li&gt;
&lt;li&gt;git管理的工程目录下的.git/info/exclude：某个开发者，在某个工程，需要排除的文件&lt;/li&gt;
&lt;li&gt;~/.gitconfig：某个开发者，所有工程中，要排除的文件（比如~后缀的临时文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;例子&lt;/h3&gt;
&lt;p&gt;我尽量在下面的例子中涵盖了gitignore的所有功能&lt;/p&gt;
&lt;p&gt;目录结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;hehe&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; \
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;container&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;added&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;haha&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;hehe&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt;     &lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt;     &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;folder&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;added&lt;/span&gt;
&lt;span class="err"&gt;│  &lt;/span&gt; &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;haha&lt;/span&gt;
&lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;hehe&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;gitignore文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;# exclude &amp;quot;#123&amp;quot;, &amp;quot;!hehe&amp;quot;, and &amp;quot;123    &amp;quot;&lt;/span&gt;
&lt;span class="err"&gt;\#&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;hehe&lt;/span&gt;
&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt; 

&lt;span class="cp"&gt;# in gitignore, excluding a directory means exluding all the files under it&lt;/span&gt;
&lt;span class="cp"&gt;# exclude dir &amp;quot;/container&amp;quot; and all the pathname under it&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;

&lt;span class="cp"&gt;# exclude &amp;quot;haha&amp;quot; in the root directory of this git repository&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;

&lt;span class="cp"&gt;# exclude &amp;quot;hehe&amp;quot; in all directories of this git repository, including &amp;quot;/hehe&amp;quot;, &amp;quot;dir/hehe&lt;/span&gt;&lt;span class="cm"&gt;/*&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;h[exyz]h?&lt;/span&gt;

&lt;span class="cm"&gt;# exclude all the files under &amp;quot;/folder&amp;quot;, except &amp;quot;/folder/added&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;/folder/*&lt;/span&gt;
&lt;span class="cm"&gt;!/folder/added&lt;/span&gt;

&lt;span class="cm"&gt;# consecutive asterisks  &lt;/span&gt;
&lt;span class="cm"&gt;**/&lt;/span&gt;&lt;span class="cp"&gt;hehe # equivalent to &amp;quot;hehe&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;container&lt;/span&gt;&lt;span class="cm"&gt;/** # equivalent to &amp;quot;/container/&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;dir/**/&lt;/span&gt;&lt;span class="n"&gt;hehe&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;exclude&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;dir/hehe&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;dir/xx/hehe&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;so&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://git-scm.com/docs/gitignore"&gt;git-scm.com&lt;/a&gt;&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>Clean Code (5)</title><link href="http://particle128.com/posts/2014/12/cleanCode(5).html" rel="alternate"></link><updated>2014-12-17T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-17:posts/2014/12/cleanCode(5).html</id><summary type="html">&lt;h3&gt;Chapter14 Successive Refinement&lt;/h3&gt;
&lt;p&gt;本章通过一个例子（处理命令参数的工具类，它把它命名为Args），给我们展现了作者是如何一步一步重构代码的。这一章很赞，重构的步骤很有借鉴之处，代码非常可读。&lt;/p&gt;
&lt;p&gt;引用一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To write clean code, you must first write dirty code and then clean it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;焦义师兄写代码也是按照两步走来的。一开始写一个面向过程的，由许多文件构成的模块。之后，用面向对象思想和设计模式，将原来的代码重构成可读性、可扩展性、可维护性更强的版本。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试驱动开发（TDD）对于重构非常重要。重构过程中，每次只修改一点，刚好导致测试无法通过，然后再改到可以通过；再修改一点，刚好导致测试无法通过，再改到可以通过。。。这样循序渐进，保证重构不会引入新的问题。如果一次全部改完再测试，可能会引入新的bug，而且不容易定位bug的位置。&lt;/li&gt;
&lt;li&gt;重构的思路：找出每次扩展（对应该例子中，参数中增加新的类型），都要修改的地方。如果这些地方有共性，把这些方法抽离出来，形成一个类。&lt;/li&gt;
&lt;li&gt;在小作用域内，用简短的名字（比如&lt;code&gt;ArgumentMarshaler am&lt;/code&gt;），而不是更长和更有描述性的名字，更易读。&lt;/li&gt;
&lt;li&gt;尽早进行代码的调整和重构，越晚重构，成本越高！！！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重构的细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重构，不是重写，所以不要上来就写所有要新增加的类，然后把原来的代码全部推翻，这样非常混乱，而且相当于把所有代码都重写之后再编译运行，并看结果如何。之前实习时的第二次重构，我就犯了这个错误，越改代码越乱，原来的代码还不敢删，所以各种注释代码，各种新增的、都还跑不通编译的代码。最后，我都要丧失了继续该下去的动力。而且即使这样改完，测试出bug，我还是需要跟踪到具体哪里的bug。&lt;/li&gt;
&lt;li&gt;假设新增一个类，其他代码保持原样（不要删除原来的旧类），然后，用新增的类替换现在类的一个出现位置，如果可以通过测试，再替换另一个出现位置，再测试。当所有这些位置，都已经通过了测试，再要被替换掉的类，这时候肯定也能通过测试。&lt;/li&gt;
&lt;li&gt;假设要定义一个类层次，首先把需要的一个功能添加到父类，子类只继承，不做其他的事情，替换代码，测试。像这样逐渐增加功能到父类，并全部通过测试。然后，再一步一步的把父类的东西挪到对应的子类。或许你会觉得这样很麻烦，但是如果上来就重头定义这个类层次，那么也意味着要重头修改所有用到该类的地方。这会导致同时产生过多没有通过测试的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter15 JUnit Internals&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比较长的表达式，要封装到函数中；否定比肯定要难理解一些，尽量用肯定语气的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;  &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;areStringEqual&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// shouldNotCompact&lt;/span&gt;
    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shouldBeCompacted&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;shouldBeCompacted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;shouldNotBeCompacted&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;shouldNotBeCompacted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;expected&lt;/span&gt;  &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;actual&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;areStringEqual&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;解决隐藏的时间耦合（hidden temporal coupling），防止程序员不经意间因为调换执行顺序，导致不易发现的bug。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;findCommonPrefix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// change prefixIndex&lt;/span&gt;
&lt;span class="nx"&gt;findCommonSuffix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// use the prefixIndex that was assigned by the previous function&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="nx"&gt;findCommonPrefixAndSuffix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;findCommonPrefixAndSuffix&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 去掉了findCommonSuffix()，把先后顺序硬编码进该函数中&lt;/span&gt;
    &lt;span class="nx"&gt;findCommonPrefix&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// the content of previous findCommonSuffix()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;把复杂的for循环条件条件表达式和最后一个表达式抽成函数，或者重新定义循环变量，以简化。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 原代码略&lt;/span&gt;

&lt;span class="c1"&gt;// 改成&lt;/span&gt;

&lt;span class="c1"&gt;// 把循环变量由index -&amp;gt; length, 自定义suffixOverlapsPrefix和charFromEnd&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;suffixOverlapsPrefix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;charFromEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;
        &lt;span class="n"&gt;charFromEnd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suffixLength&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重构是一个迭代的过程，不断的尝试、出错、再尝试。而且经常会出现一种情况，就是，我们虽然刚刚重构了一些东西，但是由于发现了新的情况，我们要撤销之前重构的部分，以满足刚刚发现的情况需要进行的重构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本章所使用的例子，在重构之前就已经比较简洁和清晰了。但是任何代码都有改进的余地，而且我们有责任将遇到的代码修改的更好一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (4)</title><link href="http://particle128.com/posts/2014/12/cleanCode(4).html" rel="alternate"></link><updated>2014-12-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-13:posts/2014/12/cleanCode(4).html</id><summary type="html">&lt;h3&gt;Chapter12 Emergence&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;The majority of the cost of a software project is in long-term maintenance  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解析极限编程：拥抱变化（Extreme Programming Explained: Embrace Change）里列举了“简单设计”的四原则，优先级依次降低：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跑通所有的测试：单一原则的简洁代码，依赖更少的代码，&lt;strong&gt;更加可测&lt;/strong&gt;。所以，测试功能的同时，也能确保程序逐渐符合“低耦合高内聚”的面向对象目标。此外，也能让我们更加大胆的重构。&lt;/li&gt;
&lt;li&gt;没有重复：提取重复的部分组成新的方法/新的类，用模板办法把公共的部分提升到抽象父类中&lt;/li&gt;
&lt;li&gt;有表达力：一个软件工程耗费最多时间的是长期的维护，所以，选好的名字、让方法和类尽可能小、写单元测试。有句话叫：想象你代码的维护者是一个精神狂暴症患者，并且他知道你家在哪儿。&lt;/li&gt;
&lt;li&gt;尽可能减少类和方法的数量：按照CLEAN CODE的各种原则，应该会产生更多的类和方法，但是过犹不及，别拆的太细了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;掌握了这些原则可以节省很多年的探索，但是只有在实践中才能更深入的理解这些原则！！！&lt;/p&gt;
&lt;h3&gt;Chapter13 Concurrency&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并发解耦了“做什么”和“什么时候做”。单线程程序通过加断点，我们很明确的知道当时程序的状态，即执行到哪里了，将要执行到哪儿。但是，多线程并不是如此，多个线程的“什么时候做”并不能通过“做什么”推导出先后顺序。&lt;/li&gt;
&lt;li&gt;并发防卫原则&lt;br /&gt;
1.单一职责。让并发代码和其他代码分隔开。&lt;br /&gt;
2.限制共享数据的使用范围。减少临界区。&lt;br /&gt;
3.优先拷贝数据(线程独占)而不是共享数据，除非效率开销在当前应用场景下影响很大。&lt;br /&gt;
4.线程越独立越好，尽量不与其他线程扯上关系（比如共享数据之类的）。&lt;/li&gt;
&lt;li&gt;使用线程安全的集合，&lt;code&gt;java.util.concurrent&lt;/code&gt;下的&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;熟悉一些常用模型和解决方法：生产者消费者、读者写者、哲学家就餐。绝大多数遇到的兵法问题，都是这些模型的变形。&lt;/li&gt;
&lt;li&gt;尽量不要让一个共享对象有两个公共方法？？？？？解决方法：基于客户端的锁、基于服务器的锁、适配的服务器？？？？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试线程代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要把一些不常见的失败，当做一次性（one-off）的，研究它的原因。&lt;/li&gt;
&lt;li&gt;先测试代码的非线程版本，再测试线程，从而确定是逻辑错了，还是线程同步出错了。&lt;/li&gt;
&lt;li&gt;开辟多于处理器的线程数，易于暴露问题&lt;/li&gt;
&lt;li&gt;尽早在多个平台上运行，易于暴露问题（不同平台的线程策略不同，在一个平台上不常见的bug可能在另一个平台上经常发生）&lt;/li&gt;
&lt;li&gt;很多多线程bug不容易发现是因为，有太多可能的执行路径，或者常见路径的概率太高（比如两个相邻的语句看似原子的执行），导致发生不常见路径的概率很低。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动插入&lt;code&gt;yield()&lt;/code&gt;或&lt;code&gt;wait()&lt;/code&gt;或&lt;code&gt;sleep()&lt;/code&gt;或&lt;code&gt;priority()&lt;/code&gt;，改变执行顺序&lt;/li&gt;
&lt;li&gt;借助AOP，在测试时，随机插入这些语句之一，在生产代码中，插入空语句。如下所示：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//根据配置文件，随机插入不同的语句，或不插入语句&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;nextUrlOrNull&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hasNext&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urlGenerator&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;updateHasNext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;ThreadJigglePoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jiggle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cleanCode"></category></entry><entry><title>使用Smart HTTP的git服务器搭建过程</title><link href="http://particle128.com/posts/2014/12/git-server.html" rel="alternate"></link><updated>2014-12-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-13:posts/2014/12/git-server.html</id><summary type="html">&lt;p&gt;刚接手了老师的一个安卓项目，考虑到实验室闲置了一台PC，决定把这个pc配置成git服务器，用来进行版本控制。以为是分分钟钟的事儿呢，结果用了一整天才搞定。被网上残缺不全的新旧教程整懵了，决定自己写一个。&lt;/p&gt;
&lt;h3&gt;协议选择&lt;/h3&gt;
&lt;p&gt;git可以使用五种网络协议进行通信：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Local：团队成员用不同账户登录同一台电脑，或者共享一个挂载的NFS&lt;br /&gt;
语法：&lt;code&gt;git clone /opt/git/project.git&lt;/code&gt; 或 &lt;code&gt;git clone file:///opt/git/project.git&lt;/code&gt;&lt;br /&gt;
前者根据是否在同一个文件系统，选择硬链接或拷贝。后者类似网络传输，效率稍低。&lt;/li&gt;
&lt;li&gt;SSH：最常用的方式，使用简单，方便搭建，加密传输+访问认证&lt;br /&gt;
语法：&lt;code&gt;git clone ssh://user@server/project.git&lt;/code&gt; 或 &lt;code&gt;git clone user@server:project.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Git Protocol：最快的方式，但是没有认证功能&lt;/li&gt;
&lt;li&gt;HTTP：最兼容的方式，该协议一般不会被防火墙阻隔，有认证没加密&lt;br /&gt;
语法：&lt;code&gt;git clone http://server/project.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HTTPS：最安全的方式，加密+认证，但效率低（SSL的握手需要6步）&lt;br /&gt;
语法：&lt;code&gt;git clone https://server/project.git&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为学校封SSH的22端口，而且有一个同学在校外，排除了SSH协议。HTTPS协议太慢，我们的项目不需要加密数据，排除。GIT协议连认证都没有，太过简陋，排除。不同账户登录一台pc机远程办公，丧失了git作为分布式版本控制系统的优势，排除。&lt;/p&gt;
&lt;p&gt;最终，我决定用HTTP协议。用HTTP协议也有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dumb http  &lt;/li&gt;
&lt;li&gt;smart http&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;区别是，&lt;strong&gt;dumb http&lt;/strong&gt;模式中，如果get请求的文件在packfile中，只能请求整个packfile，即使你需要的只有其中的一个文件。另外一方面，&lt;strong&gt;smart http&lt;/strong&gt;模式中，在http服务器后面，又加了一层CGI，叫git-http-backend，它会像git或ssh协议那样，当请求到来后，把需要的文件，从各个packfile中抽取，然后组成一个自定义packfile后再传给客户端。&lt;/p&gt;
&lt;p&gt;故选择Smart HTTP。既然都用HTTP协议了，干脆把gitweb也配出来，方便通过浏览器查看git的版本库。下面是配置过程。&lt;/p&gt;
&lt;h3&gt;配置过程&lt;/h3&gt;
&lt;h4&gt;1、软硬件环境&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Pentium Dual-Core CPU，32 bits&lt;/li&gt;
&lt;li&gt;ubuntu 12.04 LTS&lt;/li&gt;
&lt;li&gt;apache 2.4.7&lt;/li&gt;
&lt;li&gt;git 1.9.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;apache2、git、gitweb的安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;gitweb&lt;/span&gt;
&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;apache2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2、创建git库&lt;/h3&gt;
&lt;p&gt;我选择在/srv/目录下创建一个bare repo，叫test.git，并把该目录下所有文件的所有者和组都改成www-data（apache2的默认所有者和默认组），以便apache2有权限访问它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;srv&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;bare&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;span class="n"&gt;chown&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3、配置apache2&lt;/h4&gt;
&lt;p&gt;apache2的总配置文件是/etc/apache2/apache2.conf，它会读取/etc/apache2/sites-enabled/下的配置文件。而该目录下的文件，一般是/etc/apache2/sites-available/下配置文件的软链接。&lt;/p&gt;
&lt;p&gt;打开/etc/apache2/apache2.conf，在最后添加如下内容。每条命令的解释，见注释。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# 默认apache2只对两个目录（/usr/share和/var/www）有访问权限，如下指令赋予apache2对/srv的访问权限。
&lt;span class="nt"&gt;&amp;lt;Directory&lt;/span&gt; &lt;span class="err"&gt;/srv&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    Options Indexes FollowSymLinks
    AllowOverride None
    Require all granted
&lt;span class="nt"&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;

# 如果没有这句，在其他机器上执行git clone等命令会返回403错误，参照最后一条“参考”
&lt;span class="nt"&gt;&amp;lt;Location&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    Options +ExecCGI
    Require all granted
&lt;span class="nt"&gt;&amp;lt;/Location&amp;gt;&lt;/span&gt;

# 设置git的工程目录
SetEnv GIT_PROJECT_ROOT /srv/
# 默认情况下，含有git-daemon-export-ok文件的目录才可以被导出（用作git库目录）。设置这个环境变量以便所有目录都可以被导出
SetEnv GIT_HTTP_EXPORT_ALL

# 虚拟主机，匹配80端口的任何ip地址的请求，访问gitweb
&lt;span class="nt"&gt;&amp;lt;virtualhost&lt;/span&gt; &lt;span class="err"&gt;*:80&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    # 顺便在/etc/hosts里添加上一句：127.0.0.1 git.example.com。这样，在服务器上可以通过该名字访问这个页面
    ServerName git.example.com
    DocumentRoot /usr/share/gitweb
    ErrorLog &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;APACHE_LOG_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/git_error.log
    CustomLog &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;APACHE_LOG_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/git_access.log combined
&lt;span class="nt"&gt;&amp;lt;/virtualhost&amp;gt;&lt;/span&gt;

# gitweb目录添加ExecCGI的功能
&lt;span class="nt"&gt;&amp;lt;Directory&lt;/span&gt; &lt;span class="err"&gt;/usr/share/gitweb&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Options FollowSymLinks ExecCGI
    AddHandler cgi-script .cgi
    DirectoryIndex gitweb.cgi
&lt;span class="nt"&gt;&amp;lt;/Directory&amp;gt;&lt;/span&gt;

# 对git库的各种请求，执行git-http-backend.cgi
ScriptAliasMatch \
    &amp;quot;(?x)^/(.*/(HEAD | \
    info/refs | \
    objects/(info/[^/]+ | \
     [0-9a-f]{2}/[0-9a-f]{38} | \
     pack/pack-[0-9a-f]{40}\.(pack|idx)) | \
    git-(upload|receive)-pack))$&amp;quot; \
    /usr/lib/git-core/git-http-backend/$1
# 其余的请求，执行gitweb.cgi
ScriptAlias / /usr/share/gitweb/gitweb.cgi

# 设置git push等操作的认证方式为文件认证，/var/www/git-auth后面会创建。
&lt;span class="nt"&gt;&amp;lt;LocationMatch&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;^/.*/git-receive-pack$&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    AuthType Basic
    AuthName &amp;quot;Git Access&amp;quot;
    Require valid-user
    AuthBasicProvider file
    AuthUserfile /var/www/git-auth
&lt;span class="nt"&gt;&amp;lt;/LocationMatch&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4、push操作的认证&lt;/h3&gt;
&lt;p&gt;默认git-http-backend的upload-pack是被置为真的，即可以执行git clone/pull/fetch。但是，默认receive-pack是被置为false，即不能git push。为了支持带认证的git push，需要两步操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;，打开/srv/test.git/config，添加如下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[http]&lt;/span&gt;
    &lt;span class="na"&gt;receivepack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果不加上面这句，git clone下来的版本库，git push时会提示403错误，即没有授权。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;，生成一个包含用户名和密码的文件，该文件能被apache2读取，作为文件认证的依据。假设我要添加两个用户mashu和ouyang，密码在提示下输入，我要执行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;
&lt;span class="n"&gt;htpasswd&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="n"&gt;mashu&lt;/span&gt;
&lt;span class="n"&gt;htpasswd&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="n"&gt;ouyang&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了这个文件，添加到上面的apache2的配置文件中即可。&lt;/p&gt;
&lt;h3&gt;5、gitweb的配置&lt;/h3&gt;
&lt;p&gt;修改/etc/gitweb.conf中的一句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;projectroot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/srv&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;6、重启apache2&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;apache2&lt;/span&gt; &lt;span class="n"&gt;restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;7、客户端检查&lt;/h3&gt;
&lt;p&gt;在客户端电脑上，找一个目录，执行如下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//server-ip/test.git test-repo&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;repo&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;first commit&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在浏览器上输入http://server-ip，查看刚才的操作是否记录到gitweb上了。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000"&gt;使用SSH协议的git服务器搭建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/book/en/v1/Git-on-the-Server"&gt;Git on the Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://git-scm.com/2010/03/04/smart-http.html"&gt;Smart Http&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.kernel.org/pub/software/scm/git/docs/git-http-backend.html"&gt;git-http-backend Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://bugs.launchpad.net/nav/+bug/1248205"&gt;bug:403 Forbidden on front page with apache 2.4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="git"></category></entry><entry><title>Clean Code (3)</title><link href="http://particle128.com/posts/2014/12/cleanCode(3).html" rel="alternate"></link><updated>2014-12-09T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-09:posts/2014/12/cleanCode(3).html</id><summary type="html">&lt;h3&gt;Chapter8 Boundaries&lt;/h3&gt;
&lt;p&gt;边界指的是第三方库和应用程序的边界。&lt;/p&gt;
&lt;p&gt;用包裹类，或适配器模式，来封装第三方代码（third-party code），可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;限制第三方代码的功能&lt;/li&gt;
&lt;li&gt;提供更一致和好用的接口&lt;/li&gt;
&lt;li&gt;减少受第三方代码改变带来的影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经常出现匪夷所思的bug，可能是由于第三方库导致的。所以，在使用之前应该做一个Learning Test（一遍学习文档，一遍写单元测试），确保我们需要的功能它都能正确提供。Learning Test好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帮助学习文档&lt;/li&gt;
&lt;li&gt;确保得到如期的结果，避免以后bug不知道从哪儿来&lt;/li&gt;
&lt;li&gt;第三方库版本更新后，继续用它测试是否符合预期（很多时候我们都不及时更新第三方库，因为我们怕更新后带来新的问题)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Chapter9 Unit Tests&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TDD（Test Driven Development）的三法则：写了失败的UT再写成产代码；一旦可以保证生产代码失败，就停止写UT；一旦生产代码通过了UT，就停止写生产代码。这样一轮循环大约30s。&lt;/li&gt;
&lt;li&gt;测试代码和生产代码一样重要，也要简洁、可读。因为如果一开始测试代码标准不高，随着生产代码的演化，阅读和修改单元测试的成本会非常高，高到一定程度，可能团队就抛弃测试了。引用一句里面的经典语录：&lt;blockquote&gt;
&lt;p&gt;Having dirty tests is equivalent to, if not worse than, having no tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;测试的好处：可以让代码更加可扩展、可靠。因为测试详尽的话，人们就不怕修改/重构代码。反之，人们将不敢改代码，因为怕引入没有检查到的bug。&lt;/li&gt;
&lt;li&gt;测试代码要简洁，把过多的细节抽象到函数中，让测试只呈现三个部分（每一部分1、2行代码）：建立测试数据、执行操作、检查结果——即BUILD-OPERATE-CHECK模式。&lt;/li&gt;
&lt;li&gt;测试的双重标准：像成产代码一样简洁，效率可以低于生产代码（可读性 &amp;gt; 效率）。&lt;/li&gt;
&lt;li&gt;一个测试函数，只包含一个assert（尽量做到），或只处理一个概念。&lt;/li&gt;
&lt;li&gt;测试遵循FIRST原则：&lt;br /&gt;
Fast：执行效率&lt;br /&gt;
Independent：不能相互依赖，应当可以独立运行每一个测试，而且可以以任何顺序运行这些测试！！！&lt;br /&gt;
Repeatable：不依赖环境，在任何情况（生产环境，QA环境，断网环境，甚至家里）可重现&lt;br /&gt;
Self-validating：应当返回布尔值，而不是打印log&lt;br /&gt;
Timely：及时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter10 Classes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当测试需要访问类的私有成员时，提升为package（外部测试）或protected（派生类测试）。只有在别无他法时，才可以这样做（这破坏/放松了封装）。&lt;/li&gt;
&lt;li&gt;类应当小：可以用大约25个词描述一个类，并且描述中不包括“如果”，“并且”，“或”，“但”；单一职责。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一职责经常被违背。  主要有两个原因：&lt;br /&gt;
1.仅仅让程序工作就满足了，并开始处理下一个问题，而不想着在类变得日益臃肿后，花心思将其拆开/解耦.&lt;br /&gt;
2.有一堆小的类，会比较难知道更大块的工作是如何实现的（需要在类之间跳来跳去）。  &lt;br /&gt;
实际上，在一个庞大的类中了解细节，和在多个简短的类中了解细节，需要移动的范围是一样大的，一个是函数间的跳转，一个是类间的跳转。但是，类一旦按照功能细分开来，开发者就可以根据自己的情况，选择不去了解一些更具体的东西，只掌握自己需要掌握的粒度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内聚性（cohesion）：类应该具有少量的实体变量，而且实体变量被越多的方法使用，类的内聚性越高。最理想的情况：所有实体变量被所有方法使用。因为这样的类成员更加相互依赖，更加紧凑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;拆分一个函数的过程，可能拆分出来多个类：函数太长 -&amp;gt; 拆出一个函数（含有4个参数） -&amp;gt; 因为参数太多，考虑提升为实体变量 -&amp;gt; 类多了四个、仅仅被一个方法使用的实体变量，内聚性差 -&amp;gt; 拆出一个类，包含这四个实体变量&lt;/li&gt;
&lt;li&gt;文中，Uncle Bob把Knuth的一个“产生素数”的算法拆成了3个，代码量长度多了一倍，但是却的确更好理解了。Knuth的代码需要加很多注释，但是Uncle Bob的代码已经自解释了。它里面的一些函数和变量的命名也让我大开眼界，原来名字这么长（最长的名字 &amp;gt; 40个字符），反而这么容易读懂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image" src="http://particle128.com/images/long_name.jpg" /&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了适应随时都会发生的变化（需求、演化），应该：&lt;br /&gt;
（1）用Single Responsibility Principal和Open Closed Principal来构造类（修改时，不用改原来的代码，只通过增加子类即可扩展）&lt;br /&gt;
（2）用接口/适配器模式来隔离具体类&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter11 Systems&lt;/h3&gt;
&lt;p&gt;本章，把构建软件系统，类比为建造城市：需要有一开始的规划，但是不可能一开始就了解到所有的细节，以及可能会发生的所有变化，所以要做一些接受变化的决策（面向方面编程）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;让应用程序（最高层抽象）和细节隔离开：(1)抽象工场模式，(2)依赖注入。&lt;/li&gt;
&lt;li&gt;将cross-cutting concern提取出来，使所有类都是模块化的POJO(Plain Old Java Object)，即面向切面编程（AOP）：(1)Java Proxies, (2) Spring或JBoss的AOP, (3)AspectJ&lt;/li&gt;
&lt;li&gt;准则：用可以解决问题的最简单的东西。比如，能用Spring就别用EJB2这类笨重和耦合度高的东西。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (2)</title><link href="http://particle128.com/posts/2014/12/cleanCode(2).html" rel="alternate"></link><updated>2014-12-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-06:posts/2014/12/cleanCode(2).html</id><summary type="html">&lt;h3&gt;Chapter5 Formatting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;你的代码可能随着版本的升级，逐渐被替换；但是你的代码风格/格式会被后继开发者一直传承下去。&lt;/li&gt;
&lt;li&gt;文件的长度：通常200行以内，最多500行&lt;/li&gt;
&lt;li&gt;C++类文件，通常遵循scissors rule，即上面是成员函数，下面是成员变量；java相反，上面是成员变量，下面是共有函数&lt;br /&gt;
根据Sun的&lt;a href="http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html"&gt;Code Convention for Java&lt;/a&gt;，类中的成员的顺序如下：&lt;br /&gt;
1.static成员变量：public -&amp;gt; protected -&amp;gt; package -&amp;gt; private&lt;br /&gt;
2.non-static成员变量：public -&amp;gt; protected -&amp;gt; package -&amp;gt; private&lt;br /&gt;
3.构造函数&lt;br /&gt;
4.成员函数：按照语义顺序，而不是访问级别&lt;/li&gt;
&lt;li&gt;一行不超过120个字符，可以设置屏幕字符宽度为120，是否需要向右滚动屏幕是判断是否超过行限制的方法（Sun Java Convention规定是80个字符）&lt;/li&gt;
&lt;li&gt;操作符之间的空格：*和/符号两边不加空格，+和-符号两边加空格，用优先级来区分更加清晰。&lt;/li&gt;
&lt;li&gt;常量应该出现在，对该常量有意义的高层函数，然后通过参数传递给低层函数，而不是直接定义在低层函数中。&lt;/li&gt;
&lt;li&gt;不建议声明变量和赋值语句的对齐，这会导致读者只注意看变量名或赋值的右值，而忽视类型或左值&lt;/li&gt;
&lt;li&gt;尽量避免空的代码块。即使是空的代码块，也要加上括号和适当缩进，比如（书中没给出正确的例子）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;but&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;readBufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// empty&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Chapter6 Objects and Data Structures&lt;/h3&gt;
&lt;p&gt;我理解文中所谓的Objects应该是指类。&lt;/p&gt;
&lt;p&gt;对象暴漏行为，而隐藏数据，很容易增加新的对象，而不改变已经存在的行为；但很难增加行为，因为增加行为需要改变所有对象的行为。数据结构暴露数据，没有重要的行为，很容易增加新的行为，而不改变已经存在的对象；但很难增加数据结构，因为增加对象意味着需要改变所有操作这些数据结构的函数。例子如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 数据结构&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*public member*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Geometry&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;double&lt;/span&gt; &lt;span class="n"&gt;area&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;NoSuchShapeException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt; &lt;span class="k"&gt;instance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;NoSuchShapeException&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// 对象&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Square&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Rectangle&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Circle&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Shape&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*private member and public method &amp;#39;area&amp;#39;*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// 用多态获取不同类型对象的面积&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;对象和数据结构，几乎有相反的特性，根据实际需要进行选择&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;得墨忒耳率（The Law of Demeter）&lt;/strong&gt;：一个模块不应该知道它所操纵的对象的内部结构。具体来说来，类C的一个方法f应该仅能访问如下类的方法：&lt;br /&gt;
1.C这个对象&lt;br /&gt;
2.f中定义的对象&lt;br /&gt;
3.f的参数对象&lt;br /&gt;
4.C的成员对象  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面这句话是违反该规则的，因为getOptions()返回的对象，不属于上面四类之一，调用它的getDir意味着知道该返回对象的内部结构（成员函数）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getOptions&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getDir&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePath&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;应该改成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePathOfDirOption&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getDirOption&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;getAbsolutePath&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 假设arg.getDirOption()返回的是数据结构，而不是对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;数据结构：成员变量是公有的，可能含有成员函数（构造函数，get函数...）。有时被称为DTO（Data Transfer Objects），与数据库或socket通信时常用到。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Chapter7 Error Handling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用异常，而不是错误码（errno或return code），可以让代码更清晰，分离异常处理和程序逻辑。这让我想到UNP的头文件，作者Steven封装了所有网络相关系统调用（connect -&amp;gt; Connect, listen -&amp;gt; Listen），才得以让异常处理不扰乱代码逻辑。&lt;/li&gt;
&lt;li&gt;先写单元测试，再写try-catch-finally块，最后写主体逻辑&lt;/li&gt;
&lt;li&gt;未检查的异常，好处是：限制你必须catch它。但是，这不是可靠程序的必要条件（C#,C++,Python,Ruby都没有），而且底层的一次改动（比如抛出新的异常了），会导致上面好几层的函数都要重新改写异常说明符（如果到了上面第n层才catch的话），这破坏了封装！&lt;/li&gt;
&lt;li&gt;抛异常的时候，只有调用堆栈还不够，尽量提供详细的上下文，比如抛出该异常时的局部变量、第几轮循环等。&lt;/li&gt;
&lt;li&gt;可以定义包裹类，来包裹第三方API，例如把原先抛出三种异常的代码，包裹之后只抛出一种异常。好处：&lt;br /&gt;
(1)减少依赖，即当第三方API更换时，你只需该wrapper，应用代码可以不动 &lt;br /&gt;
(2)测试时方便模拟出第三方库的调用...&lt;strong&gt;啥意思???? &lt;/strong&gt; &lt;br /&gt;
(3)设计一组更符合自己使用习惯的新的接口&lt;/li&gt;
&lt;li&gt;一种场景，定义一个异常类就行了，可以通过错误信息来区分不同错误。使用多种异常类的情况：你想捕获一种异常，而放行另一种异常！！！&lt;/li&gt;
&lt;li&gt;不要用异常应付正常现象的特殊情况，用SPECIAL CASE PATTERN&lt;/li&gt;
&lt;li&gt;不要返回null，会导致太多null检查，且容易漏掉检查。用异常，或special case object（比如空列表）&lt;/li&gt;
&lt;li&gt;不要传入null，因为如果可能接收null，需要做异常处理（抛出InvalidArgumentException异常，再catch）。。。&lt;strong&gt;我感觉很多时候都没法避免啊，如果其他程序员调用该函数的时候传入null了咋办？？？放着不管？？？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>Clean Code (1)</title><link href="http://particle128.com/posts/2014/12/cleanCode(1).html" rel="alternate"></link><updated>2014-12-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-12-05:posts/2014/12/cleanCode(1).html</id><summary type="html">&lt;h3&gt;Chapter1 Clean Code&lt;/h3&gt;
&lt;p&gt;通过一个“坏代码毁了一个初创公司”的例子，讲了messy code的危害，不禁让我想到VPC的第一版。然后，列举了多个名人对clean code的推崇和理解，这些名人包括C++之父、UML创始人、程序员修炼之道作者、wiki之父...&lt;/p&gt;
&lt;h3&gt;Chapter2 Meaningful Names&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用表明意义（intention-revealing）的名字，而不是简单的名字+注释。比如&lt;code&gt;elapsedTimeInDays&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免误导信息（disinformation）。尽量少自己定义缩略形式，如果不是List别用&lt;code&gt;accountList&lt;/code&gt;（用&lt;code&gt;accounts&lt;/code&gt;,或&lt;code&gt;bunchOfAccounts&lt;/code&gt;,或&lt;code&gt;accountGroup&lt;/code&gt;），别用小写的l和大写的O&lt;/li&gt;
&lt;li&gt;做有意义的区分。避免用&lt;code&gt;a1,a2,..&lt;/code&gt;来区分多个同类元素，避免用&lt;code&gt;a,an,the,data,info&lt;/code&gt;修饰变量名，来做字面的区分&lt;/li&gt;
&lt;li&gt;用可以发出音的名字。别用&lt;code&gt;genymdhms (generation year,mon,day,hour,min,sec)&lt;/code&gt;，换成&lt;code&gt;generationTimestamp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用可搜索的名字。魔数不要用，简单的单字母变量少用。名字的长度应该对应它所在作用域的大小，即短名字仅可以出现在很小的作用域上，比如for循环中的&lt;code&gt;i,j,k&lt;/code&gt;，意义明确的短小函数中的&lt;code&gt;sum&lt;/code&gt;。当然，如果有很好表示的明确意义，还是用有意义的变量来代替&lt;code&gt;i,j,k&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不需要加类似&lt;code&gt;m_&lt;/code&gt;的前缀&lt;/li&gt;
&lt;li&gt;接口不要用&lt;code&gt;IShapeFactory&lt;/code&gt;，直接用&lt;code&gt;ShapeFactory&lt;/code&gt;，然后使用&lt;code&gt;ShapeFactoryImp&lt;/code&gt;。目的：用户不需要关心自己处理的是接口还是实现，名字中暴漏更少的信息。&lt;/li&gt;
&lt;li&gt;类名，名词或名词短语，避免添加&lt;code&gt;Manager,Processor,Data,Info&lt;/code&gt;这类没信息量的名字&lt;/li&gt;
&lt;li&gt;方法名，动词或动词短语&lt;/li&gt;
&lt;li&gt;如果能用解决方案域的名字（Solution Domain Names），就不用问题域的名字（Problem Domain Names），因为这样更容易让程序员理解，而不需要首先咨询专业人员。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;起名是一件很难的事情，需要不断练习。要在开发、测试和维护中，修改代码中欠佳的名字，别担心这会让其他人困惑，这是非常值得的。&lt;/p&gt;
&lt;h3&gt;Chapter3 Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个函数应当短到只有2~4行，缩进级别不应该超过两层（即，最多两重循环）&lt;/li&gt;
&lt;li&gt;一个函数只做一件事。界定的两种方法：&lt;br /&gt;
(1) 能否用一个TO语句描述，看描述出来是否在同一个抽象层次 (2) 能不能从一个函数中提取出另一个不同名的函数&lt;/li&gt;
&lt;li&gt;函数在源文件中的顺序：上面的函数引用下面的函数。&lt;/li&gt;
&lt;li&gt;不应该在代码中出现switch语句，switch结构肯定会很长。用抽象工场（可以包含switch，以便根据另一个对象的类型或根据一个字符串，决定创建什么类）+多态（根据类型动态选择对应的函数）替代。&lt;/li&gt;
&lt;li&gt;给函数起一个描述性的名字，比如&lt;code&gt;includeSetupAndTeardownPages&lt;/code&gt;。别怕长：长的描述性名字，好于短的不明其意的名字，好于长的描述性注释。别怕花时间选取名字+改动：现代IDE很容易全局替换名字，改名也常常带来有价值的重构代码。&lt;/li&gt;
&lt;li&gt;函数参数尽量少，不要超过3个参数。参数越少，越利于函数的理解和测试(需要测试参数的所有组合)。&lt;/li&gt;
&lt;li&gt;单参函数尽量保持三种形式之一，其余形式要考虑是不是需要重构：1、关于参数的一个判断，如&lt;code&gt;fileExists&lt;/code&gt;；2、将参数转换成别的，如&lt;code&gt;fileOpen&lt;/code&gt;；3、参数引起了一个事件，无返回值，如&lt;code&gt;passwordAttemptFailedNtimes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不要传标记（boolean类型），这显然违背了“只做一件事”原则，因为它至少做了两件事（true时..false时..）。在上层用if判断，然后调用不同函数，比如&lt;code&gt;renderForSuite()&lt;/code&gt;和&lt;code&gt;renderForNonSuite()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数不要有副作用（side effect），比如改变成员变量，改变全局变量，改变参数，等。如需改变，写在名字上，或拆成两个函数&lt;/li&gt;
&lt;li&gt;不要值-结果参数，容易让人迷惑，需要再去看函数原型——double-take(再看一眼)&lt;/li&gt;
&lt;li&gt;优先使用异常，而不是错误码，防止混合错误处理逻辑和正常逻辑，进而导致代码不清晰。把可能出现异常的语句放到一个函数中，单独定义一个，仅仅包含try-catch-finally的函数，调用前面的函数——错误处理和正常逻辑分开。&lt;/li&gt;
&lt;li&gt;用异常层次结构，而不是错误码（error class/enum，其他类需要import），解决&lt;code&gt;dependency magnet&lt;/code&gt;，即增加新的异常/错误时，不需要重新编译和部署&lt;/li&gt;
&lt;li&gt;一开始先写出长的、复杂的、有重复的、随意命名的函数，之后再按照本章的方法拆分和提炼。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;目标是，写源代码，就像写小说，函数调用的意义都很清晰，让读者读起来很流畅，不需要跳到函数原型甚至函数注释或源码中才能理解。&lt;/p&gt;
&lt;h3&gt;Chapter4 Comments&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;写注释前，仔细考虑能否把注释的东西表达在代码里。因为，注释非常容易do evil（因为没能随着代码进行更新）。&lt;/li&gt;
&lt;li&gt;很多时候，写一个函数就可以免去注释了，比如&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// check to see if the the employee is eligible for full benefits&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="no"&gt;HOURLY_FLAG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mh"&gt;65&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;应当改成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;employee&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isEligibleForFullBenefits&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;加注释的时机：&lt;br /&gt;
1.版权声明(&lt;code&gt;all rights reserved&lt;/code&gt;)
2.提供信息&lt;br /&gt;
3.解释意图&lt;br /&gt;
4.澄清意思&lt;br /&gt;
5.警告可能的结果&lt;br /&gt;
6.善用TODO注释和javadoc&lt;/li&gt;
&lt;li&gt;不要加这类注释：&lt;br /&gt;
1.冗余的注释（从函数名或函数本身，很容易知道函数的意图）&lt;br /&gt;
2.关闭括号的注释（语句太多才需要关闭括号注释，考虑拆开它）&lt;br /&gt;
3.注释掉的代码、标注代码修改者、标注代码修改记录（这类可以用版本控制软件如git来杜绝）&lt;br /&gt;
4.太多信息的注释（简要描述，提到关键字即可，别长篇大论）&lt;/li&gt;
&lt;/ul&gt;</summary><category term="cleanCode"></category></entry><entry><title>微软校招在线测试</title><link href="http://particle128.com/posts/2014/10/msOnlineTest.html" rel="alternate"></link><updated>2014-10-22T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-10-22:posts/2014/10/msOnlineTest.html</id><summary type="html">&lt;p&gt;前三题都不难，但我第一题没考虑完全就写了，corner case调试了太久(1.5h才AC)，只留给第三题了0.5h，最终没有提交上去，仅仅AC了两道题。逆序总结一下这三道题吧。&lt;/p&gt;
&lt;h3&gt;题目3 : String Matching Content Length&lt;/h3&gt;
&lt;p&gt;题目： &lt;a href="http://hihocoder.com/contest/mstest2015oct/problem/3"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路：两轮DP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;很容易想到这是“最长公共子串”的变形，所以，第一步是实现最长公共子串，用DP，得到一个二维数组len[m][n]。&lt;/li&gt;
&lt;li&gt;要求“最长的匹配子串集的总长度”，最简单的方法是DFS。即从上一步得到的len的最下角开始，向左、向上查找，直到找到第一个len[i][j]&amp;gt;=3；之后，查找的范围被限制在0~i-len[i][j]和0~j-len[i][j]之间，继续从右下角开始，向左、向上查找...直到左上角。这样就找到了一个“匹配子串集”。用这种方法，可以找到所有“匹配子串集”，取最小的即可。&lt;/li&gt;
&lt;li&gt;上一步提到的方法，可能出现重复计算，最坏复杂度是指数级的，故考虑DP，状态转移方程略。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a.size&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;b.size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// len[i][j] means the max matching length of a and b that end at i-1 and j-1 respectively&lt;/span&gt;
    &lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;n&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; 
    &lt;span class="nb"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nb"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nb"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; == b&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;) {
                len&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; = len&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; + 1;
            }
        }
    }
    // maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; means the max length of maching contents of a and b that end at i-1 and j-1 respectively
    vector&lt;span class="nt"&gt;&amp;lt;vector&lt;/span&gt;&lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="na"&gt;int&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; &amp;gt; maxLen(m+1, vector&lt;span class="nt"&gt;&amp;lt;int&amp;gt;&lt;/span&gt;(n+1, 0));
    for (int i = 1; i &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;= m; ++i) {
        for (int j = 1; j &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;= n; ++j) {
            maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; = max(maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;, maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;);
            if (len&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &amp;gt;= 3) {
                for (int k = 3; k &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;= len&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;; ++k) {
                    maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; = max(maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;, maxLen&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="na"&gt;-k&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="na"&gt;-k&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; + k);
                }
            }
        }
    }
    cout &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt; maxLen&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="cp"&gt;][&lt;/span&gt;&lt;span class="nb"&gt;n&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="na"&gt;endl&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;
    &lt;span class="na"&gt;return&lt;/span&gt; &lt;span class="na"&gt;0&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;题目2 : Performance Log&lt;/h3&gt;
&lt;p&gt;题目：&lt;a href="http://hihocoder.com/contest/mstest2015oct/problem/2"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈模拟函数调用序列，栈中保存数组的下标，在数组中保存实际函数名和时间（进栈时保存开始时间，退栈时保存持续时间）。&lt;/li&gt;
&lt;li&gt;进栈顺序就是调用图的dfs顺序，所以，最后顺序打印数组内容即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;struct&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;inline&lt;/span&gt; &lt;span class="nx"&gt;bool&lt;/span&gt; &lt;span class="nx"&gt;changeTime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;record&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;record&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start_sec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;start.h&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;start.m&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;start.s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end_sec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;end.h&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;end.m&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;end.s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;end_sec&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nx"&gt;start_sec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;gap&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;start.s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gap&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;gap&lt;/span&gt;&lt;span class="o"&gt;/=&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;start.m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gap&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;start.h&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;gap&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;60&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;ncase&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;ncase&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;action&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;char&lt;/span&gt; &lt;span class="nx"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;record&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ncase&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;tmp&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;action&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
            &lt;span class="nb"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;record&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;START&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;stk.push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nx"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="nx"&gt;vec.push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;re&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;stk.size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nx"&gt;vec&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;stk.top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;.fun != fun) {
                error = true;
                continue;
            }
            if (changeTime(vec&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;stk.top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;, re) == false) {
                error = true;
                continue;
            }
            stk.pop();
        }
    }
    if (error || !stk.empty()) {
        cout &lt;span class="err"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &amp;quot;Incorrect performance log&amp;quot; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt; endl&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt; &lt;span class="na"&gt;else&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="na"&gt;for&lt;/span&gt; &lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;int&lt;/span&gt; &lt;span class="na"&gt;i =&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="s"&gt;0;&lt;/span&gt; &lt;span class="na"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="na"&gt;vec&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="err"&gt;();&lt;/span&gt; &lt;span class="err"&gt;++&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="na"&gt;printf&lt;/span&gt;&lt;span class="err"&gt;(&amp;quot;%&lt;/span&gt;&lt;span class="na"&gt;s&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="na"&gt;02d:&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="na"&gt;02d:&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="na"&gt;02d&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="na"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;,&lt;/span&gt; &lt;span class="na"&gt;vec&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fun&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;c_str&lt;/span&gt;&lt;span class="err"&gt;(),&lt;/span&gt; &lt;span class="na"&gt;vec&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;h&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="na"&gt;vec&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;m&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="na"&gt;vec&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;s&lt;/span&gt;&lt;span class="err"&gt;);&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="na"&gt;return&lt;/span&gt; &lt;span class="na"&gt;0&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;题目1 : Beautiful String&lt;/h3&gt;
&lt;p&gt;题目：&lt;a href="http://hihocoder.com/contest/mstest2015oct/problem/1"&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路：状态机转换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据太大，只能一个字符一个字符的读入。&lt;/li&gt;
&lt;li&gt;循环中维持4个变量&lt;br /&gt;
cnt 正在处理的字符是beatiful string中的第几个元素，范围0~3&lt;br /&gt;
cur 正在处理的字符&lt;br /&gt;
ncur 正在处理的字符累计数量&lt;br /&gt;
nprev beautiful string中上一个元素的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一开始没考虑到的case：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;aaaabbcc&lt;/li&gt;
&lt;li&gt;aaaabbbccde&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ncase&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ncase&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ncase&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cin&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;ncur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nprev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// restart&lt;/span&gt;
                        &lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;nprev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// ncur &amp;lt;= nprev !!!&lt;/span&gt;
                        &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// restart&lt;/span&gt;
                        &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                    &lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ncur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;nprev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ncur&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;nprev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// over  cnt&amp;gt;=3 !!!&lt;/span&gt;
                    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;YES&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;NO&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="algorithm"></category></entry><entry><title>UNP部分知识小结</title><link href="http://particle128.com/posts/2014/10/unp.html" rel="alternate"></link><updated>2014-10-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-10-14:posts/2014/10/unp.html</id><summary type="html">&lt;p&gt;找工作期间，复习了一遍Unix Network Programming，对部分知识进行一下总结。&lt;/p&gt;
&lt;h3&gt;基础&lt;/h3&gt;
&lt;p&gt;编写基于网络通信的程序，就是网络编程。通信的发起方是客户，响应客户的是服务器，比如浏览器是客户（发出GET，POST等请求给服务器），web server是服务器。  &lt;/p&gt;
&lt;p&gt;套接字对是一个四元组，（local ip, local port, remote ip, remote port），通过这一四元组，唯一确定了网络通信的两端（两个进程），ip地址确定主机，端口确定进程。  &lt;/p&gt;
&lt;p&gt;TCP比UDP复杂，体现在TCP两端维护状态机（11个状态），UDP则不需要。&lt;/p&gt;
&lt;p&gt;UDP中，客户用socket创建套接字之后，就可以用sendto和recvfrom和服务器通信了。&lt;/p&gt;
&lt;p&gt;TCP客户存在一种套接字：主动套接字。基本调用序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket 创建套接字，默认是主动套接字&lt;/li&gt;
&lt;li&gt;connect  指定套接字对的远端ip和端口，分配套接字发送和接收缓冲区。向服务器套接字地址发起连接，进入SYN_SENT，返回时进入ESTABLISED。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP服务器存在两种套接字：被动套接字、主动套接字。基本调用序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket  创建套接字&lt;/li&gt;
&lt;li&gt;bind  指定套接字对的本端ip和端口&lt;/li&gt;
&lt;li&gt;listen  使套接字变成被动套接字/监听套接字，分配未完成和已完成连接队列。进入LISTEN&lt;/li&gt;
&lt;li&gt;accept  等待已完成连接队列中的元素，返回主动套接字/已连接套接字&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;套接字分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sockaddr_in IPv4套接字&lt;/li&gt;
&lt;li&gt;sockaddr_in6 IPv6套接字&lt;/li&gt;
&lt;li&gt;sockaddr 通用套接字，用于强制类型转换&lt;/li&gt;
&lt;li&gt;sockaddr_storage 通用套接字，用于分配空间&lt;/li&gt;
&lt;li&gt;sockaddr_un Unix域套接字&lt;/li&gt;
&lt;li&gt;sockaddr_dl 数据链路套接字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ubuntu12.04下，定义各类套接字的头文件位置，见下图：&lt;br /&gt;
&lt;img alt="image1" src="http://particle128.com/images/sockets.bmp" /&gt;&lt;/p&gt;
&lt;h3&gt;connect出错分类&lt;/h3&gt;
&lt;p&gt;connect函数会向对方发送SYN，主动建立TCP连接，可能遇到3种错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ETIMEOUT&lt;br /&gt;
超时重传了几次之后，仍然没有收到任何响应。比如网络拥塞（主机或路由器的输入队列满了，丢弃新来的数据包）导致SYN或SYN ACK丢失，或者服务器主机崩溃但连接该主机的路由器还没有检测出来（否则会报告EHOSTUNREACH或ENETUNREACH）。&lt;/li&gt;
&lt;li&gt;ECONNREFUSED&lt;br /&gt;
收到服务器TCP层发送的RST。比如connect要连接的端口上没有监听进程。&lt;/li&gt;
&lt;li&gt;EHOSTUNREACH或ENETUNREACH&lt;br /&gt;
收到中间路由器发送的ICMP错误。比如connect要连接的IP地址不可达（没有在路由器的路由表中出现，或超过跳数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;产生RST的条件&lt;/h3&gt;
&lt;p&gt;RST分节是一种特殊的TCP分节，该分节的TCP首部中RST标识被置1，一般不包含数据。有如下三种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器进程。&lt;br /&gt;
服务器发送RST（p80 connect返回ECONNREFUSED）&lt;/li&gt;
&lt;li&gt;TCP想取消一个已建立的连接。&lt;br /&gt;
客户发送RST（p112 accept返回ECONNABORTED）&lt;/li&gt;
&lt;li&gt;TCP接收到一个根本不存在的连接上的分节（已连接套接字中，没有匹配的对端ip和端口）。&lt;br /&gt;
谁接到，谁发送RST（p113 如果EOF之前收到RST，则read返回ECONNRESET）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;简单回射客户/服务器程序异常情况&lt;/h3&gt;
&lt;p&gt;回射客户逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gets从终端读入一行&lt;/li&gt;
&lt;li&gt;write把这一行写入socket&lt;/li&gt;
&lt;li&gt;read从socket读入服务器发回的数据&lt;/li&gt;
&lt;li&gt;puts把这一行打印到终端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回射服务器逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read从socket读入数据&lt;/li&gt;
&lt;li&gt;write向socket发送刚才读入的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户和服务器可能遇到的异常情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户：在服务器还没有accept相应的已连接套接字时，客户就发送RST到服务器端，主动取消连接。 
这时候accept返回ECONNABORTED错误。应该忽略该错误，再次调用accept&lt;/li&gt;
&lt;li&gt;服务器：accept系统调用被系统中断（比如子进程退出，内核向父进程发送SIGCHLD信号）。&lt;br /&gt;
这时候accept返回EINTR错误。应该忽略该错误，再次调用accept&lt;/li&gt;
&lt;li&gt;服务器：进程终止（kill）或服务器主机关机(shutdown)。内核自动close套接字，发送FIN到客户端之后，关闭进程。&lt;br /&gt;
这时候write可以执行（对方回应RST），readline返回0(收到FIN)或ECONNRESET(收到RST)。&lt;br /&gt;
收到RESET之后再调用一次write，write自己返回EPIPE错误，内核向进程发出SIGPIPE信号，中止进程。&lt;/li&gt;
&lt;li&gt;服务器：主机崩溃。&lt;br /&gt;
这时候write可以执行，readline会阻塞一段时间，如果没响应则返回ETIMEOUT，如果收到ICMP错误则返回EHOSTUNREACH或ENETUNREACH。&lt;/li&gt;
&lt;li&gt;服务器：主机崩溃后重启。&lt;br /&gt;
这时候write可以执行，write过来的数据分节返回RST（不存在的连接上的分片），readline会返回ECONNRESET。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;TCP可靠性如何保证&lt;/h3&gt;
&lt;p&gt;TCP与UDP的不同点是，它是面向连接的，有可靠性（不丢失、不重复、不失序）保证。要做到可靠性，不一定要面向连接，比如基于udp的qq就在无连接的udp之上，增加了可靠性保证。&lt;/p&gt;
&lt;p&gt;那TCP是如何在面向连接的基础上，保证可靠性的呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ACK、超时重传 ——&amp;gt; 不丢失&lt;/li&gt;
&lt;li&gt;序列号 ——&amp;gt; 不重复&lt;/li&gt;
&lt;li&gt;序列号 ——&amp;gt; 不失序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下内容，并不是必不可少的，但是却能保证TCP在一些特殊情况下，更加可靠，而不是灾难性的无法通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量控制 ——&amp;gt; 防止发送过多的数据，接收端丢弃超出接收缓冲区能力的分节，而导致过多次超时重传&lt;/li&gt;
&lt;li&gt;拥塞控制 ——&amp;gt; 防止整个网络上过多的分节，而导致所有分节都超时（路由器输入队列早就被挤满了）&lt;/li&gt;
&lt;li&gt;时间戳 ——&amp;gt; 防止某些网络中通信速度太快，序列号很快用尽并被再次使用时出现重复。&lt;/li&gt;
&lt;li&gt;动态估算RTT ——&amp;gt; 动态修改RTT的内容，保证超时时间更加准确。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IO模型&lt;/h3&gt;
&lt;p&gt;IO模型，调用方式，说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞式IO  &lt;br /&gt;
read/readv/recv/recvfrom/recvmsg,write/writev/send/sendto/sendmsg&lt;br /&gt;
阻塞进程，直到读/写到用户buffer结束&lt;/li&gt;
&lt;li&gt;非阻塞IO&lt;br /&gt;
fcntl设置描述符为O_NONBLOCK；recvXX和sendXX这两种函数，可以设置单次非阻塞&lt;br /&gt;
当读不到（接收缓冲区中的数据没达到RECV_WATER_MARK）或写不成（发送缓冲区中的空闲空间没到SEND_WATER_MARK），会返回E_WOULDBLOCK  &lt;/li&gt;
&lt;li&gt;IO复用&lt;br /&gt;
传统select/poll，现在epoll/kqueue&lt;br /&gt;
阻塞等待多个描述符，直到有至少一个就绪，即可读、可写、异常（有带外数据）&lt;/li&gt;
&lt;li&gt;信号驱动式IO&lt;br /&gt;
fcntl设置描述符为O_ASYNC&lt;br /&gt;
当数据就绪，内核会递交SIGIO给用户，用户可以在信号处理程序中读数据或写数据&lt;/li&gt;
&lt;li&gt;异步IO&lt;br /&gt;
aio_read/aio_write&lt;br /&gt;
当数据已经写入内核缓冲区或已经读到用户buffer，递交信号给用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IO超时的设置&lt;/h3&gt;
&lt;p&gt;如下方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alarm定时&lt;br /&gt;
不精确&lt;/li&gt;
&lt;li&gt;SO_RCVTIMEO，SO_SNDTIMEO&lt;br /&gt;
只能用于socket，不能用于connect&lt;/li&gt;
&lt;li&gt;select设置超时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;非阻塞IO分类&lt;/h3&gt;
&lt;p&gt;非阻塞IO通常和epoll一起使用。因为你总要知道何时可以进行真正的IO，所以只可以轮询或IO复用。如果轮询，浪费CPU，还不如阻塞方式好。 &lt;/p&gt;
&lt;p&gt;epoll配合非阻塞，可以防止虽然epoll返回的就绪描述符里有它，但是可能在执行的时候并不真正就绪，导致一直阻塞在那个描述符下。这种情况是可能出现的。比如多个线程同时调用epoll_wait等待同一组描述符，当一个描述符可读的时候，多个线程可能同时唤醒（epoll电平触发的情况下会发生，被称为“惊群”）。但只有第一个执行的线程可以read到数据，其他线程读不到。&lt;/p&gt;
&lt;p&gt;虽然非阻塞用在IO复用上更快，但因为读到的数据不一定能一次发送完，所以接收缓冲区需要维护两个指针。同理发送缓冲区。因此，逻辑要复杂一些。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞read&lt;/li&gt;
&lt;li&gt;非阻塞write&lt;/li&gt;
&lt;li&gt;非阻塞connect  节省CPU时间，设置connnect超时(默认75s才返回ETIMEOUT)，并发发起多个连接&lt;/li&gt;
&lt;li&gt;非阻塞accept  防止epoll返回后、accept调用前，某个连接被RST取消，然后accept一直阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;广播和多播的区别&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;广播&lt;/em&gt; &lt;/p&gt;
&lt;p&gt;包括链路层广播和IP层广播。假设是MAC协议，链路层广播地址为ff:ff:ff:ff:ff:ff（全1），IP层广播地址为主机号全1，或子网+主机号全1。只能用于UDP或IP。&lt;/p&gt;
&lt;p&gt;IP层广播分节，链路层MAC地址必须是全1的地址。保证局域网中的其他计算机，在接到该广播分节之后，数据链路层能正常向上层交付而不是丢弃。&lt;/p&gt;
&lt;p&gt;意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源发现&lt;br /&gt;
发现自己的IP地址（DHCP）、发现某个IP地址的MAC地址（ARP）&lt;/li&gt;
&lt;li&gt;减少局域网分组&lt;br /&gt;
广播就需要一个分节；向局域网中的每个主机单播，需要主机数量的分节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARP 链路层广播&lt;/li&gt;
&lt;li&gt;DHCP IP层广播，全1&lt;/li&gt;
&lt;li&gt;NTP（网络时间协议，广播服务器时间）&lt;/li&gt;
&lt;li&gt;routed（路由守护进程，广播路由表）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;多播&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;使用D类地址，加入多播组的主机，在接到多播组号等于自己所加入的组的组号时，会接收该分节。只能用于UDP或IP。&lt;/p&gt;
&lt;p&gt;多播可以替代广播，有资源发现和减少分组的优势。同时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以跨越局域网 （使用D类地址，不受限于局域网）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，IPv6不支持广播，只支持多播，多播相当于广播的替代方案。&lt;/p&gt;
&lt;h3&gt;客户/服务器编程范式&lt;/h3&gt;
&lt;p&gt;以回射客户/服务器程序为例。相对于现代服务器的范式而言，有些范式稍微过时一些，但至少提供一种思路。&lt;/p&gt;
&lt;p&gt;客户编程范式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;停等方式&lt;br /&gt;
缺点：看不到对端关闭连接、批处理效率低（需要很快发送一堆数据，但是很久才会读到数据）&lt;/li&gt;
&lt;li&gt;阻塞select方式（等待gets和read就绪）&lt;/li&gt;
&lt;li&gt;非阻塞select方式（等待gets,puts,read,write就绪）&lt;/li&gt;
&lt;li&gt;fork方式（父进程gets+write，子进程read+puts）&lt;/li&gt;
&lt;li&gt;pthread方式（类似）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器编程范式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iterative（只适合udp）&lt;/li&gt;
&lt;li&gt;multi-process（可用preforking）&lt;/li&gt;
&lt;li&gt;multi-thread（可用prethreading）&lt;/li&gt;
&lt;li&gt;select&lt;/li&gt;
&lt;/ul&gt;</summary><category term="linux"></category></entry><entry><title>MySQL存储过程中变量名不能和列名相同</title><link href="http://particle128.com/posts/2014/09/MySQL-bug.html" rel="alternate"></link><updated>2014-09-30T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-09-30:posts/2014/09/MySQL-bug.html</id><summary type="html">&lt;p&gt;鞍山项目，追到北京来折磨我了。&lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;专家评审部分，需要提交意见和各个指标的分数，&lt;em&gt;有一个&lt;/em&gt;专家评审的意见保存在了数据库，但是分数没有保存进去。  &lt;/p&gt;
&lt;p&gt;评审专家系统里，打分的表格是前端js动态绘制的。专家提交打分情况的时候，把分数保存在HiddenField里上传服务端。因为不知道客户浏览器的情况，推测:  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表格没有绘制成功。js绘制表格的语句不被浏览器支持，所以客户端直接看不到打分表格。&lt;/li&gt;
&lt;li&gt;分数没有提交成功。因为HiddenField实质是type="hidden"的input标签元素，它可以随表单一起提交给服务器。或许那个专家用的浏览器不支持hidden input标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决办法就是在服务器端对HiddenField提交上来的数据，进行检测，如果发现为空或者不合法，就提示用户换浏览器尝试。最初代码中没有检测数据为空，是因为前端写了js代码，保证分数都填写完毕才会提交表单。但是如果遇到推测的第2种情况，就会检测不出来。&lt;/p&gt;
&lt;h3&gt;修改数据库&lt;/h3&gt;
&lt;p&gt;代码改完，并没有万事大吉。因为数据库丢数据了，需要手动订正。&lt;/p&gt;
&lt;p&gt;大约1、2年前用过存储过程，不过太久远了，又去&lt;a href="http://dev.mysql.com"&gt;MySQL官网&lt;/a&gt;上浏览了一下相关文档。写的过程中遇到了些问题，简单记录下。&lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="c1"&gt;//&lt;/span&gt;

&lt;span class="n"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;insert_rows&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sheetid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;groupid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expertid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt; &lt;span class="n"&gt;DEFAULT&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemScore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;projID&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt; &lt;span class="n"&gt;CURSOR&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ItemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ItemScore&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;sheetitem&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;SheetID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sheetid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt; &lt;span class="n"&gt;CURSOR&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ProjID&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;projstate&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;GroupID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;groupid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;CONTINUE&lt;/span&gt; &lt;span class="n"&gt;HANDLER&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;NOT&lt;/span&gt; &lt;span class="n"&gt;FOUND&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;OPEN&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;item_loop:&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
        &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;FETCH&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemScore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemScore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt;
            &lt;span class="n"&gt;LEAVE&lt;/span&gt; &lt;span class="n"&gt;item_loop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;OPEN&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;proj_loop:&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
            &lt;span class="n"&gt;FETCH&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;projID&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="n"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt;
                &lt;span class="n"&gt;LEAVE&lt;/span&gt; &lt;span class="n"&gt;proj_loop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;projID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expertid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemScore&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;expertscore&lt;/span&gt; &lt;span class="nf"&gt;values&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;projID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expertid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;itemScore&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;CLOSE&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CLOSE&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;delimiter语句，临时把分号结束符改成双斜杠结束符，保证存储过程作为一个整体被mysql读入，否则mysql会在分号结束的地方断句，并进行解释执行，报错&lt;code&gt;syntax error: unexpected end_of_input&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQL中没有所谓数组类型，所以不能通过&lt;code&gt;select xx from xx where xx into results&lt;/code&gt;这种形式，用变量来保存多条记录。可以通过加&lt;code&gt;limit [offset,]len&lt;/code&gt;来限制只输出一行，保存到对应的变量中。&lt;/li&gt;
&lt;li&gt;没有数组，只能通过游标实现遍历。&lt;/li&gt;
&lt;li&gt;SQLSTATE是MySQL内部状态，过去叫error code。每次执行一句mysql，都会设置SQLSTATE，类似Unix下的errno。&lt;/li&gt;
&lt;li&gt;游标结束的条件，就是获取不到新的行，即'NOT FOUND'，对应错误码是'02000'。所以用一个continue handler来捕获这个事件，在这个事件中设置done变量，然后检查该变量判断是否需要退出循环。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;遇到坑&lt;/h3&gt;
&lt;p&gt;这个存储过程执行没有错误，但是并没有插入数据，通过注释部分的select取出的数据发现，变量全是null。  &lt;/p&gt;
&lt;p&gt;google了一下，发现了问题所在：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You should avoid using the same name for multiple different things. Specifically, give the variable a different name than the column you are selecting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是：&lt;strong&gt;不能取和列名一样的变量名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个在bugs.mysql.com下有人提出过，但是好像被MySQL无视了。见&lt;a href="http://bugs.mysql.com/bug.php?id=28227"&gt;这个链接&lt;/a&gt;，从mysql5.1到5.6都一直没有修复。下面有人吐槽了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is ridiculous that this is considered not to be a bug. It shouldn't break the Fetch just because you are using the same local variable names as the column names in the select cursor. If MySQL ever hopes to become a real database, it should probably up its standards......somewhere towards usable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;改过的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="c1"&gt;//&lt;/span&gt;

&lt;span class="n"&gt;CREATE&lt;/span&gt; &lt;span class="n"&gt;PROCEDURE&lt;/span&gt; &lt;span class="n"&gt;insert_rows&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_sheetid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_groupid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_expertid&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt; &lt;span class="n"&gt;DEFAULT&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;v_itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemScore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_projID&lt;/span&gt; &lt;span class="n"&gt;INT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt; &lt;span class="n"&gt;CURSOR&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ItemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ItemScore&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;sheetitem&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;SheetID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_sheetid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt; &lt;span class="n"&gt;CURSOR&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;SELECT&lt;/span&gt; &lt;span class="n"&gt;ProjID&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;projstate&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;GroupID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a_groupid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;DECLARE&lt;/span&gt; &lt;span class="n"&gt;CONTINUE&lt;/span&gt; &lt;span class="n"&gt;HANDLER&lt;/span&gt; &lt;span class="n"&gt;FOR&lt;/span&gt; &lt;span class="n"&gt;NOT&lt;/span&gt; &lt;span class="n"&gt;FOUND&lt;/span&gt; &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;OPEN&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nl"&gt;item_loop:&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
        &lt;span class="n"&gt;SET&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;FETCH&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;v_itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemScore&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt;
            &lt;span class="n"&gt;LEAVE&lt;/span&gt; &lt;span class="n"&gt;item_loop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;OPEN&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nl"&gt;proj_loop:&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;
            &lt;span class="n"&gt;FETCH&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;v_projID&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="n"&gt;IF&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;THEN&lt;/span&gt;
                &lt;span class="n"&gt;LEAVE&lt;/span&gt; &lt;span class="n"&gt;proj_loop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;v_projID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_expertid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemScore&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;INSERT&lt;/span&gt; &lt;span class="n"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;expertscore&lt;/span&gt; &lt;span class="nf"&gt;values&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v_projID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a_expertid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v_itemScore&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;CLOSE&lt;/span&gt; &lt;span class="n"&gt;projCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="n"&gt;LOOP&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CLOSE&lt;/span&gt; &lt;span class="n"&gt;itemCur&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://dev.mysql.com/doc/refman/5.6/en/cursors.html"&gt;mysql cursors&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://stackoverflow.com/questions/8731779/apparently-fetch-returns-null"&gt;Apparently fetch returns NULL&lt;/a&gt;&lt;/p&gt;</summary><category term="MySQL"></category></entry><entry><title>brief introduction of storm</title><link href="http://particle128.com/posts/2014/08/introduction-storm.html" rel="alternate"></link><updated>2014-08-25T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-08-25:posts/2014/08/introduction-storm.html</id><summary type="html">&lt;p&gt;I have used Storm for 3 months at my internship in Alibaba, and this article is a brief introduction of storm. Use English for fun, haha...&lt;/p&gt;
&lt;h3&gt;What is storm&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://storm.incubator.apache.org/"&gt;Storm&lt;/a&gt; is a distributed realtime computation system. Similar to how Hadoop provides a set of general primitives for doing batch processing, Storm provides a set of general primitives for doing realtime computation.&lt;br /&gt;
Many large companies, including Twitter, Yahoo!, Alibaba and Baidu, have used Storm to do some realtime processing, such as realtime analytics of application logs, or DRPC. Twitter integrates storm with its other infrastructures, including database systems, the messaging infrastructure, and monitoring/altering system.&lt;br /&gt;
Typical use cases for Storm:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;processing stream&lt;br /&gt;
  no need for intermediary queues -&amp;gt; faster  &lt;/li&gt;
&lt;li&gt;continuous computation&lt;br /&gt;
  compute when data is available -&amp;gt; realtime  &lt;/li&gt;
&lt;li&gt;distributed remote procedure call&lt;br /&gt;
  parallelize CPU-intensive operations -&amp;gt; higher throughput (somewhat like pipelining)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By the way, Alibaba has developed a special version of Storm, called &lt;a href="https://github.com/alibaba/jstorm"&gt;JStorm&lt;/a&gt;, which ueses Java (quicker than Clojure) to rewrite the core module of Storm and makes some changes (optimizing ack mechanism, ...), achieving higher performance and more stability.  &lt;/p&gt;
&lt;h3&gt;Basic concepts of storm&lt;/h3&gt;
&lt;h4&gt;Stream&lt;/h4&gt;
&lt;p&gt;A &lt;code&gt;stream&lt;/code&gt; is an unbounded sequence of data that is created and processed in parallel in a distributed fashion.&lt;br /&gt;
Streams are composed of &lt;code&gt;tuples&lt;/code&gt;, which are the smallest units that can be emited from spout/bolt. And a tuple is constuited of 1 or more &lt;code&gt;fields&lt;/code&gt;.&lt;br /&gt;
For example, &lt;code&gt;TestSpout&lt;/code&gt; reads tweets from a MQ, and emits &lt;code&gt;(author, tweet, date)&lt;/code&gt; to &lt;code&gt;TestBolt&lt;/code&gt;. &lt;code&gt;(author, tweet, date)&lt;/code&gt; is the tuple, and &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;tweet&lt;/code&gt;, &lt;code&gt;date&lt;/code&gt; are three fields of this tuple.  &lt;/p&gt;
&lt;h4&gt;Spout &amp;amp; Bolt&lt;/h4&gt;
&lt;p&gt;The input stream of a Storm cluster is handled by a component called a &lt;code&gt;spout&lt;/code&gt;. The spout passes the data to a component called a &lt;code&gt;bolt&lt;/code&gt;, which transforms it in some way. A bolt either persists the data in some sort of storage, or passes it to some other bolt. You can imagine a Storm cluster as a chain of bolt components that each make some kind of transformation on the data exposed by the spout.  &lt;/p&gt;
&lt;h4&gt;Connection of spout/bolt&lt;/h4&gt;
&lt;p&gt;there are 8 grouping methods, which defines how the downstream bolt read from the upstream spout/bolt.&lt;br /&gt;
Common grouping method includes  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Shuffle grouping&lt;br /&gt;
  Tuples are randomly distributed across the bolt’s tasks in a way such that each bolt is guaranteed to get an equal number of tuples.  &lt;/li&gt;
&lt;li&gt;Fields grouping&lt;br /&gt;
  The stream is partitioned by the fields specified in the grouping. For example, if the stream is grouped by the “user-id” field, tuples with the same “user-id” will always go to the same task, but tuples with different “user-id”’s may go to different tasks.  &lt;/li&gt;
&lt;li&gt;All grouping&lt;br /&gt;
  The stream is replicated across all the bolt’s tasks. Use this grouping with care.  &lt;/li&gt;
&lt;li&gt;Global grouping&lt;br /&gt;
  The entire stream goes to a single one of the bolt’s tasks. Specifically, it goes to the task with the lowest id.  &lt;/li&gt;
&lt;li&gt;Custom grouping&lt;br /&gt;
  You defines the grouping rule.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Topology&lt;/h4&gt;
&lt;p&gt;The arrangement of all the components (spouts and bolts) and their connections is called a &lt;code&gt;topology&lt;/code&gt;  &lt;/p&gt;
&lt;h4&gt;Nimbus &amp;amp; Supervior&lt;/h4&gt;
&lt;p&gt;Since it's a distributed system, there are more than one machine (node) in the system's cluster.  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;master node&lt;br /&gt;
  runs &lt;code&gt;Nimbus&lt;/code&gt; daemon, which is responsible for distributing code around the cluster, assigning tasks to each worker node, and monitoring for failures.  &lt;/li&gt;
&lt;li&gt;worker node&lt;br /&gt;
  runs &lt;code&gt;Supervisor&lt;/code&gt; daemon, which consists of 1 or more worker processes and executes a portion of a topology (such as 1 spout and 2 bolts)  &lt;/li&gt;
&lt;li&gt;zookeeper node&lt;br /&gt;
  runs zookeeper, in which the states of Nimbus and Supervisor are stored  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The illustration below shows the relationship among them&lt;br /&gt;
&lt;img alt="image" src="http://particle128.com/images/storm1.png" /&gt;  &lt;/p&gt;
&lt;h4&gt;worker &amp;amp; executor &amp;amp; task&lt;/h4&gt;
&lt;p&gt;all the three concepts are inside the supervisor daemon, since the master node and the zk node are controlling nodes  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;worker (process)&lt;br /&gt;
  runs inside the supervisor daemon&lt;br /&gt;
  You can configure the number of workers across machines by &lt;code&gt;Config config = new Config(); config.setNumWorkers(3)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;executor (thread)&lt;br /&gt;
  runs inside the worker process&lt;br /&gt;
  You can configure the initial number of executors per component(bolt/spout) by &lt;code&gt;topologyBuilder.setBolt("test", new TestBolt(), 2)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;task (bolt/spout instance)&lt;br /&gt;
  runs inside the executor, 1 executor has 1 task by default&lt;br /&gt;
  You can configure the number of tasks per component by &lt;code&gt;topologyBuilder.setBolt("test", new TestBolt(), 2).setNumTasks(4)&lt;/code&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following two illustrations show the relationship among them&lt;br /&gt;
&lt;img alt="image" src="http://particle128.com/images/storm2.png" /&gt;&lt;br /&gt;
&lt;img alt="image" src="http://particle128.com/images/storm3.png" /&gt;  &lt;/p&gt;
&lt;p&gt;What is the reason for have 2+ tasks per executor, see &lt;a href="http://stackoverflow.com/questions/17257448/what-is-the-task-in-twitter-storm-parallelism"&gt;here&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://storm.incubator.apache.org/documentation"&gt;storm documentation&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.michael-noll.com/blog/2012/10/16/understanding-the-parallelism-of-a-storm-topology/"&gt;Understanding the Parallelism of a Storm Topology&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://stackoverflow.com/questions/17257448/what-is-the-task-in-twitter-storm-parallelism"&gt;What is the “task” in twitter Storm parallelism&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://shop.oreilly.com/product/0636920024835.do"&gt;Getting Started with Storm&lt;/a&gt;  &lt;/p&gt;</summary><category term="storm"></category><category term="trident"></category></entry><entry><title>使用Storm 2个月后的总结</title><link href="http://particle128.com/posts/2014/07/storm-sum.html" rel="alternate"></link><updated>2014-07-29T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-07-29:posts/2014/07/storm-sum.html</id><summary type="html">&lt;h2&gt;如何使用directGrouping&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;申明流是direct Stream&lt;br /&gt;
spout/bolt的declareOutputFields中&lt;br /&gt;
outputFieldsDeclarer.declare(/&lt;em&gt;direct&lt;/em&gt;/true, new Fields("word"));  &lt;/li&gt;
&lt;li&gt;使用emitDirect来发送数据&lt;br /&gt;
spout/bolt的nextTuple/execute中&lt;br /&gt;
collector.emitDirect(/&lt;em&gt;taskId&lt;/em&gt;/getWordCountIndex(word),new Values(word));&lt;br /&gt;
注意：因为第一个参数是taskid，首先需要在open/prepare里面获取下游bolt的taskid列表&lt;br /&gt;
topologyContext.getComponentTasks("word-counter")  &lt;/li&gt;
&lt;li&gt;topology定义中指定连接方式为directGrouping&lt;br /&gt;
builder.setBolt("word-counter", new WordCounter(), 3).directGrouping("spout");  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;如何利用Storm提供的可靠性保证&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在spout中，用SpoutOutputCollector调用emit的时候，必须指定messageId。&lt;br /&gt;
一个messageId对应一个tuple树。&lt;br /&gt;
这样，在某个tuple树全部被处理完后，spout的回调函数ack会被调用，ack的参数是那个tuple树对应的messageId。  &lt;/li&gt;
&lt;li&gt;在每一个bolt中，用OutputCollector调用emit的时候，需要指定源tuple，并且在emit之后要调用ack。&lt;br /&gt;
如果该bolt继承自BaseBasicBolt，则自动完成上述操作。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;问题集锦&lt;/h2&gt;
&lt;h3&gt;Problem1&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Spout：emit出去一个map，下游Bolt：有时候读到空的map，有时候读到有内容的map&lt;br /&gt;
&lt;strong&gt;原因&lt;/strong&gt;&lt;br /&gt;
emit出去一个map，就调用pruneData函数把map给clear了。&lt;br /&gt;
因为本地模式在同一个虚拟机下，storm并没有把这个map深拷贝到tuple中保存，Bolt读到的map和上游Spout发送的map是来自同一块内存。&lt;br /&gt;
这样，就出现了一个竞争条件：如果Spout线程先clear，下游Bolt才接到的话，读到的就是空map；如果先接到，Spout再clear，读到的就是有内容的map。&lt;br /&gt;
&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
pruneData不clear这个map了，而是new一个新的map。让垃圾回收器去把不用的map回收。  &lt;/p&gt;
&lt;h3&gt;Problem2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Trident中，使用each和partitionAggregate函数，下游接收到空的tuple&lt;br /&gt;
&lt;strong&gt;原因&lt;/strong&gt;&lt;br /&gt;
这和&lt;a href="http://storm.incubator.apache.org/documentation/Documentation.html"&gt;官方Documentation&lt;/a&gt;不符，原因不详&lt;br /&gt;
&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
不管是each，还是partitionAggregate函数，必须指定第一个参数（即Fields），表明输入的值列表。  &lt;/p&gt;
&lt;h3&gt;Probelm3&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;br /&gt;
Trident中，一旦加上partitionPersist函数，就会报错  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;NotSerializableException&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;aliyun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;aep&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;storm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;binpacking&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;BinpackingTrident&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;br /&gt;
让BinpackTrident实现Serializable。  &lt;/p&gt;</summary><category term="storm"></category></entry><entry><title>新技能get：git cherry-pick</title><link href="http://particle128.com/posts/2014/06/git-cherry-pick.html" rel="alternate"></link><updated>2014-06-24T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-06-24:posts/2014/06/git-cherry-pick.html</id><summary type="html">&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;形象化地表述就是：&lt;br /&gt;
今天在fork出的github库中提交了3次，一次是内容相关的（'content'），两次是对程序的修改（'change1','change2'），然后我就兴致勃勃地拿去pull request了。本以为就这样完事了，结果被师兄无情地打回来了...说弄成两个pull request，一个内容相关的，一个程序相关的。&lt;br /&gt;
在github的页面上摆弄了半天也没找到可以把当前分支拆开进行pull request的按钮，于是，虔诚地向师兄请教，师兄微微一笑，给了我几个关键字（'根部开分支','cherry-pick'）后，拂袖而去，留下无助的我，在风中凌乱着。。。  &lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;原来的git提交结构是这样的(假设'old','content'...这些是commit的代号):  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;master:&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;change1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;change2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了把content和change1,change2分开,我需要建立如下的结构  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;master:&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;change1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;change2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;  
&lt;span class="nl"&gt;cmd:&lt;/span&gt;          &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;  
&lt;span class="nl"&gt;develop:&lt;/span&gt;      &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;change1&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;change2&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中,建立了两个分支'cmd'和'develop',分别对应内容和程序修改。  &lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;h4&gt;1、操作本地git repository&lt;/h4&gt;
&lt;p&gt;首先，  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;log&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分别找到'old','content','change1','change2'这4次提交的散列码，假设分别为oldsum,consum,ch1sum,ch2sum&lt;br /&gt;
然后，创建cmd分支，把'content'这次的提交合并进去  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;oldsum&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;cherry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pick&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;consum&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，创建develop分支，把'change1'和'change2'的提交合并进去  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;oldsum&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;develop&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;cherry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pick&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ch1sum&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;cherry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pick&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ch2sum&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2、更新我fork出来的远程git repository&lt;/h4&gt;
&lt;p&gt;把本地离线建立地分支，更新到远程库中  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;develop&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;develop&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这只后，就可以对cmd和develop申请pull request了  &lt;/p&gt;
&lt;h4&gt;3、善后工作&lt;/h4&gt;
&lt;p&gt;等师兄merge了我的请求，合并上游代码库中最新的版本，并提交到我fork出的代码库  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;upstream&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;xxx&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yyy&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;fetch&lt;/span&gt; &lt;span class="n"&gt;upstream&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;reabse&lt;/span&gt; &lt;span class="n"&gt;upstream&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;把本地&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="err"&gt;衍合到&lt;/span&gt;&lt;span class="n"&gt;upstream&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="err"&gt;分支上。&lt;/span&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="err"&gt;也可，只是多一个合并的&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="err"&gt;记录&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;reset&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;hard&lt;/span&gt; &lt;span class="n"&gt;HEAD&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;为了让提交历史干净，我把&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="err"&gt;上的已经被合并的&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;个&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="err"&gt;手动撤销了&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;清除临时创建的无用分支  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;branch&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;     &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;强制删除&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="err"&gt;分支。因为没有合并，只能&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="err"&gt;强制删除&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;branch&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;develop&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;强制删除&lt;/span&gt;&lt;span class="n"&gt;develop&lt;/span&gt;&lt;span class="err"&gt;分支&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;清除远程库的分支（这一条和上一条没有先后顺序）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;cmd&lt;/span&gt;  
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;develop&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="git"></category></entry><entry><title>数据库的分库和分表</title><link href="http://particle128.com/posts/2014/06/database-shard.html" rel="alternate"></link><updated>2014-06-23T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-06-23:posts/2014/06/database-shard.html</id><summary type="html">&lt;h2&gt;一、分表&lt;/h2&gt;
&lt;h3&gt;水平分表&lt;/h3&gt;
&lt;h4&gt;1、背景&lt;/h4&gt;
&lt;p&gt;当一张表的数据记录太多的时候，索引结构会膨胀，因此对该表的查询和更新的时间会延长。&lt;br /&gt;
以InnoDB的B+树索引为例，记录多的时候，B+树高度更大。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询：层数多，每次查询需要访问的结点就多，速度就慢。&lt;/li&gt;
&lt;li&gt;更新：当某个叶子结点达到容量极限的时候，再次插入应该落入该结点的元素，需要增加叶子结点，并且更新上层索引，极端情况下需要更新每一层索引，因此层数多也会导致速度慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，还有写入表时锁的问题，数据表太大，一个写入操作可能阻塞后续的读取别的位置的读操作。&lt;/p&gt;
&lt;h4&gt;2、概念&lt;/h4&gt;
&lt;p&gt;把usr表分成usr_1, usr_2, usr_3...，每个表的结构都和原表一样，各包括原表的一部分数据。比如usr_1包括id从0到9999，usr_2包括id从10000到19999。&lt;/p&gt;
&lt;h4&gt;3、意义&lt;/h4&gt;
&lt;p&gt;提高数据的查询和更新效率（索引结构变小，锁住的数据量变少）&lt;/p&gt;
&lt;h3&gt;垂直分表&lt;/h3&gt;
&lt;h4&gt;1、背景&lt;/h4&gt;
&lt;p&gt;当一张表，有些字段经常被查询不常更新，另外一些字段经常被更新的时候，这张表的效率是不高的。&lt;/p&gt;
&lt;h4&gt;2、概念&lt;/h4&gt;
&lt;p&gt;根据数据的活跃度，把一张表进行分离，比如usr表分成usr_static_info,usr_dynamic_info，分别保存冷数据和活跃数据。&lt;br /&gt;
首先存储引擎的使用不同，冷数据使用MyIsam 可以有更好的查询效率。活跃数据，可以使用Innodb ,可以有更好的更新速度。 &lt;br /&gt;
其次，对冷数据进行更多的从库配置，因为更多的操作时查询，这样来加快查询速度。对热数据，可以相对有更多的主库的横向分表处理。&lt;br /&gt;
其实，对于一些特殊的活跃数据，也可以考虑使用memcache ,redis之类的缓存，等累计到一定量再去更新数据库，或者mongodb 一类的nosql 数据库。  &lt;/p&gt;
&lt;h4&gt;3、意义&lt;/h4&gt;
&lt;p&gt;提高数据的查询和更新效率（对活跃数据和冷数据的分别存储和优化，提高活跃数据的更新效率，和冷数据的查询效率）&lt;/p&gt;
&lt;h2&gt;二、分库&lt;/h2&gt;
&lt;h3&gt;1、背景&lt;/h3&gt;
&lt;p&gt;对于一个大型的互联网应用，每天几十亿的PV会对单机数据库造成了相当高的负载，对于系统的稳定性和扩展性造成了极大的问题。&lt;/p&gt;
&lt;h3&gt;2、概念&lt;/h3&gt;
&lt;p&gt;为了克服单机的性能瓶颈，增加一个数据库主机，把原数据库DB1中的一些表，挪到另一个数据库DB2中，从而让查询语句分开访问不同的主机。&lt;br /&gt;
重要的是对业务要细化，分库时候要想清楚各个模块业务之间的交互情况，避免将来写程序时出现过多的跨库操作（开销很大）。 &lt;/p&gt;
&lt;h3&gt;3、意义&lt;/h3&gt;
&lt;p&gt;减少了单机的访问压力。&lt;/p&gt;
&lt;h2&gt;三、分库+分表&lt;/h2&gt;
&lt;h3&gt;1、背景&lt;/h3&gt;
&lt;p&gt;单表记录巨多，访问量巨大，单纯的分表克服不了访问压力，单纯的分库又不适用于单表的情况，就需要采用：分库+分表。&lt;/p&gt;
&lt;h3&gt;2、概念&lt;/h3&gt;
&lt;p&gt;分库+分表，把usr表分成DB1.usr, DB2.usr, ... 等。每个数据库中对应的同名表，保存了原来usr表的部分数据。&lt;/p&gt;
&lt;h3&gt;3、意义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;减少单机访问压力&lt;/li&gt;
&lt;li&gt;提高查询和更新效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4、原则&lt;/h3&gt;
&lt;h4&gt;(1) 以user_id为区分&lt;/h4&gt;
&lt;p&gt;1～1000的对应DB1，1001～2000的对应DB2，以此类推&lt;br /&gt;
优点：可部分迁移&lt;br /&gt;
缺点：数据分布不均  &lt;/p&gt;
&lt;h4&gt;(2) 对user_id进行hash取模分&lt;/h4&gt;
&lt;p&gt;对user_id进行hash（或者如果user_id是数值型的话直接使用user_id 的值也可），然后用一个特定的数字，比如应用中需要将一个数据库切分成4个数据库的话，我们就用4这个数字对user_id的hash值进行取模运算，也 就是user_id%4,这样的话每次运算就有四种可能：结果为1的时候对应DB1；结果为2的时候对应DB2；结果为3的时候对应DB3；结果为0的时 候对应DB4，这样一来就非常均匀的将数据分配到4个DB中。&lt;br /&gt;
优点：数据分布均匀&lt;br /&gt;
缺点：数据迁移的时候麻烦，不能按照机器性能分摊数据  &lt;/p&gt;
&lt;h4&gt;(3) 在认证库中保存数据库配置&lt;/h4&gt;
&lt;p&gt;就是建立一个DB，这个DB单独保存user_id到DB的映射关系，每次访问数据库的时候都要先查询一次这个数据库，以得到具体的DB信息，然后才能进行我们需要的查询操作。&lt;br /&gt;
优点：灵活性强，一对一关系&lt;br /&gt;
缺点：每次查询之前都要多一次查询，性能大打折扣  &lt;/p&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zhengdl126.iteye.com/blog/419850"&gt;数据库水平切分的实现原理解析－－－分库，分表，主从，集群，负载均衡器&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://my.oschina.net/cmcm/blog/175104"&gt;mysql分库分表的一些技巧&lt;/a&gt;&lt;/p&gt;</summary><category term="database"></category></entry><entry><title>项目中一个诡异的问题</title><link href="http://particle128.com/posts/2014/05/vdisk-one-question.html" rel="alternate"></link><updated>2014-05-26T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-26:posts/2014/05/vdisk-one-question.html</id><summary type="html">&lt;p&gt;记录下今天在做虚拟磁盘过程中，遇到的一个问题。  &lt;/p&gt;
&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;因为没有找到合适的fat32格式文件系统的扩容工具（fatresize没有效果，parted3.1可以检测到分区但是没有resize功能，parted2.x有resize功能但是检测不到分区），只能暂时采用如下方法来进行“磁盘扩容”。（假设原磁盘test.img，大小为100M，要扩容到200M）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;zero&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  
&lt;span class="n"&gt;mkdosfs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;iocharset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;  
&lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;iocharset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;gb2312&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;umount&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cdrom&lt;/span&gt;  
&lt;span class="n"&gt;umount&lt;/span&gt;  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mnt&lt;/span&gt;  
&lt;span class="n"&gt;mv&lt;/span&gt; &lt;span class="n"&gt;bigger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了测试这种方法的可行性，用了如下步骤：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端挂载test.img，并写入一系列文件  &lt;/li&gt;
&lt;li&gt;客户端卸载test.img  &lt;/li&gt;
&lt;li&gt;服务器执行上述命令  &lt;/li&gt;
&lt;li&gt;客户端再次挂载test.img，查看文件是否存在并且该磁盘大小是否变成200M  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结果，奇怪的事情发生了：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户的windows下现实的磁盘大小仍然为100M  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我用&lt;code&gt;head -c 512 test.img| xxd&lt;/code&gt;查看了一下test.img的启动扇区，0x20开始的4个字节显示磁盘的扇区数目没有错，对应的就是200M大小的磁盘。  &lt;/p&gt;
&lt;p&gt;后来又发现了更诡异的事情：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端对test.img对应磁盘的修改，从服务器的打印信息来看是写入成功了，但是在服务器上mount一下test.img后发现跟原来一样。（写入磁盘我用的mmap+msync方式，所以不存在对文件的修改没有写入磁盘的问题）  &lt;/li&gt;
&lt;li&gt;ls -l 命令显示，客户端对test.img进行修改后，test.img的mtime并没有变化  &lt;/li&gt;
&lt;li&gt;客户端对test.img修改之后，卸载了再挂载，之前的修改保留在了磁盘上  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;客户端对test.img的修改去哪里了？为啥客户端可以看到修改，服务器看不到？  &lt;/p&gt;
&lt;h3&gt;排查&lt;/h3&gt;
&lt;p&gt;试了几种方法，都没有发现问题，后来用&lt;code&gt;lsof | sed -n '1p;/test.img/p'&lt;/code&gt;查看打开文件的时候，发现问题了。&lt;br /&gt;
结果如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;COMMAND&lt;/span&gt;     &lt;span class="n"&gt;PID&lt;/span&gt;       &lt;span class="n"&gt;USER&lt;/span&gt;   &lt;span class="n"&gt;FD&lt;/span&gt;      &lt;span class="n"&gt;TYPE&lt;/span&gt;     &lt;span class="n"&gt;DEVICE&lt;/span&gt;  &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;OFF&lt;/span&gt;       &lt;span class="n"&gt;NODE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;  &lt;span class="n"&gt;DEL&lt;/span&gt;       &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;              &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;    &lt;span class="mi"&gt;6u&lt;/span&gt;      &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;deleted&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正常情况，在执行PUT的过程中输出如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;COMMAND&lt;/span&gt;     &lt;span class="n"&gt;PID&lt;/span&gt;       &lt;span class="n"&gt;USER&lt;/span&gt;   &lt;span class="n"&gt;FD&lt;/span&gt;      &lt;span class="n"&gt;TYPE&lt;/span&gt;     &lt;span class="n"&gt;DEVICE&lt;/span&gt;  &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;OFF&lt;/span&gt;       &lt;span class="n"&gt;NODE&lt;/span&gt; &lt;span class="n"&gt;NAME&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;  &lt;span class="n"&gt;mem&lt;/span&gt;       &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;span class="n"&gt;server&lt;/span&gt;    &lt;span class="mi"&gt;11987&lt;/span&gt;       &lt;span class="n"&gt;root&lt;/span&gt;    &lt;span class="mi"&gt;6u&lt;/span&gt;      &lt;span class="n"&gt;REG&lt;/span&gt;        &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;209715200&lt;/span&gt;    &lt;span class="mi"&gt;1177379&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;VDisk_Home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中mem表示test.img被内存映射  &lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;首先引用一句APUE里的话：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关闭一个文件时，内核会首先检查打开该文件的进程数。如果进程数达到0，然后检查其链接数，如果这个数才是0，那么就删除该文件。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注：shell下可以分别用&lt;code&gt;lsof | grep filename&lt;/code&gt;和&lt;code&gt;ls -l filename | cut -d ' ' -f 2&lt;/code&gt;来检查这两点是否满足。  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv bigger.img test.img&lt;/code&gt;，其实是删除原test.img再把bigger.img改名为test.img的过程。&lt;br /&gt;
test.img的删除，是unlink的过程，即“将test.img的inode结点中的链接数字段-1”。虽然此时test.img的链接数变为0，但是test.img还打开着，所以不会马上删除这个文件的inode结点、数据块。但是，会删除test.img所在目录里的一行文件记录(inode号-&amp;gt;文件名)。由于，inode块和数据块没有删除，inode map和data map中对应的位置也占用着，所以后续在文件系统创建新文件，不会把他们覆盖。  &lt;/p&gt;
&lt;p&gt;项目中我使用了全局hashmap path2fd(保存文件路径到文件描述符)，所以客户端卸载再加载test.img的过程，还在使用原来的文件描述符来访问文件。read和write系统调用，都是使用文件描述符来引用的。因此mv删除原test.img后，重新挂载test.img后，仍然都在修改原test.img——一个在目录中找不到的文件，也被称为幽灵文件(phantom file)。  &lt;/p&gt;
&lt;h4&gt;一个问题&lt;/h4&gt;
&lt;p&gt;这个原理，顺便可以解释一个问题——“什么情况下，df -h /dir和du -hs /dir的结果不一样：&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;答&lt;/em&gt;&lt;/strong&gt;：运行中进程打开的文件，被用户删除！（link=0，但访问进程数&amp;gt;0）&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;解释&lt;/em&gt;&lt;/strong&gt;：df直接从文件系统的超级块读取磁盘使用情况信息，所以往往返回结果很快。但是du递归深入目录，readdir来获取每一个目录下的文件，然后将各个文件的inode中保存的文件大小相加。目录项被删除，du变小；文件没有被真正删除，超级块没变，df没变。df的结果&amp;gt;du的结果。  &lt;/p&gt;
&lt;h3&gt;解决&lt;/h3&gt;
&lt;p&gt;每次resize一个FAT32磁盘，就重新打开一遍这个文件，更新一下全局hashmap。  &lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>linux中的线程的实质和实现</title><link href="http://particle128.com/posts/2014/05/linux-thread.html" rel="alternate"></link><updated>2014-05-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-20:posts/2014/05/linux-thread.html</id><summary type="html">&lt;h3&gt;线程的实质&lt;/h3&gt;
&lt;p&gt;gdb调试线程，在线程创建和退出的时候，会看到这样的字样  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;New&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="mh"&gt;0xb799ab40&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LWP&lt;/span&gt; &lt;span class="mi"&gt;20528&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="mh"&gt;0xb799ab40&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LWP&lt;/span&gt; &lt;span class="mi"&gt;20528&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;exited&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Thread后面的数字是线程id，但是后面出现的LWP是什么呢？  &lt;/p&gt;
&lt;p&gt;LWP(light weighted process)，即轻量级进程。它是进程，但是和普通进程的区别在于，子进程和父进程共享绝大多数地址空间和资源:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址空间中，除了栈，其他段（text、data、bss、heap等）都是共享的。  &lt;/li&gt;
&lt;li&gt;资源中，除了tid、线程特定的信号屏蔽字、errno等少数几个，其余的（pid、ppid、pgid、sid、controlling terminal、uid、gid、open file descriptors、record locks、当前目录和根目录、rlimit限制、文件默认创建模式、itimer定时器等）都是共享的。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普通进程和LWP在实现上的不同点是：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通进程，fork会调用clone，第三个参数flags不会包含CLONE_THREAD  &lt;/li&gt;
&lt;li&gt;LWP，pthread_create会调用clone，第三个参数flags会包含CLONE_THREAD(可能还有其他几个标志)，标示子进程和父进程同属一个线程组(相同TGID)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程和LWP是同一个东西，只是在用户态，我们管进程中每一个执行序列为“线程”，但是内核中它被称为LWP。因为内核上没有线程的概念，CPU的调度是以进程为单位的。  &lt;/p&gt;
&lt;h3&gt;线程的实现&lt;/h3&gt;
&lt;p&gt;线程的实现，经历了如下发展阶段：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LinuxThreads : Linux2.6之前  &lt;/li&gt;
&lt;li&gt;NPTL (Native Posix Thread Library) : RedHat负责，Linux2.6之后  &lt;/li&gt;
&lt;li&gt;NGPT (Next Generation Posix Thread): IBM负责，同NPTL同时开始研究的，但是最后被抛弃了(IBM啊...哎...)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;LinuxThreads&lt;/h4&gt;
&lt;p&gt;在LinuxThreads中，专门为每一个进程构造了一个管理线程，负责处理线程相关的管理工作。当进程第一次调用pthread_create()创建一个线程的时候就会创建并启动管理线程。然后管理线程再来创建用户请求的线程。也就是说，用户在调用pthread_create后，先是创建了管理线程，再由管理线程创建了用户的线程。  &lt;/p&gt;
&lt;p&gt;为了遵循POSIX对线程的一个规定：&lt;code&gt;当"进程"收到一个致命信号(比如由于段错误收到SIGSEGV信号), 进程内的线程全部退出&lt;/code&gt;，LinuxThreads的实现方法：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;程序第一次调用pthread_create时, linuxthreads发现管理线程不存在, 于是创建这个管理线程. 这个管理线程是进程中的第一个线程(主线程)的儿子.  &lt;/li&gt;
&lt;li&gt;然后在pthread_create中, 会通过pipe向管理线程发送一个命令, 告诉它创建线程. 即是说, 除主线程外, 所有的线程都是由管理线程来创建的, 管理线程是它们的父亲.  &lt;/li&gt;
&lt;li&gt;于是, 当任何一个子线程退出时, 管理线程将收到SIGUSER1信号(这是在通过clone创建子线程时指定的). 管理线程在对应的sig_handler中会判断子线程是否正常退出, 如果不是, 则杀死所有线程, 然后自杀.  &lt;/li&gt;
&lt;li&gt;主线程是管理线程的父亲, 其退出时并不会给管理线程发信号. 于是, 在管理线程的主循环中通过getppid检查父进程的ID号, 如果ID号是1, 说明父亲已经退出, 并把自己托管给了init进程(1号进程). 这时候, 管理线程也会杀掉所有子线程, 然后自杀.  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;容易发现，管理线程可能成为多线程系统的瓶颈，线程创建和销毁的开销很大（需要IPC）。&lt;br /&gt;
更为重要的是，LinuxThreads无法满足Posix对线程的绝大多数规定，比如：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看进程列表的时候, 相关的一组task_struct应当被展现为列表中的一个节点;  &lt;/li&gt;
&lt;li&gt;发送给这个"进程"的信号(对应kill系统调用), 将被对应的这一组task_struct所共享, 并且被其中的任意一个"线程"处理;  &lt;/li&gt;
&lt;li&gt;发送给某个"线程"的信号(对应pthread_kill), 将只被对应的一个task_struct接收, 并且由它自己来处理;  &lt;/li&gt;
&lt;li&gt;当"进程"被停止或继续时(对应SIGSTOP/SIGCONT信号), 对应的这一组task_struct状态将改变;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NPTL&lt;/h4&gt;
&lt;p&gt;在linux 2.6中, 内核有了线程组的概念, task_struct结构中增加了一个tgid(thread group id)字段.&lt;br /&gt;
如果这个task是一个"主线程", 则它的tgid等于pid, 否则tgid等于进程的pid(即主线程的pid).  &lt;/p&gt;
&lt;p&gt;通过如下方式，解决了LinuxThreads不能兼容POSIX的问题：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有了tgid, 内核或相关的shell程序就知道某个tast_struct是代表一个进程还是代表一个线程, 也就知道在什么时候该展现它们, 什么时候不该展现(比如在ps的时候, 线程就不要展现了).  &lt;/li&gt;
&lt;li&gt;为了应付"发送给进程的信号"和"发送给线程的信号", task_struct里面维护了两套signal_pending, 一套是线程组共享的, 一套是线程独有的。通过kill发送的信号被放在线程组共享的signal_pending中, 可以由任意一个线程来处理; 通过pthread_kill发送的信号(pthread_kill是pthread库的接口, 对应的系统调用中tkill)被放在线程独有的signal_pending中, 只能由本线程来处理.  &lt;/li&gt;
&lt;li&gt;当线程停止/继续, 或者是收到一个致命信号时, 内核会将处理动作施加到整个线程组中.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;NGPT&lt;/h4&gt;
&lt;p&gt;上面提到的两种线程库使用的都是内核级线程(每个线程都对应内核中的一个调度实体), 这种模型称为1:1模型(1个线程对应1个内核级线程);&lt;br /&gt;
而NGPT则打算实现M:N模型(M个线程对应N个内核级线程), 也就是说若干个线程可能是在同一个执行实体上实现的.  &lt;/p&gt;
&lt;p&gt;因为模型太复杂，貌似没有实现出来所有预定功能，所以被放弃了。  &lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.thegeekstuff.com/2013/11/linux-process-and-threads/"&gt;What are Linux Processes, Threads, Light Weight Processes, and Process State&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.cnitblog.com/tarius.wu/articles/2277.html"&gt;关于进程、线程和轻量级进程的一些笔记&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www3.ece.neu.edu/~dschaa/docs/processes.html"&gt;PROCESSES AND THREADS&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://blog.csdn.net/tianyue168/article/details/7403693"&gt;Linux进程、线程模型，LWP，pthread_self()&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library"&gt;wiki:Native POSIX Thread Library&lt;/a&gt;  &lt;/p&gt;</summary><category term="linux"></category><category term="thread"></category><category term="lwp"></category></entry><entry><title>一场core dump引发的思考</title><link href="http://particle128.com/posts/2014/05/delete-core-dump.html" rel="alternate"></link><updated>2014-05-19T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-19:posts/2014/05/delete-core-dump.html</id><summary type="html">&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;上午在实现算法“找出最小的k个元素/找出第k大的元素”时，遇到了core dump。代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iterator&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;algorithm&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cstdlib&amp;gt;  &lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="c1"&gt;//copy(arr+begin,arr+end+1,ostream_iterator&amp;lt;int&amp;gt;(cout,&amp;quot;,&amp;quot;));  &lt;/span&gt;
    &lt;span class="c1"&gt;//cout&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;begin:&amp;quot;&amp;lt;&amp;lt;begin&amp;lt;&amp;lt;&amp;quot;,end:&amp;quot;&amp;lt;&amp;lt;end&amp;lt;&amp;lt;&amp;quot;,mid:&amp;quot;&amp;lt;&amp;lt;mid&amp;lt;&amp;lt;endl;  &lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// the last element of the small part!!!  &lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;  
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;mink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;||!&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt;  
            &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;srand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;random_shuffle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ostream_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mink&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// fail  &lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ostream_iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并不总会出现core dump，往往测试几组会出现一次。错误信息：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;glibc&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x09499008&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt;  
&lt;span class="o"&gt;=======&lt;/span&gt; &lt;span class="n"&gt;Backtrace&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=========&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x75ee2&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb751bee2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libstdc&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_ZdlPv&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x1f&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb76f951f&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libstdc&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_ZdaPv&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0x1b&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb76f957b&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x8048bfb&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;i386&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;libc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;so&lt;/span&gt;&lt;span class="mf"&gt;.6&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__libc_start_main&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mh"&gt;0xf3&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="mh"&gt;0xb74bf4d3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x8048791&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="o"&gt;=======&lt;/span&gt; &lt;span class="n"&gt;Memory&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;========&lt;/span&gt;  
&lt;span class="mi"&gt;08048000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;a000&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xp&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;a000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00001000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;b000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0804&lt;/span&gt;&lt;span class="n"&gt;c000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00002000&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;09&lt;/span&gt; &lt;span class="mi"&gt;137&lt;/span&gt;        &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mashu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Dropbox&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Practice&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;offer&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;  
&lt;span class="mi"&gt;09499000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;094&lt;/span&gt;&lt;span class="n"&gt;ba000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;          &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;heap&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="n"&gt;b7459000&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b745b000&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mo"&gt;00&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;错误显示为free了一个无效的指针，但是这段代码中new 和 delete的关系如此简单，怎么也想不通啊。况且，从内存映射信息中可以看出，free的指针的确也位于堆上，更让人费解。  &lt;/p&gt;
&lt;h3&gt;转折&lt;/h3&gt;
&lt;p&gt;下午有事没有来实验室，晚上再次拾起这个问题的时候，发现partition代码让我给弄没了（-.-|||），只能重写。&lt;br /&gt;
重写的过程中，突然意识到应该是&lt;code&gt;int j=begin;&lt;/code&gt;，因为j保存的是小于arr[mid]的区段的最后一个元素，区段开始位置是begin+1，上午写成了&lt;code&gt;int j=begin-1;&lt;/code&gt;。改了这一句，在main函数里加了一个循环测试，一点问题都没有。  &lt;/p&gt;
&lt;p&gt;看来，问题出在这一句上。思虑片刻，又翻了一下CSAPP，恍然大悟。  &lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;new和delete的底层会使用malloc和free，在堆上进行内存分配和释放。用malloc分配一个数组，使用，之后传递给free一个数组指针的时候，它如何知道释放多少空间呢？&lt;br /&gt;
答案是，从指针位置前面的一个字中寻找要释放的内存的大小，块大小保存在实际数据位置-4的内存中。&lt;br /&gt;
堆中分配的内存块的截图如下：&lt;br /&gt;
&lt;img alt="image" src="http://particle128.com/images/heap_map.png" /&gt;  &lt;/p&gt;
&lt;p&gt;在gdb中测试一下，结果和解释：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;                  &lt;span class="c1"&gt;//输入，表示会动态分配10个int  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c038&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c034&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c034&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;49&lt;/span&gt;          &lt;span class="c1"&gt;//解释：至少需要的字节数为10*4+4=44（10个4B的int，加一个4B的块大小），为了凑够8B对齐（双字对齐），添加4B的填充(padding)，正好48B。49是因为块大小的最后一位被置1，表示是已分配  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;conti&lt;/span&gt;  
&lt;span class="n"&gt;Continuing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;  
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  

&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;  
&lt;span class="mi"&gt;52&lt;/span&gt;  &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c078&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c074&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c074&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;17&lt;/span&gt;          &lt;span class="c1"&gt;//解释：至少1*4+4=8B，按理来说8B满足对齐要求了，不需要填充了。（猜测）但为了防止外部碎片，分配策略约定至少分配16B，所以8B的填充。  &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;conti&lt;/span&gt;  
&lt;span class="n"&gt;Continuing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;  
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  

&lt;span class="n"&gt;Breakpoint&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minK&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cpp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;  
&lt;span class="mi"&gt;52&lt;/span&gt;  &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mh"&gt;0x804c0a0&lt;/span&gt;  
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="mh"&gt;0x804c09c&lt;/span&gt;  
&lt;span class="mh"&gt;0x804c09c&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="mi"&gt;25&lt;/span&gt;          &lt;span class="c1"&gt;//同理  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;明白了这一点后，我把程序改回了原来的状态(即&lt;code&gt;j=begin-1;&lt;/code&gt;)，并且把上面的代码中注释部分去掉注释，让它打印局部状态，执行结果和解释如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;          &lt;span class="c1"&gt;//输入5和3(5个元素的数组，取最大的3个元素)，后面的为输出信息  &lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  
&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="c1"&gt;// arr[mid]=0，是最小的一个元素，所以这一趟执行完之后，j=begin-1=-1，swap交换了arr[-1]和arr[0]，arr[-1]存的正好是堆块的大小信息，所以0不见了，25出现了。  &lt;/span&gt;
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
&lt;span class="nl"&gt;begin:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;  
&lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="n"&gt;glibc&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;0x09499008&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="c1"&gt;// free指针，发现释放的指针的前一个字的最后一位是0，表明是未分配的内存，所以调用abort()函数中止了进程的执行。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category></entry><entry><title>类unix系统下函数的可重入性</title><link href="http://particle128.com/posts/2014/05/reentrant.html" rel="alternate"></link><updated>2014-05-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-05-05:posts/2014/05/reentrant.html</id><summary type="html">&lt;p&gt;以下内容汇总自APUE不同章节，还包括自己的一些测试  &lt;/p&gt;
&lt;h3&gt;可重入&lt;/h3&gt;
&lt;p&gt;可重入（reentrant）函数，字面意思就是可以重复进入执行，而不会发生数据错乱等异常情况。包括两重意思：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信号处理程序可重入 —— 满足这个条件的函数，称之为异步-信号安全的(async-signal-safe)  &lt;/li&gt;
&lt;li&gt;线程可重入 —— 满足这个条件的函数，称之为线程安全的(thread-safe)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个概念并不对等:&lt;br /&gt;
标准IO库函数比如printf，是线程安全的，因为内部使用了递归锁，即用&lt;code&gt;flockfile(FILE*fp)&lt;/code&gt;和&lt;code&gt;funlockfile(FILE*fp)&lt;/code&gt;包裹;&lt;br /&gt;
但是，它并不是异步信号安全的，因为毕竟&lt;code&gt;FILE&lt;/code&gt;结构是全局的，信号处理程序中可能会修改它(flockfile和funlockfile之间).  &lt;/p&gt;
&lt;h3&gt;信号处理程序可重入&lt;/h3&gt;
&lt;p&gt;不可重入的几种情况：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用静态数据结构，比如getpwnam，getpwuid：如果信号发生时正在执行getpwnam，信号处理程序中执行getpwnam可能覆盖原来getpwnam获取的旧值  &lt;/li&gt;
&lt;li&gt;调用malloc或free：如果信号发生时正在malloc（修改堆上存储空间的链接表），信号处理程序又调用malloc，会破坏内核的数据结构  &lt;/li&gt;
&lt;li&gt;使用标准IO函数，因为好多标准IO的实现都使用全局数据结构，比如printf(文件偏移是全局的)  &lt;/li&gt;
&lt;li&gt;函数中调用longjmp或siglongjmp：信号发生时程序正在修改一个数据结构，处理程序返回到另外一处，导致数据被部分更新。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试书中的例子发现并不会产生SIGSEGV信号，但是程序会阻塞在信号处理程序中调用getpwnam处，怀疑是我的linux版本中getpwnam实现中使用锁来保护静态数据结构struct passwd，而且不是递归锁。  &lt;/p&gt;
&lt;p&gt;测试代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;sys/unistd.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/time.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;signal.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;pwd.h&amp;gt;  &lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sig_alrm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;in the sig_alrm&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getpwnam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;root&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;root error&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after the sig_alrm&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;alarm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//!!!  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;sighandler_t&lt;/span&gt; &lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGALRM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;sig_alrm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;alarm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//alarm只支持秒级的定时器  &lt;/span&gt;
    &lt;span class="cm"&gt;/*  &lt;/span&gt;
&lt;span class="cm"&gt;    struct itimerval old_val,new_val;  &lt;/span&gt;
&lt;span class="cm"&gt;    new_val.it_interval.tv_sec=0;  &lt;/span&gt;
&lt;span class="cm"&gt;    new_val.it_interval.tv_usec=1000; //1ms  &lt;/span&gt;
&lt;span class="cm"&gt;    setitimer(ITIMER_REAL,&amp;amp;new_val,&amp;amp;old_val);//setitimer支持精度更高的定时器，最高可以达到us级，如果系统支持这么高的精度的话  &lt;/span&gt;
&lt;span class="cm"&gt;    cout&amp;lt;&amp;lt;&amp;quot;old itimerval,interval:&amp;quot;&amp;lt;&amp;lt;old_val.it_interval.tv_sec*1000+old_val.it_interval.tv_usec/1000&amp;lt;&amp;lt;&amp;quot;,value:&amp;quot;&amp;lt;&amp;lt;old_val.it_value.tv_sec*1000+old_val.it_value.tv_usec/1000&amp;lt;&amp;lt;endl;  &lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;;)&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before pwnam&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;passwd&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getpwnam&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;after pwnam&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu error&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;pw_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mashu&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;not mashu&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  

    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGALRM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;old_handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;线程可重入&lt;/h3&gt;
&lt;p&gt;很多线程不可重入的系统调用或库函数，都有对应的线程可重入版本，比如  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;asctime_r,ctime_r,gmtime_r,localtime_r  &lt;/li&gt;
&lt;li&gt;getpwnam_r,getpwuid_r,getgrgid_r,getgrnam_r  &lt;/li&gt;
&lt;li&gt;readdir_r,rand_r,strerror_r,strtok_r  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书中实现的getenv_r，做到了线程安全：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改接口，让调用者自己提供缓冲区，而不是用静态/全局缓冲区  &lt;/li&gt;
&lt;li&gt;在访问全局变量environ时递归互斥锁，防止其他线程对该全局变量的修改(pthread_once,pthread_mutex_lock,pthread_mutex_unlock...)  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS，第一点，还可以选择用线程私有/特定数据实现（pthread_key_create,pthread_setspecific,pthread_getspecific）&lt;br /&gt;
第二点，之所以递归，是防止信号处理程序调用同一函数时，死锁。  &lt;/p&gt;
&lt;p&gt;即使做到这几点，getenv_r仍然不是异步信号安全的，因为pthread函数库不保证异步信号安全，包含pthread函数库的函数（getenv_r）也就不能保证异步信号安全。  &lt;/p&gt;</summary><category term="reentrant"></category><category term="linux"></category></entry><entry><title>大规模分布式存储系统-笔记（2）</title><link href="http://particle128.com/posts/2014/04/distriStore2.html" rel="alternate"></link><updated>2014-04-26T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-26:posts/2014/04/distriStore2.html</id><summary type="html">&lt;h2&gt;Chapter2 单机存储系统&lt;/h2&gt;
&lt;h3&gt;2.1硬件基础&lt;/h3&gt;
&lt;h4&gt;CPU架构&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;SMP（对称多处理）:经典的CPU架构，一个计算机上汇集了一组CPU（一个CPU往往包括不止一个核），对称工作、无主次或从属关系，共享相同的物理内存和总线。&lt;br /&gt;
  某些CPU还通过超线程技术（Hyper-Threading Technology），在一个核心上同时执行两个线程。  &lt;/li&gt;
&lt;li&gt;NUMA（非一致存储访问）:克服SMP中多CPU对总线资源的竞争，一个NUMA包括多个NUMA节点，一个NUMA节点就是一个SMP结构（n个CPU，1个内存）  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;IO总线&lt;/h4&gt;
&lt;p&gt;Intel的主板，一般为南、北桥架构  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;北桥芯片：CPU，内存，高端SSD (高速IO)  &lt;/li&gt;
&lt;li&gt;南桥芯片：网卡，硬盘，中低端SSD  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;网路拓扑&lt;/h4&gt;
&lt;p&gt;数据中心网络拓扑结构，主要分为  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三层结构：核心层、汇聚层、接入层。一个接入层交换机下的服务器部署在一个机架内  &lt;/li&gt;
&lt;li&gt;三级CLOS网络：Google设计的扁平化拓扑结构（从wiki上看图，感觉挺复杂的）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输时延  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同一个数据中心内部，网络来回的时延为0.5ms  &lt;/li&gt;
&lt;li&gt;杭州和北京两个数据数据中心之间，网络来回的时延大约40ms  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;性能参数&lt;/h4&gt;
&lt;p&gt;比较重要的参数  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存访问：               100ns  &lt;/li&gt;
&lt;li&gt;千兆网络发送1MB数据：    10ms  (1Gbit/s=0.1GB/s=100MB/s，1MB/(100MB/1000ms)=10ms)  &lt;/li&gt;
&lt;li&gt;SATA磁盘寻道：           10ms  &lt;/li&gt;
&lt;li&gt;SATA磁盘顺序读取1MB数据：20ms （SATA带宽100MB/s，寻道+访问=10ms+1MB/(100MB/1000ms)=20ms）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外：&lt;br /&gt;
SSD（固态硬盘）因为随机读取延迟小（磁盘的随机读取，需要耗费大量的寻道时间），并且提供很高的IOPS（每秒读写次数），在缓存和一些性能要求较高的关键业务上的应用越来越广。  &lt;/p&gt;
&lt;p&gt;存储系统的性能包括两个维度 : 吞吐量 , 访问延时&lt;br /&gt;
磁盘和SSD的访问延时差别很大，但是吞吐量差别不大。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘：大块顺序访问的存储系统，保存冷数据  &lt;/li&gt;
&lt;li&gt;SSD：随机访问较多或者对延时比较敏感的关键系统，保存热数据  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.2 单机存储引擎&lt;/h3&gt;
&lt;p&gt;存储引擎相当于存储系统的发动机.&lt;br /&gt;
存储引擎就是哈希表、B树、LSM树等数据结构在磁盘、SSD等持久化介质的实现。根据采用数据结构不同，分成：哈希存储引擎，B树存储引擎，LSM树存储引擎  &lt;/p&gt;
&lt;h4&gt;哈希存储引擎&lt;/h4&gt;
&lt;p&gt;Bitcask是&lt;a href="http://docs.basho.com/riak/1.2.0/tutorials"&gt;Riak&lt;/a&gt;（排名第三的键值数据库key-value store，elang实现，前两名是redis和memcached）的默认后台存储引擎。  &lt;/p&gt;
&lt;p&gt;特点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只支持追加操作，磁盘中的数据文件包括active data file和older data file。当active data file达到一定大小，就会变成older data file，并且建立新的active文件用来追加数据。  &lt;/li&gt;
&lt;li&gt;磁盘中数据的格式：&lt;code&gt;crc,timestamp,key_sz,value_sz,key(变长),value(变长)&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;内存中的数据结构：&lt;code&gt;key&lt;/code&gt; -&amp;gt; &lt;code&gt;file_id,value_sz,value_pos,timestamp&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;定期合并：删除和更新后，原来的记录会变成垃圾数据，这时候需要合并older data file。基于时间戳，把同一个键下的旧记录或设置为无效的记录删除，只保留最新的记录。  &lt;/li&gt;
&lt;li&gt;快速恢复：内存中的哈希表，每次都在磁盘上保存一份，叫索引文件（hint file）。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增：先在磁盘中追加一条记录，再更新内存的哈希表  &lt;/li&gt;
&lt;li&gt;删：更新磁盘中对应记录的value为无效，更新内存  &lt;/li&gt;
&lt;li&gt;改：增加一条新的记录，更新内存  &lt;/li&gt;
&lt;li&gt;查：通过内存哈希表找到文件号、value位置、value长度，直接read指定的文件在指定的偏移多少字节即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有键都保存在内存中，需要保证键的范围不够大。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;B树存储引擎&lt;/h4&gt;
&lt;p&gt;MySQL InnoDB是&lt;a href="http://dev.mysql.com/"&gt;MySQL&lt;/a&gt;(排名第二的数据库，第一是oracle)的一个存储引擎  &lt;/p&gt;
&lt;p&gt;缓冲区的管理方式：LIRS&lt;br /&gt;
是LRU替换算法的一种改进，被用在MySQL InnoDB和Oracle Touch Count中。将缓冲池分为两级，数据首先进入第一级，如果数据在较短时间内被访问两次或以上，则成为热点数据进入第二级，每一级内部还是采用LRU替换算法。&lt;br /&gt;
目的：防止之前的热点数据，被一次数据库遍历操作全部剔除出缓冲区。  &lt;/p&gt;
&lt;h4&gt;LSM树存储引擎&lt;/h4&gt;
&lt;p&gt;LSM树，即log structured merge tree， LevelDB采用。PS:erlang版本的eLevelDB是Riak的可选后台存储引擎。  &lt;/p&gt;
&lt;p&gt;特点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对数据的修改增量保存在内存的MemTable中，因此修改操作比较快。  &lt;/li&gt;
&lt;li&gt;当MemTable大小达到上限，LevelDB将其冻结为“不可变MemTable”，即只可读的MemTable；同时重新生成一个MemTable，用于接收到达的写入请求。  &lt;/li&gt;
&lt;li&gt;写入操作：先写到磁盘中的操作日志，再更新内存中的MemTable。  &lt;/li&gt;
&lt;li&gt;合并操作(minor compaction)：后台线程将不可变MemTable中的数据排序后写入磁盘，形成SSTable文件。SSTable文件中的记录按照主键排序，每个文件有最小和最大的主键值，这些数据元信息保存于“清单文件”中。SSTable文件根据写入时间，分成多个层次，新写入的放入0层，旧的在1层，更旧的在2层，依次类推。  &lt;/li&gt;
&lt;li&gt;合并操作(major compaction)：当某个层级下的SSTable文件数目超过上限，合并该层中的某些文件到高层级中。  &lt;/li&gt;
&lt;li&gt;读取操作（LevelDB只支持随机读取单条记录）：按如下顺序读取，（1）内存中MemTable，（2）内存中的不可变MemTable，（3）从新到老读取磁盘中的SSTable文件。  &lt;/li&gt;
&lt;li&gt;当内存没有命中时，读取操作比较费时，需要在内存和各个层次文件中查找。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;小结（by myself）&lt;/h4&gt;
&lt;p&gt;几乎存储引擎都会先更新磁盘中的log，再写入内存。
Q:为什么不直接写入磁盘中的数据文件，再写入内存，都是一次磁盘io和一次内存访问？
A:我感觉，因为log文件总是需要的（转储时，数据库失败恢复时），所以必须要写log，而只写log不写磁盘中的数据文件，不会有任何影响，所以减少一次磁盘访问，就只写log和内存。&lt;/p&gt;
&lt;h3&gt;2.3数据模型&lt;/h3&gt;
&lt;p&gt;数据模型相当于存储系统的外壳.&lt;br /&gt;
包括:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件模型，比如unix树状的文件系统，GFS，TFS等  &lt;/li&gt;
&lt;li&gt;关系模型，比如关系型数据库oracle,mysql  &lt;/li&gt;
&lt;li&gt;键值模型，比如redis  &lt;/li&gt;
&lt;li&gt;表格模型，比如Google Bigtable，HBase  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NoSQL(键值模型或表格模型)与SQL(关系模型)对比  &lt;/p&gt;
&lt;p&gt;在海量数据的场景中，SQL存在缺点：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务：事务的多个操作可能在不同主机上，为了保证原子性，需要“两阶段提交协议”（two-phase commit protocol,2PC）。该协议性能很低，而且不能容忍服务器故障。  &lt;/li&gt;
&lt;li&gt;多表连接：关系数据库讲究范式，为了达到更高级别的范式，需要拆分表格，这可能导致多个表在不同主机上，连接性能比较低。  &lt;/li&gt;
&lt;li&gt;性能：B树存储引擎，在某些特定的情形下不如LSM树和hash表。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，也有其优势：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准：SQL语言标准化工作很好  &lt;/li&gt;
&lt;li&gt;运维：关系数据库有成熟的运维工具和大量运维人员  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="distributed"></category><category term="storage"></category></entry><entry><title>大规模分布式存储系统-笔记（1）</title><link href="http://particle128.com/posts/2014/04/distriStore1.html" rel="alternate"></link><updated>2014-04-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-15:posts/2014/04/distriStore1.html</id><summary type="html">&lt;h2&gt;Chapter1 概述&lt;/h2&gt;
&lt;h3&gt;分布式存储特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可扩展：随着集群规模增大，整体性能表现为线性增长  &lt;/li&gt;
&lt;li&gt;低成本：构建在普通PC上，实现自动容错、自动负载均衡  &lt;/li&gt;
&lt;li&gt;高性能  &lt;/li&gt;
&lt;li&gt;易用：提供易用的外部接口，也具备完善的监控和运维工具  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;鸡汤：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般来讲，工程师如果能够深入理解分布式存储系统，理解其他互联网后台架构不再会有任何困难。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;分布式存储分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非结构化数据：文档、图片、视频等  &lt;/li&gt;
&lt;li&gt;结构化数据：数据库中的表  &lt;/li&gt;
&lt;li&gt;半结构化数据：HTML文档，模式结构和内容混在一起  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分布式存储系统分类&lt;/h3&gt;
&lt;p&gt;1、分布式文件系统&lt;br /&gt;
存储非结构化数据，可以用作分布式数据库或分布式表格系统的底层存储  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储BLOB，Facebook Haystack以及Taobao File System  &lt;/li&gt;
&lt;li&gt;存储大文件，Google File System，分布式表格系统Google Bigtable的基础  &lt;/li&gt;
&lt;li&gt;存储定长块，Amazon的Elastic Block Store，分布式数据库Amazon RDS的基础  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、分布式键值系统&lt;br /&gt;
存储关系简单的半结构化数据，只提供基于主键的CRUD功能，一般用作分布式缓存  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Amazon Dynamo  &lt;/li&gt;
&lt;li&gt;Taobao Tair  &lt;/li&gt;
&lt;li&gt;redis  &lt;/li&gt;
&lt;li&gt;memcached  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一致性哈希(consistent hashing)是分布式缓存常用的技术&lt;/p&gt;
&lt;p&gt;3、分布式表格系统&lt;br /&gt;
存储关系较为复杂的半结构化数据，除了CRUD功能，还支持主键的范围查找  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Bigtable  &lt;/li&gt;
&lt;li&gt;Amazon DynamoDB  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4、分布式数据库&lt;br /&gt;
存储结构化数据，是关系型数据库的扩展，提供SQL关系查询语言，多表关联、嵌套子查询等。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Google Spanner  &lt;/li&gt;
&lt;li&gt;阿里的OceanBase  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然还有很火的NoSQL数据库，克服关系数据库扩展、并发、性能方面的缺陷。  &lt;/p&gt;</summary><category term="distributed"></category><category term="storage"></category></entry><entry><title>初识自旋锁spinlock</title><link href="http://particle128.com/posts/2014/04/spinlock.html" rel="alternate"></link><updated>2014-04-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-04-02:posts/2014/04/spinlock.html</id><summary type="html">&lt;h3&gt;起因&lt;/h3&gt;
&lt;p&gt;虚拟磁盘的项目中，使用了互斥锁(mutex)来控制任务队列的访问。但是mutex开销过大，让线程池的效果大打折扣，于是发现了spinlock的存在。  &lt;/p&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;来自&lt;a href="http://en.wikipedia.org/wiki/Spinlock"&gt;wiki&lt;/a&gt;的定义：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, a spinlock is a lock which causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking if the lock is available. Since the thread remains active but is not performing a useful task, the use of such a lock is a kind of busy waiting.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自旋锁是一种忙等锁，它不像其他同步方式（mutex,rwlock,cond）一样，将不能进入临界区的线程阻塞，并通过上下文切换，让另一个可以执行的线程在该cpu上运行。该锁会一直循环检查，直到别的线程释放。  &lt;/p&gt;
&lt;h3&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多处理器（或者多核） ——否则，线程会进入死循环，程序死锁  &lt;/li&gt;
&lt;li&gt;临界区代码执行很快   ——比如就几行代码，且没有系统调用  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优点和缺点&lt;/h3&gt;
&lt;p&gt;优点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免了上下文切换的繁重开销（用户态-&amp;gt;内核态，保护现场，可能页置换等），执行速度快  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一直占用CPU，如果锁很久也得不到，就会浪费过多的cpu资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;API&lt;/h3&gt;
&lt;p&gt;pthread库就支持spinlock，提供的API如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;pthread.h&amp;gt;  &lt;/span&gt;

&lt;span class="c1"&gt;//创建和初始化  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pshared&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// pshared 可选： PTHREAD_PROCESS_SHARED 或 PTHREAD_PROCESS_PRIVATE  &lt;/span&gt;
&lt;span class="c1"&gt;//销毁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_destroy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//加锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_trylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//解锁  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;pthread_spin_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;pthread_spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="spinlock"></category><category term="multi-thread"></category></entry><entry><title>选择恐惧症</title><link href="http://particle128.com/posts/2014/03/selectFear.html" rel="alternate"></link><updated>2014-03-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-03-20:posts/2014/03/selectFear.html</id><summary type="html">&lt;h3&gt;症状&lt;/h3&gt;
&lt;p&gt;这个名词是我在《天生购物狂》这部电影里看到的。时隔这么多年，发现自己身上的“选择困难”问题愈演愈烈了。稍微回顾下我的症状：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配眼镜：假期要换一副黑框眼镜，逛了3个眼镜店，在第三个眼镜店挑了接近1h的眼镜。假期回来后发现自己挑了这么久的眼镜还是不太合适，于是决定换一副：去了学校眼镜店两次+试了各种眼镜，累计1h；在网上逛了n次，累计2h；问了3个人（亚南，小雷，涵姐），累计2h，最终才买下了这款眼镜，事后发现也一般。。。  &lt;/li&gt;
&lt;li&gt;选实习部门：好几个单位，都找了人内推。但是每次跟这些同学或师兄谈论关于内推的事情，都要纠结至少2h，而且每次都把可怜的内推er（姑且这么称呼他们）弄的有点不爽。。。毕竟人家内推你是出于情面，但是你一直纠结这个部门前景好还是那个部门工资高，人家肯定不耐烦了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;产生原因&lt;/h3&gt;
&lt;p&gt;完美主义的非正常心理的作怪  &lt;/p&gt;
&lt;p&gt;凡是有选择恐惧症的人，都是极度追求完美的人，而且是极度苛刻的人——他们要求自己必须做一个单选，而且这唯一的选择必须是最大限度的理想化的选择。可以说，这些病人也属于强迫症人群。他们往往追求完美，并赋予选项太多的意义。  &lt;/p&gt;
&lt;h3&gt;诊断&lt;/h3&gt;
&lt;p&gt;看了上面的症状，是不是发现我问题挺严重的。。。我后来专门从网上测了一下，虽然只有寥寥几道题，估计不太准，但还是反映了我现在这个问题的严重性：  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你已经站在选择恐惧症的边缘了。&lt;br /&gt;
选择对于你来说已经是一件很难的事了，你总是比较来比较去，想得出一个最佳的答案，可是事实上很多事情是没有所谓的最佳答案的。选择更多时候意味着得到某些东西并且失去某些东西，而你心里则不想失去任何东西。你要想的不是怎样保证不失去，而是怎样获得最大的收获。如果按照这条原则，相信你的选择将会变得清晰而明了。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实它给我的思路并不完全适用，有时候是担心失去，有时候则是寻求最优解。  &lt;/p&gt;
&lt;h3&gt;出路&lt;/h3&gt;
&lt;p&gt;说出路，有点夸张，但是“选择恐惧症”的确让我有点拙计。况且，现在在学校，面临的选择还比较少，以后呢？工作、婚姻、家庭、生活，方方面面的选择太多了，每个选择都花个一两天太不值得了。况且，即使花了这么久，也不见得选择的就是好的（就像配眼镜那件事）。绝大多数时候，因为选择时的眼界和视野，根本没法选择出最优解。&lt;br /&gt;
其实，有的时候，多考虑一下不是坏事，但是要有个度，考虑个差不多，还选不出来的时候，就“听天由命”的随便选一个了。很多选择，选之前永远不会明白哪个是最好的，选之后才知道。&lt;br /&gt;
下面的一些话摘自网上（知乎啥的），当我又犯病的时候可以看看！  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《暗时间》中有这样一段话：“有人会因为无法作出决定就推迟决定，然而实际上推迟决定恰恰是最差的决定，在推迟决定期间，时间悄悄流逝，你却没有任何一条路上的积累，白白浪费了时间。如果你有一些钱不知道花在A还是B上，你先不作决定，没问题，因为钱还是你的，但如果你有一些时间，不知道花在A上还是B上，不行，因为过了这段时间，这段时间就不是你的了。”  &lt;/p&gt;
&lt;p&gt;很多决定确实会影响你的一生，但这样机会人的一生中平均也就七八次，如果你时时都有这个念头，是不是有些多了呢？很多时候都只是瞎担心罢了，但最坏的打算恰恰是犹豫不决，因为往往你几个不同的决定是意味着将来不同的道路，但是其实每条路都是光明的。 比如说林书豪，就算他不决定进NBA，他可能完成哈佛经济学的学业，成为一名成功的经济学家；如果贝索斯不创立亚马逊，继续做他的对冲基金，也许很多年后他也会能成为第二个索罗斯。  &lt;/p&gt;
&lt;p&gt;在《从优秀到卓越中》有个飞轮开门的例子，就是无论你是顺时针转动飞轮还是逆时针转动都能将门打开，但一定要坚持，如果你时而顺时针，时而逆时针，那就无论如何都打不开。所以，贵在坚持，如果你认准了一个选择，就毫不犹豫地坚持下去。  &lt;/p&gt;
&lt;p&gt;每个人对选择多少都会有些恐惧，因为选择意味着放弃其中的若干选项，而失去的感觉（即使那是个垃圾）总是让人讨厌的。这在营销中叫作购后失调，就是你买了A商品后，会认为B商品更好；反之买了B商品亦然。负性偏差是每个人都难以避免的，也是人类长期进化出来的心理，人对失去的担心远远大过得到的快乐，因为一次没有发现天敌就会让你丧命，而错过食物顶多饿两个小时肚子。 （具体可见2002年诺贝尔经济学奖得主卡尼曼的“前景理论”前景理论_百度百科）  &lt;/p&gt;
&lt;p&gt;在面对道路选择的时候，只要你去掉几条明显不靠谱的路，那么剩下的路中，每条路都是精彩却又不完美的。每条路都有利也有弊，每条路上鲜花与荆棘并存，没有完美的路，没有哪条路比哪条路更好。“选择就是放弃”，你选择了一条路，也就是在放弃其他的路，阻碍我们做出选择的其实是贪婪和恐惧，舍不得被放弃的路中的鲜花又害怕自己选择路中的荆棘。这样“患得患失”的人活着是很痛苦的。  &lt;/p&gt;
&lt;p&gt;我曾经也是这样痛苦的活着的，后来我开始照着“随便选一个”的方法去选择，我去掉几个不靠谱的路，对于剩下的路我会像你一样分析不同路的优点和缺点，如果还是无法比较出哪条路更好的话，我就会“随便选一个”，现在我活的很快乐，事实证明我选择的路我也都走的很好。拿起一个硬币，高高抛起，正面选A、反面选B，让老天爷帮你“随便选”一条路吧！一旦选好了一条路，就去勇敢的把这条路走得鲜花满路。记住，路是走出来的，不是选出来的。  &lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="select"></category></entry><entry><title>Bargain Snatcher：全自动极速抢购脚本</title><link href="http://particle128.com/posts/2014/03/vipshop.html" rel="alternate"></link><updated>2014-03-10T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-03-10:posts/2014/03/vipshop.html</id><summary type="html">&lt;p&gt;以下汇总的内容均来自本人的博客，或github站点。&lt;/p&gt;
&lt;h3&gt;源码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/particle128/vipshop-buy"&gt;particle128的github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;所用到的技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2013/12/selenium.html"&gt;Selenium WebDriver总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目相关总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2013/12/vipshop-intro.html"&gt;使用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2013/12/vipshop-tech.html"&gt;技术问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://particle128.com/posts/2013/12/vipshop-port.html"&gt;移植到windows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="python"></category><category term="selenium"></category></entry><entry><title>vector的安插语义</title><link href="http://particle128.com/posts/2014/03/inserter.html" rel="alternate"></link><updated>2014-03-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-03-08:posts/2014/03/inserter.html</id><summary type="html">&lt;p&gt;今天做Online Judge的时候，遇到一个问题如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//把A和B两个有序数组合并到A里，A空间足够大  &lt;/span&gt;
&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reserve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果显示A并没有变.  &lt;/p&gt;
&lt;p&gt;稍微考虑了一下，修改第一版如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reserve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果运行正确。  &lt;/p&gt;
&lt;h4&gt;解释：&lt;/h4&gt;
&lt;p&gt;原来的问题是，std::merge方法，最后一个参数是一个OutputIterator，每次合并来的东西都是通过&lt;code&gt;*iter++&lt;/code&gt;这种方式写入的，而&lt;code&gt;operator*&lt;/code&gt;（同理，&lt;code&gt;operator-&amp;gt;&lt;/code&gt;和&lt;code&gt;operator[]&lt;/code&gt;）是覆盖语义，而不是插入语义，并不修改vector中的finish指针，所以std::merge执行完后，temp.begin()和temp.end()都是指向temp的第一个元素，即size()会返回0。  &lt;/p&gt;
&lt;p&gt;不过，我的这次修改，相当于把temp当成普通数组来使用了，并不符合STL的使用规范。temp如果供后续使用，也会是个大隐患，毕竟temp的实际数据已经达到m+n个了，但是temp.size()还是返回0。  &lt;/p&gt;
&lt;p&gt;修改的第二版：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reserve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;back_inserter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;解释：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;back_inserter&lt;/code&gt;包裹函数会返回一个&lt;code&gt;back_insert_iterator&lt;/code&gt;迭代器，std::merge每次调用&lt;code&gt;*iter=xxx&lt;/code&gt;会转化成&lt;code&gt;temp.push_back(xxx)&lt;/code&gt;，即自动将赋值语义转化成安插语义。这样，temp的结构不会被破坏，temp.size()返回m+n。  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;本以为自己动手实现过vector，也看过vector的源码，知识点应该都掌握了，看来还是太年轻了。。。&lt;br /&gt;
这就是为什么很多技术大神，在若干年后还在看一些经典的书籍（比如EffectiveC++，APUE等），知识点看一遍两遍，根本消化不完。  &lt;/p&gt;</summary><category term="cpp"></category><category term="vector"></category></entry><entry><title>Rereading Programming Pearls(6)</title><link href="http://particle128.com/posts/2014/02/pp6.html" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-02-20:posts/2014/02/pp6.html</id><summary type="html">&lt;h2&gt;Column6 Perspective on performance&lt;/h2&gt;
&lt;h3&gt;Design Levels&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;problem definition&lt;br /&gt;
Good specifications are quite important.&lt;br /&gt;
Good error recovery may make a compiler slightly slower, but it usually decreases its overall time by reducing the number of compilations.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;system structure&lt;br /&gt;
Decomposition of a large system into modules is probably the single most important factor in determining its performance.&lt;br /&gt;
After sketching the overall system, you should do a 'back-of-the-envelop' estimate to ensure the performance, because efficiency is much easier to build into a new system than to retrofit into an existing one.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;algorithms&lt;br /&gt;
The keys to a fast module.  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;code tuning  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;system software&lt;br /&gt;
Is a new database system faster for the queries?&lt;br /&gt;
Would a different operating system be better suited to the system?&lt;br /&gt;
Are all possible compiler optimizations are enabled?  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hardware&lt;br /&gt;
general-purpose computers -&amp;gt; special-purpose computers&lt;br /&gt;
adding a floating point accelerator  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Principles&lt;/h3&gt;
&lt;p&gt;Simple design can't be overemphasized:&lt;br /&gt;
&lt;em&gt;The cheapest, fastest and most reliable components of a computer system are thoses that aren't there.&lt;/em&gt;  &lt;/p&gt;</summary><category term="algorithm"></category><category term="cpp"></category></entry><entry><title>Rereading Programming Pearls(7)</title><link href="http://particle128.com/posts/2014/02/pp7.html" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-02-20:posts/2014/02/pp7.html</id><summary type="html">&lt;h2&gt;Column 7 The back of the envelope&lt;/h2&gt;
&lt;h3&gt;rules of thumb&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;rule of 72&lt;br /&gt;
Used for estimating the growth of any exponential process.&lt;br /&gt;
&lt;em&gt;Assume that you invest a sum of money for y years at an interest rate of r percent per year. The financial version of the rule says that if r x y=72, then your money will roughly double.&lt;/em&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tom Duff's rule&lt;br /&gt;
&lt;em&gt;PI seconds is a nanocentury&lt;/em&gt;&lt;br /&gt;
It is to say, a year equals to 3.14 x 10^7s  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;safety factors&lt;/h3&gt;
&lt;p&gt;In calculating our real-time software system, we ought to derate them by a factor of 2, or 4, or 6 to compensate for our ignorance of the problem at hand.  &lt;/p&gt;
&lt;h3&gt;Little's law&lt;/h3&gt;
&lt;p&gt;The average number of things in a system is the product of the average rate at which things leave the system and the average time each one spends in the system. If there is a gross slow balance, the exit rate is also the entry rate.  &lt;/p&gt;</summary><category term="cpp"></category><category term="algorithm"></category></entry><entry><title>《穷爸爸富爸爸》读毕</title><link href="http://particle128.com/posts/2014/02/richdad.html" rel="alternate"></link><updated>2014-02-17T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-02-17:posts/2014/02/richdad.html</id><summary type="html">&lt;p&gt;今天看完了《穷爸爸富爸爸》，的确像网上有些人评论的那样，内容有些拖沓，好多内容出现了重复，其实要表达的观点可以用一篇长文说出来，但是偏偏要凑成一本书。但是它也的确带给我了很多的思考，特别是自己以前一些陋习的反思，记录下来。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;投资于资产而不是负债&lt;br /&gt;
资产是能带来收入的东西，比如房地产（出租、或等升值后转手）、股票等；负债是不能带来收入的东西，比如汽车、用品等。&lt;br /&gt;
启示：把消费性支出维持在低水平，把工作的结余用于投资。大头投资不动产，小头尝试投资风险高一些的项目,如股票。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有意识培养财商&lt;br /&gt;
四项技能组成：会计、投资、市场营销、法律。&lt;br /&gt;
启示：在学习专业技能以维持工作收入的同时，考虑通过书籍和辅导班学一些理财的知识，帮助自己合理理财。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聪明人往往雇佣比自己更聪明的人&lt;br /&gt;
启示：交朋友也是这样。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成功需要的管理素质&lt;br /&gt;
(1) 对现金流的管理，也就是管理自己支出在哪里；
(2) 对时间的管理；
(3) 对人员的管理  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对失败的态度  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大部分人从来不赢是因为他们太害怕失去。如果你看到人类学习的方法，就会明白人类其实就是在犯错误中进行学习的。我们从跌倒中学会了走路，如果我们从不跌倒，就永远也学不会走路。富裕也是同样的道理，不幸的是大部分不富有的主要原因是他们太担心失去。胜利者是不怕失去的，但是失败者都害怕失去。失败是成功之母，如果避开失败，也就避开了成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;启示：穷人因为对损失金钱的恐惧而不敢投资，富人并不是喜欢损失金钱，但是他们从每一次失败中学到东西，最终获得的金钱远大于损失的金钱。  &lt;/p&gt;</summary><category term="finance"></category></entry><entry><title>SSL总结</title><link href="http://particle128.com/posts/2014/01/ssl.html" rel="alternate"></link><updated>2014-01-26T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2014-01-26:posts/2014/01/ssl.html</id><summary type="html">&lt;p&gt;TLS是SSL的升级版，最新版本分别是TLS1.2和SSL3.0，基本过程差不多，只是TLS额外增加了一些防止攻击的方法，还有替换了一些加密算法（比如MD5-SHA-1替换为SHA-256等）.  &lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;p&gt;用RSA分发密钥；用双方商定的对称加密算法加密通信。  &lt;/p&gt;
&lt;h2&gt;使用SSL，服务器和客户端需要首先进行握手（handshake）&lt;/h2&gt;
&lt;p&gt;【1】客户端发送自己SSL通信相关的一些信息（版本号、密码设置等）给服务器&lt;br /&gt;
【2】服务器发送自己SSL通信相关的一些信息，还有自己的证书给客户端&lt;br /&gt;
【3】客户端用各个CA的公钥一一试验解密证书（被某个CA的私钥加密了），取出证书中的公钥和所有者信息，如果所有者信息正是欲通信的对端，用得到的公钥加密（1）客户端选取的pre-master secret（2）客户端的证书（3）客户端私钥加密后的一段会话信息（前面握手过程中产生的数据），发送给服务器。同时，客户端进行一系列操作由pre-master secret生成master secret，进而再产生session key，作为对称加密密钥。&lt;br /&gt;
【4】服务器用自己的私钥解密后，验证客户端证书，用证书中的公钥解密客户端私钥加密后的数据，从而验证了客户端的身份。由客户端发送过来的pre-master secret生成master secret，再生成session key。&lt;br /&gt;
》》之后的通信用session key进行对称加密。&lt;br /&gt;
【5】客户端用对称密钥加密数据，告诉服务器握手过程结束&lt;br /&gt;
【6】服务器用对称密钥加密数据，告诉客户端握手过程结束  &lt;/p&gt;
&lt;h2&gt;补充&lt;/h2&gt;
&lt;p&gt;[0] 对称加密中，公钥和私钥都可以进行加密，另外一个进行解密。&lt;br /&gt;
公钥是可以发给别人的，私钥是永远留在自己本地的。&lt;br /&gt;
公钥加密，最常见，提供加密功能。因为私钥只有对端才有，所以其他人截获了也无法打开，保密功能实现。&lt;br /&gt;
私钥加密，主要用在证书上，提供数字签名功能。如果自己能用公钥解密一个文件，说明该文件一定被私钥加密的，所以一定来自对端，第三方不能伪造，签名功能实现。  &lt;/p&gt;
&lt;p&gt;[1] 证书certificate，在cryptography中全名是public key certificate，又叫digital certificate。&lt;br /&gt;
公钥和公钥所有者一些信息被绑定在证书中，同时证书被CA（certificate authority证书颁发机构）进行了数字签名（也就是用私钥进行加密了）。PKI（public key infrastructure）公钥基础设施方案中，CA是可信的，所以CA的数字签名保证公钥所有者的真实身份。&lt;br /&gt;
证书的意义是：作为公钥的载体，让公钥可以在不加密的信道传输，而不用担心被伪造。  &lt;/p&gt;
&lt;p&gt;[2] 客户端可以不提供证书，这样仅仅保证对端是可信的服务器，而服务器无法确定客户端的身份。&lt;br /&gt;
无论哪种情况，都可以保证客户端和服务器之间的通信是加密的。  &lt;/p&gt;
&lt;p&gt;[3] 过程剖析&lt;br /&gt;
1、2两步通信不加密，用来传递服务器证书；&lt;br /&gt;
3、4两步通信公钥加密，用来传递pre-master secret（对称密钥的雏形）和客户端证书；&lt;br /&gt;
5、6两步以及之后的通信对称加密。&lt;br /&gt;
【1~4】构成3次握手，【5~6】构成2次挥手  &lt;/p&gt;
&lt;p&gt;[4] 身份认证&lt;br /&gt;
客户端的身份是【4】时确定的，解开证书确定公钥是可信的，解开签名确定对端有私钥，身份确定。&lt;br /&gt;
服务器的身份是【6】时确定的，客户端解开证书确定公钥是可信的，服务器用session key加密说明其已经获得了pre-master，必有私钥，身份确定。&lt;br /&gt;
其实，如果服务器在【2】时也传递自己签名的数据过去的话，自己的身份可以提前确定。但是提前确定对后面的步骤没有影响，所以省略传递这个数据，更加节省握手过程中的流量。  &lt;/p&gt;</summary><category term="ssl"></category></entry><entry><title>关于Selenium WebDriver</title><link href="http://particle128.com/posts/2013/12/selenium.html" rel="alternate"></link><updated>2013-12-28T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-28:posts/2013/12/selenium.html</id><summary type="html">&lt;p&gt;用Selenium Webdriver有段时间了，一直learning on demand，浏览了大部分API，并没有对这个工具进行详细和彻底的学习。&lt;br /&gt;
今天正好闲下来，梳理一下相关知识。  &lt;/p&gt;
&lt;h2&gt;Some Links&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://code.google.com/p/selenium/"&gt;工程主页&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://www.seleniumhq.org/docs"&gt;文档主页&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://selenium.googlecode.com/svn/trunk/docs/api/py/index.html"&gt;Python文档&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://selenium-python.readthedocs.org/en/latest/index.html"&gt;Python非官方文档&lt;/a&gt;&lt;br /&gt;
本人的两个使用Selenium的小项目
&lt;a href="https://github.com/particle128/vipshop-buy"&gt;vip.com shop assistant&lt;/a&gt; &lt;a href="https://github.com/particle128/qunar-flight-reminder"&gt;qunar flight-fare reminder&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Some Concepts&lt;/h2&gt;
&lt;h3&gt;敏捷开发（Agile development）&lt;/h3&gt;
&lt;p&gt;是一个软件开发方法学，强调3点：&lt;br /&gt;
(1)adaptive&amp;gt;predictive (2)iterative&amp;gt;waterfall (3)codes&amp;gt;documents&lt;br /&gt;
强调软件快速迭代，随着需求变化而修改或重构程序，而不是一开始就为将来可能出现的所有需求来设计。  &lt;/p&gt;
&lt;h3&gt;极限编程（extreme programming）&lt;/h3&gt;
&lt;p&gt;是敏捷开发中最有成效的方法，强调简单（只为今天的需求设计）、勇气（对随时可能进行的重构做好心里准备）等。  &lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;selenium是一个自动化测试工具（test automation），常被用来进行回归测试（regression test），因为回归测试在每次增加新的功能或修复bug之后都要进行，每次都人力测试太麻烦了。&lt;br /&gt;
它其实是一个软件集(Tool Suite)，包含4个工具：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selenium 2（aka. Selenium Webdriver）：向下兼容Selenium RC，额外提供了面向对象的API  &lt;/li&gt;
&lt;li&gt;Selenium 1 (aka. Selenium RC or Remote Control)：支持多种语言，Java，C#，Javascript，Ruby，Perl，PHP，Python  &lt;/li&gt;
&lt;li&gt;Selenium IDE：Firefox的一个插件，提供类似VS自带的自动化测试工具的功能  &lt;/li&gt;
&lt;li&gt;Selenium-Grid：使Selenium RC可以在多台机器上并行处理&lt;br /&gt;
它支持多种浏览器和平台，至少支持Windows，Linux，MacOS支持，至少支持Chrome,Firefox,IE。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Selenium WebDriver&lt;/h2&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Selenium RC : 对于所有浏览器，都注入(inject)同样的javascript代码，通过调用js代码实现对浏览器的操作&lt;/li&gt;
&lt;li&gt;Selenium WebDriver : 直接调用浏览器原生的接口来&lt;em&gt;控制浏览器&lt;/em&gt;，不同浏览器为自动化留的接口不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Selenium-Server&lt;/h3&gt;
&lt;p&gt;一般情况只使用WebDriver就可以满足要求，以下情况还要安装Server&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Selenium-Grid&lt;/li&gt;
&lt;li&gt;测试脚本和浏览器不在同一台机器上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;API Commands and Operations&lt;/h3&gt;
&lt;h4&gt;fetching a page&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.google.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不同操作系统/浏览器的搭配，可能使get方法有不同的效果：有的等待页面加载完返回，有的不等待直接返回。
Linux/ChromeDriver的情况是：等待加载完才返回。
出于健壮性考虑，建议使用Explicit/Implicit waits&lt;/p&gt;
&lt;h4&gt;locating web elements&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ele&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="n"&gt;_by_id&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;class_name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tag_name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;link_text&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;css_selector&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;xpath&lt;/span&gt;
&lt;span class="n"&gt;inputs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_script&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;var inputs=...return inputs&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 保证返回element对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;css_selector&lt;/code&gt;参考 &lt;a href="http://www.w3.org/TR/CSS/#selectors"&gt;标准格式&lt;/a&gt;
xpath参考 &lt;a href="http://www.w3school.com.cn/xpath"&gt;w3c文档&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;user input&lt;/h4&gt;
&lt;p&gt;下拉列表的处理&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# available since 2.12&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Select&lt;/span&gt;
&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_tag_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;select&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deselect_all&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;select_by_visible_text&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Edam&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提交表单&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#方法1：找到对应的按钮，然后调用click()&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="c"&gt;#方法2：表单中的任何一个元素调用submit()，WebDriver会帮你找到包裹这个元素的最里层的form然后提交&lt;/span&gt;
&lt;span class="n"&gt;ele&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;submit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;moving between windows and frames&lt;/h4&gt;
&lt;p&gt;默认在当前window和当前frame中定位元素，切换窗口和帧&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;switch_to_window&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;window1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;switch_to_frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;frameName.0.child&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#frameName的第一个子frame的名叫child的子frame&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;弹出对话框的处理&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;alert&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;switch_to_alert&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#适用于alerts,confirms,prompts&lt;/span&gt;
&lt;span class="n"&gt;alert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dismiss&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;读取和写入&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;前进后退，cookies&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;back&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;...&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#必须先到达一个站点，才能设置cookie&lt;/span&gt;
&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_cookie&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;value&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;托拽&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.action_chains&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;ActionChains&lt;/span&gt;
&lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;source&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;target&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;target&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;ActionChains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;drag_and_drop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perform&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;显式和隐式等待&lt;/h4&gt;
&lt;p&gt;explicit wait&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.common.by&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;By&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support.ui&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;WebDriverWait&lt;/span&gt; &lt;span class="c"&gt;# available since 2.4.0&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium.webdriver.support&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;expected_conditions&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;EC&lt;/span&gt; &lt;span class="c"&gt;# available since 2.26.0&lt;/span&gt;

&lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://somedomain/url_that_delays_loading&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;WebDriverWait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EC&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;presence_of_element_located&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;By&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;myDynamicElement&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;implicit wait&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;selenium&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;

&lt;span class="n"&gt;ff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webdriver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Firefox&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;implicitly_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# seconds&lt;/span&gt;
&lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://somedomain/url_that_delays_loading&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;myDynamicElement&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ff&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myDynamicElement&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="selenium"></category></entry><entry><title>常量map容器只能调用find来获取元素</title><link href="http://particle128.com/posts/2013/12/map-operator.html" rel="alternate"></link><updated>2013-12-18T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-18:posts/2013/12/map-operator.html</id><summary type="html">&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;做我的http server的时候，遇到了个错误，出错相关代码如下  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="cm"&gt;/* ... */&lt;/span&gt;  
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;status_map_t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;status_map_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;init_status_code&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;status_map_t&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;200 OK&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;404&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;404 Not Found&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;500&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;500 Internal Error&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;status_map_t&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;init_status_code&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;header_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//??? why can&amp;#39;t define const status_map_t&amp;amp; status_code=init_status_code();  &lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;报错如下  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;passing&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;status_map_t&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;aka&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;}&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; 
&lt;span class="err"&gt;‘&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Alloc&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;mapped_type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Alloc&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;
&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Alloc&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;key_type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;)&lt;/span&gt; 
&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;_Key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;,&lt;/span&gt; 
&lt;span class="n"&gt;_Alloc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;allocator&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;,&lt;/span&gt; 
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Alloc&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;mapped_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*,&lt;/span&gt; 
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;_Key&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Tp&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Compare&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_Alloc&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;key_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;’&lt;/span&gt; &lt;span class="n"&gt;discards&lt;/span&gt; &lt;span class="n"&gt;qualifiers&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Analysis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;编译错误，去掉[]中的类型解释，去掉复杂的map类型信息，得简化版本如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;passing&lt;/span&gt; &lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="n"&gt;status_map_t&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;this&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;mapped_type&amp;amp; operator[](key_type&amp;amp;)&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题很明显了，&lt;strong&gt;const对象不能调用non-const成员函数，而operator[]是map的non-const成员函数&lt;/strong&gt;。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么map容器不提供operator[]的const版本呢？&lt;br /&gt;
operator[]的原理是：如果存在给定的键，则返回对应的值；如果不存在给定的键，则插入一个(key,mapped_type())，并返回这个缺省值。&lt;br /&gt;
既然operator[]可能对map进行insert操作，肯定不能定义const版本了。&lt;br /&gt;
m[k]等价于&lt;code&gt;m.insert(value_type(k,mapped_type())).first-&amp;gt;second&lt;/code&gt;&lt;br /&gt;
注意：insert的原型如下  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//bool=true，返回的iterator指向新插入的元素；bool=false，返回的iterator指向对应key的原来的元素  &lt;/span&gt;
&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;value_type&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;operator[]可以用find和insert来代替，const map只能使用find函数来获取元素  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;header_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pstr&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status_code&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="STL"></category><category term="map"></category></entry><entry><title>MoreEffectiveC++(4)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(4).html" rel="alternate"></link><updated>2013-12-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-14:posts/2013/12/MoreEffectiveCpp(4).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;技术Techniques,Idioms,Patterns&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item25 构造函数、非成员函数的虚化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;这一条目所指的“虚化”，并不是C++语法意义上的虚化，而是“动态调用”的意思。  &lt;/li&gt;
&lt;li&gt;3种语义上的虚化：&lt;br /&gt;
1.虚构造函数&lt;br /&gt;
根据输入（磁盘、网络、终端），可产生不同类型的对象，保存于&lt;code&gt;list&amp;lt;Base*&amp;gt;&lt;/code&gt;中&lt;br /&gt;
2.虚拷贝构造函数&lt;br /&gt;
定义虚函数clone，返回一个指针，指向调用者副本（&lt;code&gt;return new TextBlock(*this);&lt;/code&gt;），复制构造函数通过基类指针调用不同的clone&lt;br /&gt;
3.虚非成员函数&lt;br /&gt;
定义虚函数print，参数和返回值都是ostream&amp;amp;，定义非成员函数&lt;code&gt;inline ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream&amp;amp; s,const Base&amp;amp; c){return c.print(s);}&lt;/code&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item26 限制一个类所能产生的对象数量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;杂类知识：&lt;br /&gt;
1.不能在类成员变量里定义自身类型的对象，否则编译器报错&lt;code&gt;incomplete type&lt;/code&gt;。但是可以在类成员函数（包括inline构造函数）中定义该类类型的对象。&lt;br /&gt;
2.希望该类不能实例化对象，声明protected ctor；希望该类不能被继承和实例化对象，声明private ctor。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:The above method can only restrict the construction of objects on the stack. Because you can define a static/friend function, in which new an object and return a pointer to that.&lt;br /&gt;
3.基类指针、引用指向派生类对象，必须是public继承，private和protected继承都会报错&lt;code&gt;'Base' is an inaccessible base of 'Derived'&lt;/code&gt;。一般允许当作基类的类都要定义virtual dtor，但是如果该基类只被private或protected继承的话，不需要定义虚析构函数。  &lt;/li&gt;
&lt;li&gt;限制对象数量，方法如下：&lt;br /&gt;
(1)声明private ctor，友元/静态成员函数定义如下  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;thePrinter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Printer&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;评价：仅限于只允许一个对象的情况&lt;br /&gt;
(2)类中定义静态数据成员count，定义一个异常类TooManyObject，构造函数计算count并抛出异常&lt;br /&gt;
评价：允许多个对象；但是，继承或包含该类的类的定义，也会造成count累积抛出异常。&lt;br /&gt;
(3)同上，另外构造函数私有化，提供友元/静态成员函数&lt;code&gt;makePrinter(){return new Printer()}&lt;/code&gt;。&lt;br /&gt;
评价：允许多个对象，不会出现上述问题，因为直接就不让继承该类或定义该类的对象了；但是，只能产生heap上的对象，需要手动delete或放到智能指针里。&lt;br /&gt;
(4)定义计数类模版  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;//每个class类型有一个计数器（maxObjects），所以定义成模版  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;  
&lt;span class="nl"&gt;protected:&lt;/span&gt;  
    &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//protected构造函数，防止实例化  &lt;/span&gt;
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;maxObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;numObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//不定义maxObjects，让用户自己定义，比如const size_t Counted&amp;lt;Printer&amp;gt;::maxObjects=10;  &lt;/span&gt;
&lt;span class="c1"&gt;//私有继承，语义上是：implemented in terms of；功能上是：防止基类指针/引用访问派生类对象  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Counted&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;TwoManObjects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item27 要求，或禁止对象产生于堆上&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为什么需要对象产生于堆上：&lt;br /&gt;
需要一种对象，可以在作用域离开之前撤销自己，即&lt;code&gt;delete this&lt;/code&gt;的功能。  &lt;/li&gt;
&lt;li&gt;为什么需要对象禁止在堆上产生：&lt;br /&gt;
嵌入式系统中堆上的资源比较有限  &lt;/li&gt;
&lt;li&gt;要求对象产生于堆上：&lt;br /&gt;
1.private/protected dtor,public ctors&lt;br /&gt;
2.定义&lt;code&gt;public void destory const(){delete this;}&lt;/code&gt;&lt;br /&gt;
这样，只能通过Obj* po=new Obj;调用，只能通过po-&amp;gt;destory()释放。因为定义类的对象（Obj o;）的时候会检查ctor和dtor的可访问性，有一个不可访问就会编译出错。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：&lt;br /&gt;
1.private ctors也可以限制构造对象，但是构造函数比较多，都需要一一定义为private，不如析构函数方便&lt;br /&gt;
2.如果需要保证继承，将dtor定义为protected.  &lt;/li&gt;
&lt;li&gt;禁止对象产生于堆上：&lt;br /&gt;
定义private限定的operator new，operator delete，operator new[]，operator delete[]&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;:基类的operator new私有化，那么派生类如果不在public里重新定义operator new，调用Derived *pd=new Derived;就会出错。只要Derived类中存在operator new，即使不可访问（private或protected），new操作符也不会转而调用全局作用域的operator new。  &lt;/li&gt;
&lt;li&gt;没有具备移植性的正确的办法，可以判断一个对象位于堆内。&lt;br /&gt;
1.定义类内static bool isOnHeap，类内operator new设置isOnHeap，构造函数判断isOnHeap的值，并在最后恢复isOnHeap为false&lt;br /&gt;
缺点：线程不安全；new一个数组会出错，即使定义了operator new&lt;a href="分配一次，构造多次，第二个构造中isOnHeap为false"&gt;&lt;/a&gt;&lt;br /&gt;
2.根据进程在内存中的布局（栈位于最高地址，向下增长；静态存储区位于最低地址，向上增长；堆位于静态存储区上，向上增长）  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//栈顶，最低地址  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//只有堆地址或静态存储区才小于栈地址  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺点：布局依赖操作系统实现，不具备移植性；无法区分静态和堆上的对象  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法明确确定位于堆上，但是可以比较容易的判断是否可以delete&lt;br /&gt;
1.定义全局operator new，分配空间的同时，保存这个地址在一个全局list里。全局operator delete判断全局list里是否存在该地址&lt;br /&gt;
缺点：污染其他代码；效率；Base1* pb=new Derived()，多重继承下基类地址可能不同于派生类对象地址，造成判断错误&lt;br /&gt;
2.定义abstract mixin base class（抽象混合式基类），把operator new,operator delete，list都保存于其中  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;HeapTrack&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;isOnHeap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//解决上述第3个问题，把基类this指针转换成派生类对象地址  &lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rawAddr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="cm"&gt;/*判断list中是否包含rawAddr*/&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：派生类中的基类函数，参数this的类型为指向基类类型的指针常量。否则一个类被多个类继承，该类的所有函数就要有多份重载的代码。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(5)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(5).html" rel="alternate"></link><updated>2013-12-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-14:posts/2013/12/MoreEffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item28 Smart pointer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;智能指针相比于内置指针的优势：&lt;br /&gt;
1.构造和析构：分别防止wild指针（默认实参是0）和内存泄露（dtor内delete对象）&lt;br /&gt;
2.复制和赋值：可以定义出3种语义：深复制、浅复制(加引用计数、或转移控制权)、不允许复制&lt;br /&gt;
3.解引用(dereference)：包括&lt;code&gt;-&amp;gt;&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;操作符(都是const函数)，可以实现出lazy fetching（数据库中的对象的访问）  &lt;/li&gt;
&lt;li&gt;志记工作最好使用一个类的构造函数和析构函数(自动调用)来标明开始和结束，而不是显示调用两个函数。这对异常更加稳健。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;作为参数，必须引用传递，否则调用之后，原&lt;code&gt;auto_ptr&lt;/code&gt;对象中的指针为0，不能访问了。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：除了内置类型、STL迭代器、函数对象，其余对象最好都用引用传递参数  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的operator=操作符，需要在开始处判断&lt;code&gt;if (this==&amp;amp;rhs)&lt;/code&gt;，因为之后会&lt;code&gt;delete rhs&lt;/code&gt;。&lt;br /&gt;
不需要判断，只调整语句顺序的情况：&lt;br /&gt;
1.new+delete都有的函数:deep copy&lt;br /&gt;
2.new+delete都没有的函数:复制值  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的对象，如果保存的不是new分配的堆对象，释放的时候会段错误，编译没有错误。  &lt;/li&gt;
&lt;li&gt;pt是一个对象，&lt;code&gt;pt-&amp;gt;display()&lt;/code&gt;会被编译器翻译成&lt;code&gt;(pt.operator-&amp;gt;())-&amp;gt;display()&lt;/code&gt;，(1)返回的对象keyi调用&lt;code&gt;-&amp;gt;&lt;/code&gt;操作符，(2)返回a pointer。  &lt;/li&gt;
&lt;li&gt;提供功能，测试智能指针是否为null&lt;br /&gt;
1.添加成员函数&lt;code&gt;isNull()&lt;/code&gt;：不直观，无法调用if(ptn)或if(ptn==0)或if(!ptn)&lt;br /&gt;
2.重载&lt;code&gt;operator bool()&lt;/code&gt;，或&lt;code&gt;opertor!()&lt;/code&gt;：前者3种形式都满足，但是可能允许不同类型的指针互相比较，后者则只能实现第3种语义&lt;br /&gt;
3.转换操作符&lt;code&gt;operator T*()&lt;/code&gt;：3种形式都满足，但是允许用户delete SmartPtr类型对象，会导致内存泄露。&lt;br /&gt;
总结：可以使用第二种方法，但是定义const get()成员函数返回原始指针。  &lt;/li&gt;
&lt;li&gt;要实现&lt;code&gt;SmartPtr&amp;lt;Base&amp;gt;&lt;/code&gt;的指针或引用，指向&lt;code&gt;SmartPtr&amp;lt;Derived&amp;gt;&lt;/code&gt;对象：&lt;br /&gt;
1.特化&lt;code&gt;SmartPtr&amp;lt;Derived&amp;gt;&lt;/code&gt;，并定义如下转换操作符:  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointee&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺点：必须所有派生类，而且必须给每一个派生类特化版本定义到所有基类（包括间接基类）的转换函数，因为不允许2次类类型转换.&lt;br /&gt;
2.在SmartPtr模版里定义如下成员模版：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointee&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：不仅适用于派生体系，只要raw pointer可以隐式转换，包裹在外面的SmartPtr都可以隐式转换，比如non-const指针转成const指针；non-void指针转成void指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_con&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_void&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base_of_T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sp_base&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//此处函数参数必须为常量引用，因为转换操作符返回一个临时对象  &lt;/span&gt;
&lt;span class="c1"&gt;//(临时对象：源码中不可见的对象，比如函数返回值、异常对象、表达式结果对象(比如1+2))  &lt;/span&gt;
&lt;span class="c1"&gt;//临时对象不能传递给非常量引用，因此编译器不允许调用转换操作符  &lt;/span&gt;
&lt;span class="c1"&gt;//这是C++对函数参数的一个语义限制，因为非常量引用在函数中可能被修改  &lt;/span&gt;
&lt;span class="c1"&gt;//而如果该修改作用在临时对象上，函数返回之前会被销毁，无法传递给程序，所以不允许.  &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;SmartPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Base_of_T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;  
&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;再次强调，非常量引用不能指向临时对象&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：以上两种实现中，都含有SmartPtr的构造函数，参数是原始指针。原始指针出现在继承体系的两个对象中，所以不能使用auto_ptr的构造和析构函数，否则会出现多次delete同一块内存的情况，应当使用reference counting。&lt;br /&gt;
&lt;em&gt; 派生类指针，转换成距离自己更近的基类指针的代价更小，不会造成二义性。&lt;br /&gt;
&lt;/em&gt; const T * const 对应的智能指针版本就是：&lt;code&gt;const SmartPtr&amp;lt;const T&amp;gt;&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item29 Reference counting(引用计数)&lt;/h2&gt;
&lt;p&gt;略  &lt;/p&gt;
&lt;h2&gt;Item30 Proxy classes(代理类)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代理类的使用场景&lt;br /&gt;
1.抑制单参构造函数所引起的隐式类类型转换&lt;br /&gt;
在不支持explicit的情形下，可以通过代理类模拟explicit的行为。&lt;br /&gt;
思路:类类型转换只能进行一次，让参数进行一次，那么所要限制的类本身就不能隐式类型转换了。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//代理类，用来代理Array构造函数的参数  &lt;/span&gt;
            &lt;span class="nl"&gt;public:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.构造出多维数组类型，且使用起来像arr[1][2]&lt;br /&gt;
C++标准中不支持每维都是变量的多维数组（C99中好像支持），自定义类类型Array2D。&lt;br /&gt;
C++中又不能重载operator[][]函数，所以通过代理类模拟Array2D[1][2]的访问方式。&lt;br /&gt;
思路:Array2D的operator[]返回返回一个代理类对象Array1D，Array1D支持operator[]返回一个实际对象  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array2D&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;Array1D&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="c1"&gt;//代理类，用来代理第一维的operator[]的返回值  &lt;/span&gt;
            &lt;span class="nl"&gt;public:&lt;/span&gt;  
                &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;Array1D&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//Array1D是函数内局部对象，所以不返回引用  &lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Array1D&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;:如果可以接受array(1,2)这种访问二维数组的方式，可以重载operator(int idx1,int idx2)函数&lt;br /&gt;
3.区分operator[]的读写行为  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;String&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CharProxy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//写  &lt;/span&gt;
                &lt;span class="n"&gt;CharProxy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//写  &lt;/span&gt;
                &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//读  &lt;/span&gt;
            &lt;span class="nl"&gt;private:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
                &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;theString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;CharProxy&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//省略const版本  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;代理类有其限制  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;=&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//&amp;amp;不可以  &lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="c1"&gt;//传递给reference-to-non-const出错，因为是代理类的临时对象而不是引用  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有些限制可以通过重载操作符来实现，非常麻烦。而传递参数的问题则没法避免。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(3)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(3).html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-06:posts/2013/12/MoreEffectiveCpp(3).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;效率Efficiency&lt;/strong&gt;  &lt;/p&gt;
&lt;h2&gt;Item16 80-20 principal&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Most programs' performance bottle-neck is inclined to high counter-intuition. If you just improve programs here and there, it won't help a lot.  &lt;/li&gt;
&lt;li&gt;The accurate way to do this is to use program profiler(程序分析器).  &lt;/li&gt;
&lt;li&gt;Offer as much data as possible to the profiler, to find the real bottle-neck.  &lt;/li&gt;
&lt;li&gt;Make sure that every group of data is representative(典型的，可重现的).  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item17 consider to use Lazy Evaluation(缓式评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;First of all, let me quote a sentence：  &lt;blockquote&gt;
&lt;p&gt;从效率的观点来看，最好的运算是从未被执行的运算。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Lazy evaluation means you should write your class in the way that calculation should be made only when it's urgent.&lt;br /&gt;
Three usages:&lt;br /&gt;
1.reference counting&lt;br /&gt;
Maybe some copy behaviour is no use.  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abcd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;MyStr&lt;/span&gt; &lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//need not malloc and copy,just assign a pointer  &lt;/span&gt;
&lt;span class="n"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConvertToUpper&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//need to malloc and copy  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.lazy fetching&lt;br /&gt;
Maybe a large table only need a small part.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LargeObject&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;LargeObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//just assign private pointers to 0  &lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;field1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//connect to the database and fetch data  &lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;field2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;ObjectID&lt;/span&gt; &lt;span class="n"&gt;oid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fieldValue1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;mutable&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filedValue2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.lazy expression evaluation&lt;br /&gt;
Maybe you just need to calculate some parts.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Matrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//just store two pointers to m2 and m3,and a enum indicating it&amp;#39;s addition  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//only calculate the fourth line//define operator[]  &lt;/span&gt;
&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;m3&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;m4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//have to change m1,which has a pointer to m2.//overload operator+  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;Don't over do it.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item18 consider to use Over-Eager Evaluation(超急评估)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Two usages:&lt;br /&gt;
1.caching  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="nf"&gt;CubicleNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Cubicle&lt;/span&gt; &lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//访问数据库耗时，访问缓存快速  &lt;/span&gt;
    &lt;span class="n"&gt;CubicleMap&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;cubes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*get info from the databse and update cubes*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;it&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//more portable than it-&amp;gt;second}  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.prefetching&lt;br /&gt;
when it needs x spaces, allocate 2x spaces.
因为系统调用（operator new中malloc）耗时，所以尽量一次分配更多的空间。调用进程内函数快速。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trade space for time.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item19 understand the sources of Temporary Objects&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C++中的临时对象是在栈上分配的匿名对象或不可见对象。&lt;/li&gt;
&lt;li&gt;匿名对象举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;不可见对象两种情况：&lt;br /&gt;
1.隐式类型转换得到的对象。
&lt;strong&gt;Note&lt;/strong&gt;:reference-to-non-const参数不能接受需要隐式类型转换的对象，因为参数可能会在函数中被修改，而修改仅仅作用于临时对象，C++禁止这种行为，编译失败，报错&lt;code&gt;invalid initialization of non-const reference of type ‘std::string&amp;amp; {aka std::basic_string&amp;lt;char&amp;gt;&amp;amp;}’ from an rvalue of type ‘char*’&lt;/code&gt;&lt;br /&gt;
2.返回对象。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item20 降低返回值临时对象的成本return value optimization(RVO)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;书上说在return表达式中，返回匿名临时对象（比如&lt;code&gt;return Rational(lhs.num()*rhs.num(),lhs.den()*rhs.den())&lt;/code&gt;），可以让编译器进行返回值优化（消除匿名临时对象以及返回值临时对象的构造和析构函数成本。把函数中return语句后面的内容提到调用者作用域中，&lt;code&gt;Rational c=a*b;&lt;/code&gt;中仅有c的构造成本）。  &lt;/li&gt;
&lt;li&gt;注释又说“1996年ISO/ANSI标准委员会又宣布，返回命名对象和匿名对象都可以借助RVO被优化去掉。”后者可能在编译器下具备更好的优化性能。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item21 消除参数临时对象的成本use overload&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以重载一堆函数，来代替隐式类型转换，来消除参数临时对象的构造和析构成本。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:每个重载操作符，都必须获得至少一个“用户定制类型”的自变量。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item22 操作符复合形式效率&amp;gt;独身形式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果编译器无法进行RVO，那么operator+运算，会构造并析构两个对象：局部对象和返回值临时对象。替换成类内成员函数operator+=，则无需构造这两个对象。  &lt;/li&gt;
&lt;li&gt;可行的方案是：类内定义operator+=，类外定义模版operator+（使用对象的operator+=）。&lt;br /&gt;
&lt;strong&gt;Note&lt;/strong&gt;:匿名对象比命名对象容易被消除，所以尽量选择前者。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item23 考虑使用其他程序库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用benchmark(性能评估软件)，判断某个程序库在特定软件里，性能如何，然后做出取舍。  &lt;/li&gt;
&lt;li&gt;iostream比stdio的速度慢20%~200%，程序大小也大很多，但是如果io不是瓶颈，不需要用stdio代替iostream，毕竟类型安全。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item24 了解虚函数等的成本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;看完Inside C++ Object Model回来看，现在看的不是很透彻。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(2)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(2).html" rel="alternate"></link><updated>2013-12-03T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-03:posts/2013/12/MoreEffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item6&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自增自减操作符，两原则：&lt;br /&gt;
1.postfix increment和decrement操作符，应该返回const对象，理由是：不允许进行两次后置++，防止用户把比较操作符写成赋值操作符而通过编译。  &lt;blockquote&gt;
&lt;p&gt;设计类的一条无上宝典就是：一旦有疑虑，试看int行为如何并遵循之。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.后自增和自减应该调用前自增和自减，而不是自己写函数，这样只需要维护前自增。  &lt;/p&gt;
&lt;h2&gt;Item7&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要重载&amp;amp;&amp;amp;，||和，操作符，因为无论定义成员或非成员函数，都无法模拟C++中这3个操作符的行为模式（短路，求值顺序）。  &lt;/li&gt;
&lt;li&gt;for语句头包括3个部分，第1部分是语句，所以可以定义多个变量。第3部分是表达式，所以只能用逗号隔开多个表达式，而不能使用定义变量。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item8&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;placement new类似于new，首先调用operator new，然后调用对象构造函数，然后返回内存指针。&lt;br /&gt;
不同点，是placement new调用的operator new的原型和实现如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//第一个参数不提供名字，防止编译器警告。  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;placement new构造的对象，可能位于operator new分配的内存，也可能不是。如果不确定是不是，就不要调用delete来释放，否则可能未定义。因为delete析构对象之后调用operator delete释放内存，而这段内存如果是malloc分配的，或者是静态的内存，用operator delete释放都会出问题。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;异常Exception&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item9&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;利用析构函数(smart pointer处理单个对象，vector处理对象数组)避免资源泄露，绝不使用操纵局部资源的指针。&lt;br /&gt;
因为即使加了try和catch语句块包裹可能出现异常的代码，也会把代码变得支离破碎，而且delete会出现两遍（正常执行序列的最后，catch中throw到上一层之前）  &lt;/li&gt;
&lt;li&gt;C++加入异常的概念，意义：&lt;br /&gt;
保证错误的发生绝不会被忽略，而C语言中置errno或返回错误代码的方法，都可能因为调用者的不检查而使错误不被发现。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item10 在构造函数中阻止资源泄露(resource leak)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对象未构造完全(构造函数中抛出异常)，不会调用其析构函数，但是对象的成员变量会保证释放（如果是类类型，自动调用其析构）。在ctor中动态分配资源可能因为异常的出现，泄露了。&lt;br /&gt;
原因：&lt;br /&gt;
析构函数如果需要在构造不完全的对象上自动执行，就得记录构造函数执行到的位置，代价太大。  &lt;/li&gt;
&lt;li&gt;构造函数动态分配资源的情况下，防止资源泄露的解决办法&lt;br /&gt;
1.构造函数中try+catch&lt;br /&gt;
2.类中使用auto_ptr成员代替指针成员  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item11 禁止异常流出dtor&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;析构函数调用时机&lt;br /&gt;
1.退出作用域&lt;br /&gt;
2.stack unwinding时&lt;br /&gt;
3.delete&lt;br /&gt;
4.手动调用  &lt;/li&gt;
&lt;li&gt;禁止异常流出的原因：&lt;br /&gt;
1.避免在stack unwinding时，析构函数抛出的异常导致terminate函数执行，中止程序。&lt;br /&gt;
考虑上线的软件，因为1个异常就down机了，这绝不是人们想看到的。&lt;br /&gt;
2.协助确保dtor完成了所有事情。&lt;br /&gt;
考虑析构函数有多条语句，第一条语句执行中抛出异常，后面的语句没法执行，但是可能很重要，比如释放对象资源。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item12 区分异常和函数调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如下示例：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;  
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;rw&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//抛出的是类型为Base的异常对象。只有在基类指针或引用指向派生类对象，且调用虚函数的情况下才会看动态类型，其余都是静态类型。  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;异常对象是抛出对象的副本，是一个临时对象，一般临时对象不能给非常量引用赋值。但是catch字句中non-const引用也可以捕获，这是一个特例。  &lt;/li&gt;
&lt;li&gt;异常和函数调用区别：&lt;br /&gt;
1.总会被复制，需要支持复制构造&lt;br /&gt;
2.允许的类型转换很少(非const到const，派生类到基类(指针引用对象都可)，指针到void*，数组到数组指针，函数到函数指针)&lt;br /&gt;
3.按catch子句出现的顺序匹配，而不是最佳匹配  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item13 以引用方式捕获异常&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;原因：&lt;br /&gt;
1.by-pointer:不知道是全局和静态对象，还是动态对象，所以不知道要不要delete；和语言本身可能抛出的异常(bad_alloc等)不符合&lt;br /&gt;
2.by-value:切割对象，无法多态；复制对象成本高&lt;br /&gt;
3.by-reference:没上面的问题  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item14 异常说明符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;try和catch后面的语句必须用大括号包围，即使只有1条语句。  &lt;/li&gt;
&lt;li&gt;当抛出exception specification中没有出现的异常时，unexpected函数会被系统调用，默认调用terminate中止程序。&lt;br /&gt;
就像不希望析构函数抛出异常一样，必须防止任何中止程序(很可能是需要一直运行的服务程序)的行为，即使有错误发生。&lt;br /&gt;
注意：&lt;br /&gt;
1.不要给模版函数提供异常说明。因为模版的类型实参千变万化，无法预料抛出异常的情况。&lt;br /&gt;
2.需要调用没有异常说明的函数，自己也不要给出异常说明。&lt;br /&gt;
3.不使用默认版本的unexcepted函数：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一种方式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;{};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;UnexpectedException&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;span class="c1"&gt;//第二种方式  &lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="p"&gt;;}&lt;/span&gt;&lt;span class="c1"&gt;//重抛，默认抛出bad_exception  &lt;/span&gt;
&lt;span class="n"&gt;set_unexpected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//用定制版本  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：采用了上面任一种方式后，需要在函数的异常说明符中加入UnexpectedException或bad_exception，否则还是会terminate。  &lt;/p&gt;
&lt;h2&gt;Item15 understand exception handling's cost&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;即使从未使用exception处理机制，程序为了支持exception，也需要放置一些数据结构占用空间，维护这些数据结构占用时间。  &lt;/li&gt;
&lt;li&gt;try语句，以及异常说明，会导致代码膨胀和速度下降5%~10%（一些测试结果，并未很准确）。异常的真正抛出，会比正常函数返回，慢3个数量级（同上，不准确）。  &lt;/li&gt;
&lt;li&gt;代价很大，所以仅在非用不可的时候才使用，不要像写python那样轻易使用。  &lt;/li&gt;
&lt;li&gt;如果确保自己的程序中没有用到exception机制，并且确保调用的标准库没有用到，例如没有try catch throw关键字，那么可以通过编译器的选项禁止。&lt;br /&gt;
g++下的禁止方式是&lt;code&gt;-fno-exceptions&lt;/code&gt;。如果有异常抛出（new无法分配等），直接调用std::abort()进行中止。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(1)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(1).html" rel="alternate"></link><updated>2013-12-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-02:posts/2013/12/MoreEffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有实现bool类型的编译器，替代方案：&lt;br /&gt;
(1)enum bool{false,true};&lt;br /&gt;
缺点：无法int赋值给bool变量&lt;br /&gt;
(2)typedef int bool;&lt;br /&gt;
const bool false=0;&lt;br /&gt;
const bool true=1;&lt;br /&gt;
缺点：无法重载bool和int参数的函数  &lt;/li&gt;
&lt;li&gt;C++中内存泄露，不一定只是new出的对象中的数据成员泄露了，还可能在构造函数(ctor)中创建了其他资源，也泄露了。   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;基础议题Basics&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有null reference，所以有时候使用引用可能比使用指针更有效率。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//使用指针  &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;*&lt;/span&gt;&lt;span class="n"&gt;pd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//使用引用  &lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;rd&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;const_cast用于改变constnest和valatileness  &lt;/li&gt;
&lt;li&gt;reinterpret_cast与编译器息息相关，不具备移植性。最常见用途：转换函数指针  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  
&lt;span class="n"&gt;FuncPtr&lt;/span&gt; &lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;funcPtrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;FuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;经典语录&lt;blockquote&gt;
&lt;p&gt;让转型动作既丑陋又不易键入，或许未尝不是件好事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item3&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要以多态方式处理数组，因为数组对象总是会涉及指针算术运算，而指针位置的移动是按照指针类型的对象大小来算的，而不是指向实际对象大小。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//pb[i]是*(pb+i)的简写，代表pb+i*sizeof(Base)  &lt;/span&gt;
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//同样不行，相当于循环中从后向前调用pb[j].~Base();  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item4&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不提供默认构造函数，会有3个限制：&lt;br /&gt;
1.不方便定义数组，以普通方式（&lt;code&gt;X a[N]&lt;/code&gt;）定义的数组调用默认构造函数&lt;br /&gt;
解决：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//第一个方法，仅用于静态数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)};&lt;/span&gt;   
&lt;span class="c1"&gt;//第二个方法，动态数组，需要额外空间保存指针数组  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;pX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//或 X* pX[3];  &lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//第三个方法，动态数组，不需要额外空间  &lt;/span&gt;
&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;xArr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.不适于很多基于模版的容器类(template-based container class)&lt;br /&gt;
因为很多容器类都有单参构造函数，参数是容器的size，所以里面可能调用的&lt;code&gt;data=new T[size];&lt;/code&gt;。&lt;br /&gt;
但是设计良好的模版类，应该不依赖默认构造函数，像vector，可能使用上面3种方法的后两种解决的。&lt;br /&gt;
3.虚基类如果没有默认构造函数，对于派生类来说非常不方便。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是如果提供默认构造函数，可能产生没有被完全初始化的对象，如果如果不在乎上面的3个限制（不需要面对数组，不需要存入默认容器，不需要做虚基类），就不提供默认构造函数。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;操作符operators&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Item5&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注意右尖括号中间加空格，否则会因为词法分析是用的贪心算法，两个尖括号会组成了一个词法单元。&lt;br /&gt;
&lt;code&gt;static_cast&amp;lt;Array&amp;lt;int&amp;gt; &amp;gt;(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量不用conversion operator，因为很可能在你没意识到的情况下隐式调用了。&lt;br /&gt;
解决：&lt;br /&gt;
显示定义一个函数，比如&lt;code&gt;double asDouble() const&lt;/code&gt;。这样虽然写起来很麻烦，但是可以防止很多错误。  &lt;blockquote&gt;
&lt;p&gt;越有经验的C++程序员越会避免使用类型转换操作符，比如string类型没有隐式转换成char *的conversion operator，而是包含&lt;code&gt;c_str()&lt;/code&gt; 函数。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;尽量不要使用conversion constructor，道理同上。&lt;br /&gt;
解决：&lt;br /&gt;
1.explicit&lt;br /&gt;
2.用代理类模拟,例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;ArraySize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
            &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;theSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ArraySize&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>MoreEffectiveC++(7)</title><link href="http://particle128.com/posts/2013/12/MoreEffectiveCpp(7).html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/MoreEffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 32 在未来时态下发展程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;面向对象方法应用于系统构造的一个强大力量就是，它支持日后的变化  &lt;/li&gt;
&lt;li&gt;请为每一个类处理复制和赋值动作，即使这样的动作暂时没有人使用。如果这些函数不易完成，请将其声明为private  &lt;/li&gt;
&lt;li&gt;没有virtual destructor的String类，不能用于当作基类(因为当作基类，就有delete指向派生对象的基类指针的可能性)。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 33 将非尾端(non-leaf)类设计为抽象类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;考虑这样一个继承体系&lt;br /&gt;
具体类Animal -&amp;gt;派生Lizard和Chicken&lt;br /&gt;
可能出现部分赋值（partial assignment）的问题：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//Animal部分赋值，Lizard部分没有赋值  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;解决方法：&lt;br /&gt;
1.operator=变成虚函数从而利用多态实现派生类的赋值  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//C++允许返回值不同，但是参数类型必须相同，否则就是在Lizard中重载了operator=操作符，没有实现多态  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;*pa=*pb&lt;/code&gt;这种情况可以利用多态，即根据pa实际指向的对象，调用对应的&lt;code&gt;virtual operator=&lt;/code&gt;&lt;br /&gt;
问题：允许了如下情形  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Chicken&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pa&lt;/span&gt;&lt;span class="o"&gt;=*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//异型赋值  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决：&lt;br /&gt;
operator=函数里用dynamic_cast转型； 同时定义一个重载函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="c1"&gt;//原virtual operator=(const Animal&amp;amp;)里dynamic_cast进行判断，防止异型赋值  &lt;/span&gt;
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Animal&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//重载一个普通版本，降低Lizard对象之间赋值的成本  &lt;/span&gt;
        &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Lizard&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.将Animal中的opeartor=设为protected&lt;br /&gt;
这样做，直接不允许了进行&lt;em&gt;pa=&lt;/em&gt;pb这种行为，但是同时也限制了Animal对象之间的赋值。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;终极解决方法：&lt;br /&gt;
将Animal当作和Lizard、chicken一样的类，然后共同继承自抽象类AbstractAnimal类，该类几乎和原Animal一样即可（相同的成员函数，相同的数据成员）。&lt;br /&gt;
AbstractAnimal的operator=设为protected。&lt;br /&gt;
这样就限定了&lt;em&gt;pa=&lt;/em&gt;pb这种行为，而且没有AbstractAnimal对象之间的赋值问题。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：仅仅定义纯虚函数，还是可以&lt;code&gt;*pa=*pb&lt;/code&gt;这类部分赋值(更常用的说法是slicing)，因为这并没有实例化抽象类，只是把派生类切割成基类部分，然后进行了赋值。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纯虚函数的意义是：使所在类为抽象类；使该函数必须被派生类重定义(否则派生类还是抽象类)。&lt;br /&gt;
一般纯虚函数可以不给予实现，但是如果析构函数是纯虚函数，必须给予实现（即使是空函数也是实现），因为派生类的析构会调用它。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么时候需要抽象出抽象类？&lt;br /&gt;
答：&lt;br /&gt;
1.具体类被派生时。这可以防止刚才遇到的赋值问题，还有Item3讲到的基类数组参数指向派生类数组的问题（当基类是抽象类时，就不会想要使用基类数组参数了）。&lt;br /&gt;
2.不要在一开始就定义一个抽象类，在前面的发生发生后才做。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要派生第三方类库中的具体类，怎么办？&lt;br /&gt;
答：&lt;br /&gt;
1.派生具体类，但是小心基类指针解引用后的部分赋值问题，还有不要将派生类数组传入基类数组作为参数的函数。&lt;br /&gt;
缺点：容易出错&lt;br /&gt;
2.找找这个类库中有没有上层的抽象类，然后继承自它&lt;br /&gt;
缺点：需要实现很多本来可以继承的东西&lt;br /&gt;
3.将该具体类的对象当作自己要定义的类的数据成员&lt;br /&gt;
缺点：不能享受继承的一些特性：多态&lt;br /&gt;
4.直接用这个具体类，然后加一些非成员函数在外面。&lt;br /&gt;
缺点：代码不够清爽，不好维护。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item34 在同一个程序里结合C++和C&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;extern "C"的使用&lt;br /&gt;
作用：阻止name mangling（名称重整）&lt;br /&gt;
1.C++程序使用C语言写的库函数，需要声明成  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;  &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用时不会mangling  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.C++程序写一个供C语言调用的库，需要声明成  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//实现时不会mangling  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.C或C++要使用C语言写的库函数，加入如下头文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifdef __cplusplus&lt;/span&gt;&lt;span class="c1"&gt;//C++预处理器符号，C语言程序自动跳过该extern &amp;quot;C&amp;quot;块  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="cp"&gt;#endif  &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="cp"&gt;#ifdef __cplusplus  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="cp"&gt;#endif  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;statics的初始化&lt;br /&gt;
静态对象包括：全局对象(program scope)，类静态对象(class scope)，namespace内对象(namespace scope)，文件内静态对象(file scope)&lt;br /&gt;
C++会在main函数之前，加入一段对静态对象的构造语句，称为static initialization&lt;br /&gt;
同时，会在main函数之后，加入一段对静态对象的析构语句，称为static destruction&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：anonymous namespace的出现，相当于取代了文件静态对象;函数内静态对象不属于“静态对象”的范畴，它的初始化是在第一次调用的时候，而不是main之前。&lt;/li&gt;
&lt;li&gt;new和delete，malloc和free必须成对&lt;br /&gt;
否则结果未定义  &lt;/li&gt;
&lt;li&gt;数据结构兼容性&lt;br /&gt;
不能传递的有：&lt;br /&gt;
对象，&lt;br /&gt;
成员函数指针&lt;br /&gt;
可以兼容传递的有：&lt;br /&gt;
普通指针（指向对象、非成员函数/静态成员函数），&lt;br /&gt;
内置类型变量，&lt;br /&gt;
某些struct对象（满足：不含有虚函数，不继承自其他对象）  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>去哪儿网机票提醒脚本</title><link href="http://particle128.com/posts/2013/12/qunar.html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/qunar.html</id><summary type="html">&lt;p&gt;源码参见&lt;a href="https://github.com/particle128/qunar-flight-reminder"&gt;particle128的github&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;This project is used to check the airfare in &lt;a href="http://www.qunar.com"&gt;www.qunar.com&lt;/a&gt;, and send you a SMS message when the price is lower than what you set in config.py  &lt;/p&gt;
&lt;h2&gt;Requirements&lt;/h2&gt;
&lt;p&gt;Download the ChromeDriver in &lt;a href="https://code.google.com/p/chromedriver/downloads/list"&gt;here&lt;/a&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;selenium&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;see config.py  &lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category></entry><entry><title>一些反思</title><link href="http://particle128.com/posts/2013/12/some-thought.html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/some-thought.html</id><summary type="html">&lt;p&gt;来实验室的路上，总结自己过去比较失败的地方，发现了这几点：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目标不具体    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有具体的目标，只有空泛的目标，比如要好好锻炼身体，要加强技术。这些空洞的、口号性质的目标往往让我坚持不了几天。但是如果采用更加具体的目标，比如要找一个漂亮的女朋友（所以要让自己强壮起来），要去某某公司（所以要加强哪几个方面的技术），就容易让人坚持下来，而且更加有针对性，不会出现走很多弯路的情况。容易坚持的原因，我觉得是有憧憬，想放弃的时候想到佳人在旁或Offer在手的情形，会让人又鼓起斗志。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;花了很多时间在做重要但不紧急的事情，但是收效甚微。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最主要的原因是我没有坚持下来，比如每天记单词啦，健身啦，什么的，都尝试过一段时间，但是都半途而废了。  &lt;br /&gt;
&lt;strong&gt;要么不做一件事，节省下来时间做其他事；要么坚持做一件事。&lt;/strong&gt;做一件事，没有坚持下来的话，会浪费很多时间，最后还相当于零。没有明确目标的做一件事，就容易半途而废。就像《高效能人士的七个习惯》中说的，绝大多数情况下不是自制力差，而是制定目标的能力差。这个我也有些许感触：别靠自制力，靠目标和纪律来约束自己。    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方向选择上走了很多弯路。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然走弯路也有意义，但是会推迟成功到来的时间。比如当初做鞍山项目的时候选择的技术，让我用了前前后后半年多的时间花在一个不热门的技术上，浪费了很多宝贵的时间，本来可以用在更加有前景的技术上。又比如大四花了不少时间背英语口语，很久不练习也没有对我产生什么积极的帮助。  &lt;br /&gt;
总之，在做选择之前，多考虑考虑这件事对我实现目标（先明确的东西）到底有多大意义，如果一两年都没啥意义，而又比较好突击的话，现在就不要做。还有就是多看看前人在做什么，借鉴经验。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总结下来就是，第一个因素决定了后面两个因素。反思过去走过的弯路，供以后借鉴。    &lt;/p&gt;</summary><category term="thought"></category><category term="goal"></category></entry><entry><title>Bargain Snatcher:使用说明</title><link href="http://particle128.com/posts/2013/12/vipshop-intro.html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/vipshop-intro.html</id><summary type="html">&lt;p&gt;源码请移步&lt;a href="https://github.com/particle128/vipshop-buy"&gt;particle128的github&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;Two Modes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自选模式&lt;br /&gt;
配置config.ini，运行软件，键盘控制购买哪些看中的物品。&lt;br /&gt;
打开方式：设置config.ini中auto_pick下的AutoPickMode=False。  &lt;/li&gt;
&lt;li&gt;全自动模式&lt;br /&gt;
配置config.ini，运行软件，自动购买符合过滤条件的物品。&lt;br /&gt;
打开方式：设置config.ini中auto_pick下的AutoPickMode=True。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;config.ini&lt;/code&gt;配置文件分为url，screen，auto_pick，config，type，size，empty，sort几个section。  &lt;/p&gt;
&lt;h3&gt;url&lt;/h3&gt;
&lt;p&gt;包括登陆界面和主页的url，一般不需要动。  &lt;/p&gt;
&lt;h3&gt;screen&lt;/h3&gt;
&lt;p&gt;配置屏幕和选购窗口的大小安排，一般默认即可。  &lt;/p&gt;
&lt;h3&gt;auto_pick&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;【AutoPickMode】：可选值是True或False。&lt;br /&gt;
选择True，将使软件进入&lt;strong&gt;全自动模式&lt;/strong&gt;，auto_pick部分配置的其他选项才有意义。&lt;br /&gt;
选择False，则直接忽略auto_pick部分的其余配置，进入&lt;strong&gt;自选模式&lt;/strong&gt;。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【PriceSpan】：价格区间，半角逗号分割  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【DisSpan】：折扣区间，半角逗号分割  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【Excepts】【Keywords】&lt;br /&gt;
因为是全自动模式，进入某个品牌的页面之后，软件需要根据条件进行筛选，Keywords是必须包含的关键字，Excepts必须过滤的关键字。&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="na"&gt;PriceSpan&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;100,300  &lt;/span&gt;
&lt;span class="na"&gt;DisSpan&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0,5  &lt;/span&gt;
&lt;span class="na"&gt;Excepts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;POLO,T恤,紫  &lt;/span&gt;
&lt;span class="na"&gt;Keywords&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;男  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解释：软件会筛选价格在￥100~300之间，折扣在0~5之间，商品标题中包含“男”并且不包含“POLO”、”T恤”和”紫”的商品。  &lt;/p&gt;
&lt;h3&gt;config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;【TestMode】：可选值是True或False。&lt;br /&gt;
非正式使用，只是为了熟悉本软件操作方式的时候，设置成False，会跳过刷新首页环节，直接进入所关注的品牌内。&lt;br /&gt;
正式使用，一定记得设置成True，这样软件才会每隔5s刷新首页等待商品更新。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【Account】：自己vipshop的账户和密码（冒号分割用户密码，多个账户密码换行即可）&lt;br /&gt;
之所以要用多个，是因为一个帐号购物袋中最多只能放10个商品，当海选商品的时候，可能10个并不够。况且这样也能加快购买的速度，建议最少两个帐号。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【Keys】：首页品牌的筛选关键字，空格隔开&lt;br /&gt;
例子：&lt;code&gt;Keys=男 鞋&lt;/code&gt;&lt;br /&gt;
解释：首页品牌描述中只有既包括‘男’又包括'鞋'这两个关键字的才可以匹配上。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【Brands】：中意的品牌，空格隔开&lt;br /&gt;
例子：&lt;code&gt;Brands=Nike adidas 七匹狼&lt;/code&gt;&lt;br /&gt;
解释：首页品牌描述中包括 'Nike' ， ’adidas‘ 或 '七匹狼' 其中之一就可以匹配上。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【Type】【Size】【Empty】【Sort】&lt;br /&gt;
这几个选项，对应下图中画圈部分。其中，Type和Size的值可以包含多个，空格隔开，但是Type和Size中的值要在对应位置一一对应。  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="image" src="https://raw.github.com/particle128/vipshop-buy/master/images/1.png" /&gt;&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;[type]&lt;/span&gt;  
&lt;span class="na"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;上衣 鞋类 男包  &lt;/span&gt;
&lt;span class="err"&gt;…&lt;/span&gt;  
&lt;span class="err"&gt;[size]&lt;/span&gt;  
&lt;span class="na"&gt;Size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;XL 9 均码  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解释：有时候，你喜欢的品牌有多种商品，你比较感兴趣，比如XL的上衣，9号的鞋，还有均码的男包。这时候，你可以配置成例子所示。&lt;br /&gt;
程序会先进入"上衣 XL"的商品页面。一旦属于这一类的商品都浏览完毕，就会进入"鞋类 9"的商品页面，最后才会进入"男包 均码"页面。  &lt;/p&gt;
&lt;h2&gt;Usage&lt;/h2&gt;
&lt;h3&gt;Steps&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将dist/下的chromedriver放到PATH中指定的目录下，或者添加本目录进PATH(windows下没有此步骤)。  &lt;/li&gt;
&lt;li&gt;修改配置文件config.ini。  &lt;/li&gt;
&lt;li&gt;9点55左右(10点新品开卖)，执行python master.py（windows下双击运行dist/master.exe）。软件会弹出1个选购窗口和多个购买窗口。  &lt;/li&gt;
&lt;li&gt;如果是自选模式，等待进入品牌商品页，通过在命令行窗口下输入1、2、3、4、j、k键控制选择过程。如果是全自动模式，则免去此步骤。  &lt;/li&gt;
&lt;li&gt;软件退出，自己在购物袋中选择付款购买。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS:此软件配合本站的vipshop-notice一起使用，效果更佳~  &lt;/p&gt;
&lt;h3&gt;Commands&lt;/h3&gt;
&lt;p&gt;自选模式需要在终端窗口内输入命令,如下&lt;br /&gt;
导航窗口：&lt;br /&gt;
j ——窗口向下滚动一行&lt;br /&gt;
k——窗口向上滚动一行&lt;br /&gt;
选择当前所在行的物品：&lt;br /&gt;
1——选择最左边的商品&lt;br /&gt;
2——选择第2个商品&lt;br /&gt;
3——选择第3个商品&lt;br /&gt;
4——选择最右边的商品&lt;br /&gt;
退出：&lt;br /&gt;
q——在选择商品的过程中，输入q，退出程序。购物袋中有物品的窗口最大化，没有物品的窗口直接退出。  &lt;/p&gt;
&lt;h3&gt;Snapshots&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="https://raw.github.com/particle128/vipshop-buy/master/images/2.png" /&gt;&lt;br /&gt;
&lt;img alt="image" src="https://raw.github.com/particle128/vipshop-buy/master/images/3.png" /&gt;  &lt;/p&gt;</summary><category term="python"></category><category term="selenium"></category></entry><entry><title>Bargain Snatcher:linux到windows的移植问题</title><link href="http://particle128.com/posts/2013/12/vipshop-port.html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/vipshop-port.html</id><summary type="html">&lt;p&gt;源码参见&lt;a href="https://github.com/particle128/vipshop-buy"&gt;particle128的github&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;p&gt;0.登陆windows系统  &lt;/p&gt;
&lt;p&gt;1.安装python2.7&lt;br /&gt;
google上搜索exe安装包安装之。  &lt;/p&gt;
&lt;p&gt;2.安装pip&lt;br /&gt;
参考：http://www.pip-installer.org/en/latest/installing.html&lt;br /&gt;
下载setuptools源码tar.gz ——&amp;gt; 解压后执行python path/of/the/setuptools/setup.py install&lt;br /&gt;
——&amp;gt;下载get-pip.py ——&amp;gt;执行python get-pip.py  &lt;/p&gt;
&lt;p&gt;3.用pip安装需要的扩展包：selenium&lt;br /&gt;
D:\Python27\Scripts\pip install -U selenium  &lt;/p&gt;
&lt;p&gt;4.安装py2exe&lt;br /&gt;
下载地址：http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/  &lt;/p&gt;
&lt;p&gt;5.下载selenium chrome driver&lt;br /&gt;
下载地址：https://code.google.com/p/chromedriver/downloads/list&lt;br /&gt;
解压后，将其放入master.py和slave.py所在的文件夹。  &lt;/p&gt;
&lt;p&gt;6.修改源码，见后面。  &lt;/p&gt;
&lt;p&gt;7.配置文件转成windows下的版本（换行\r\n）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install dos2unix  
unix2dos config.ini  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8.用py2exe将python代码转成exe&lt;br /&gt;
参考：http://www.py2exe.org/index.cgi/Tutorial&lt;br /&gt;
(1)在脚本所在文件夹下新建setup_m.py和setup_s.py文件，内容为  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;distutils.core&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;  
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;py2exe&lt;/span&gt;  
&lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;master.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="c"&gt;#如果是windows应用程序则改成windows，main.py是可执行脚本的名称  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同理setup_s.py，把master.py改成slave.py  &lt;/p&gt;
&lt;p&gt;(2)执行python setup_m.py py2exe 和python setup_s.py py2exe。  &lt;/p&gt;
&lt;p&gt;dist里的master.exe和slave.exe即为转化成的可执行文件。  &lt;/p&gt;
&lt;p&gt;9.运行master.exe&lt;br /&gt;
执行期间报错ERROR:textfield.h(162) NOT IMPLEMENTED&lt;br /&gt;
不过对程序没有影响  &lt;/p&gt;
&lt;h2&gt;源码修改&lt;/h2&gt;
&lt;p&gt;【1】增加区分系统的标志，为了支持NON-buffering输入，引入不同的库  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;IsWindows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;  
&lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;platform&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Windows&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;msvcrt&lt;/span&gt;  
     &lt;span class="n"&gt;IsWindows&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;  
     &lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;  
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#Linux  &lt;/span&gt;
     &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;termios&lt;/span&gt;  
     &lt;span class="n"&gt;Line&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【2】因为windows的终端是gbk编码，所以需要定义输出函数，每次print的时候，如果含有中文就调用print local_str('...')。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;local_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;IsWindows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【3】不缓冲输入  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;msvcrt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getch&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#不回显，或者c=msvcrt.getche()回显  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【4】linux下可以通过ActionChains对象定义按键事件进行翻页，windows下不知道是不是bug，调用send_keys或key_up或key_down都没有作用。所以，替代方案如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;IsWindows&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;idx&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#windows下每4行要重新获取一下dts，因为是异步加载  &lt;/span&gt;
     &lt;span class="n"&gt;dts&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_elements_by_class_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pro_list_pic&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【5】windows下的chrome第一个页面加载巨慢，所以加大了延时  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;IsWindows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_page_load_timeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c"&gt;#win下chrome第一个页面加载很慢  &lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_page_load_timeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="py2exe"></category></entry><entry><title>Bargain Snatcher:技术问题</title><link href="http://particle128.com/posts/2013/12/vipshop-tech.html" rel="alternate"></link><updated>2013-12-01T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-12-01:posts/2013/12/vipshop-tech.html</id><summary type="html">&lt;p&gt;源码参见&lt;a href="https://github.com/particle128/vipshop-buy"&gt;particle128的github&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;环境:&lt;/h2&gt;
&lt;p&gt;下载selenium chrome driver：&lt;br /&gt;
&lt;a href="https://code.google.com/p/chromedriver/downloads/list"&gt;url&lt;/a&gt;&lt;br /&gt;
安装selenium ：&lt;code&gt;pip install -U selenium&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;遇到的问题和总结：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不输入回车直接读入键盘操作，因此需要设置终端输入no buffer模式  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;  
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;termios&lt;/span&gt;  

&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="c"&gt;# 命令行不缓冲直接读入，linux版本  &lt;/span&gt;
     &lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileno&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
     &lt;span class="n"&gt;old&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tcgetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tcgetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ICANON&lt;/span&gt;  
     &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TCSADRAIN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="c"&gt;# code here  &lt;/span&gt;

&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;  
&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
      &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tcsetattr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;termios&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TCSADRAIN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;old&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;经常需要调用某个命令，忽略抛出的异常（一般是TimeoutException），定义如下函数  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;call_with_no_except&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
     &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#一个参数  &lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#无参  &lt;/span&gt;
     &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;pass&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Selenium模块的driver.find_elements_by_xpath("//tag[@class='pro_list_pic'][2]")有问题，会返回NoSuchElementException，不知道是bug还是没有实现这个功能，用其他函数代替。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取无缓冲的标准输入  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;select&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;  
&lt;span class="n"&gt;rlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;],[],[])&lt;/span&gt;  

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;rlist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读取有缓冲的管道输入：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;],[],[])&lt;/span&gt;  
&lt;span class="n"&gt;infos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#不能使用read(2)。readline读出的字符串带有结尾的换行符  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;创建子进程，传递3个参数，并通过管道与其通信（该应用中之需要单向的通信）  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;slave.py&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pwd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xpos&lt;/span&gt;&lt;span class="p"&gt;)],&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PIPE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;与子进程的通信  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#找到可用的子进程  &lt;/span&gt;
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt; &lt;span class="c"&gt;#一定要调用poll()返回returncode，而不是直接查看returncode属性，因为returncode属性是被poll()，wait()和communicate()3个函数设置的。  &lt;/span&gt;
          &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  
          &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;process quits by accident&amp;#39;&lt;/span&gt;  
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
         &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;all processes are dead...&amp;#39;&lt;/span&gt;  
               &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#退出  &lt;/span&gt;
     &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;break&lt;/span&gt;  
&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pIdx&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;设置页面加载超时  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_page_load_timeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;设置之后，调用driver.get和driver.refresh，如果发生超时，直接抛出TimeoutException异常。&lt;br /&gt;
设置之后，执行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ActionChains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ele&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perform&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="err"&gt;，会在下一次调用&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="err"&gt;的地方抛出&lt;/span&gt;&lt;span class="n"&gt;TimeoutException&lt;/span&gt;&lt;span class="err"&gt;异常。&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;动态设置超时时间  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux下selenium webdriver不提供异步加载页面的功能，所以只能使用同步加载策略。因为页面上图片较多（商品图片、广告、活动宣传等），如果等待页面完整的下载下来，会浪费很多宝贵的时间。因此采用带有超时的同步加载。但是，利用每台电脑的网卡速度、内存情况，每次购物的网络拥挤状况不同，导致加载同一个页面的时间相差较大。&lt;br /&gt;
采用“指数增长，线性调整”策略：&lt;br /&gt;
一开始读取配置文件中的一个初始值，设置超时时间全局变量。加载页面的策略就是：在一个循环中，get一个页面，超时后会出错返回，然后检查我关注的标签（比如衣服的尺码信息、加入购物车按钮等）是否加载完毕，如果加载完毕，退出循环，继续下面的步骤；否则，超时的时间*=2，再次进入循环，刷新这个页面。。。这是“指数增长”阶段。当连续两次没有超时就获取到页面元素之后，就进入“线性调整”阶段。该阶段中，每次不发生超时，超时时间-=1，直到再次遇到超时，进入“最终阶段”。最终阶段，每次超时，超时时间+=1，不再进行-=1的操作了。&lt;br /&gt;
抢购完毕软件退出时，会把动态修改的超时时间写入配置文件，下次用该值进行初始化。  &lt;/p&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;buy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
    &lt;span class="s"&gt;&amp;quot;购买对应尺码的商品&amp;quot;&lt;/span&gt;  
    &lt;span class="n"&gt;p_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;buy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="n"&gt;SizeReg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;默认&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;SizeReg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;^&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;([^.L]|$)&amp;#39;&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c"&gt;# 如果是默认尺码，那就所有商品都选  &lt;/span&gt;
        &lt;span class="n"&gt;SizeReg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;.*&amp;#39;&lt;/span&gt;  
    &lt;span class="n"&gt;timeout_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  
    &lt;span class="n"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  
    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;BuyTimeout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SuccessCnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt;  
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
            &lt;span class="c"&gt;# 定位出价格显示区  &lt;/span&gt;
            &lt;span class="n"&gt;pri_block&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_class_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;size_list&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;btn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;J_cartAdd_submit&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;pri_block&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_elements_by_tag_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;  
                &lt;span class="c"&gt;# 没有售完，且大小符合要求  &lt;/span&gt;
                &lt;span class="n"&gt;class_attr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_attribute&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;class&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;class_attr&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sli_disabled&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;class_attr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c"&gt;# 售完的  &lt;/span&gt;
                    &lt;span class="k"&gt;continue&lt;/span&gt;  
                &lt;span class="n"&gt;span&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_tag_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;span&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SizeReg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;quot; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;  
                    &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ActionChains&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
                    &lt;span class="c"&gt;# ！！！ click会超时，至少2s的page_load_timeout  &lt;/span&gt;
                    &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;click&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;btn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perform&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
                    &lt;span class="n"&gt;p_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;got size&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;span&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
                    &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;HasGood&lt;/span&gt;  &lt;span class="c"&gt;# !!!全局变量  &lt;/span&gt;
                    &lt;span class="n"&gt;HasGood&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  
                    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;TimeoutException&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="n"&gt;p_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;timeout&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;  
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="n"&gt;p_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;timeout_flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ExponState&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;BuyTimeout&lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;    &lt;span class="c"&gt;# 指数增长  &lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;BuyTimeout&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;    &lt;span class="c"&gt;# 线性调整  &lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;LinearState&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                    &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;FinalState&amp;#39;&lt;/span&gt;  

            &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_page_load_timeout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BuyTimeout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;p_print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;new timeout&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
            &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="c"&gt;#重新加载该页  &lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="k"&gt;break&lt;/span&gt;  

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;timeout_flag&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ExponState&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="n"&gt;SuccessCnt&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;SuccessCnt&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;LinearState&amp;#39;&lt;/span&gt; &lt;span class="c"&gt;# 指数增长阶段，连续两次不超时，进入线性调整阶段  &lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;LinearState&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="n"&gt;BuyTimeout&lt;/span&gt;&lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;      &lt;span class="c"&gt;# 线性调整  &lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
            &lt;span class="k"&gt;pass&lt;/span&gt; &lt;span class="c"&gt;# FinalState不进行-1的操作  &lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;State&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ExponState&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
        &lt;span class="n"&gt;SuccessCnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;  

&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;  
&lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;  
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
     &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
          &lt;span class="c"&gt;# 用xpath定位element  &lt;/span&gt;
          &lt;span class="n"&gt;ul&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find_element_by_xpath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;//table[@class=&amp;#39;tab_data&amp;#39;]/tbody/tr/td/div/div/ul&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  

         &lt;span class="c"&gt;# code here  &lt;/span&gt;

     &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="n"&gt;TimeoutException&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;timeout&amp;#39;&lt;/span&gt;  
          &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;  
     &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;  
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;MaxReload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;get to MaxReload,return&amp;#39;&lt;/span&gt;  
               &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="c"&gt;#直接函数返回，忽略该商品  &lt;/span&gt;
          &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
               &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;  
               &lt;span class="n"&gt;ref&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="c"&gt;#重新加载该页  &lt;/span&gt;
     &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
          &lt;span class="k"&gt;break&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="selenium"></category></entry><entry><title>MoreEffectiveC++(6)</title><link href="http://particle128.com/posts/2013/11/MoreEffectiveCpp(6).html" rel="alternate"></link><updated>2013-11-29T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-29:posts/2013/11/MoreEffectiveCpp(6).html</id><summary type="html">&lt;p&gt;&lt;em&gt;感受&lt;/em&gt;：这一章几乎用了一天时间阅读和消化，面向对象设计思想很薄弱，对作者设计时考虑的全面性很是叹服，需要以后要多思考和实际参与设计来锻炼设计能力。  &lt;/p&gt;
&lt;h2&gt;Item31: 让函数根据一个以上的对象类型决定如何虚化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;问题背景：&lt;br /&gt;
假设要设计一款游戏，SpaceShip、SpaceStation还有Asteroid继承自抽象基类GameObject，3个对象两两互相碰撞的情形各不相同。&lt;br /&gt;
需要定义一个碰撞函数，假设是processCollision(GameObject&amp;amp; obj1,GameObject&amp;amp; obj2)，能根据要碰撞的两个对象的类型决定碰撞行为(shipHitStation,stationHitShip等6种)。&lt;br /&gt;
因为游戏在版本更新中，可能不断增加新的GameObject子类，所以该方法要可以扩展。  &lt;/li&gt;
&lt;li&gt;虚函数调用动作被称为message dispatch(消息分派)，processCollision根据两个参数而虚化被成为double-dispatch(双重分派)，更一般的是multiple dispatch(多重分派)  &lt;/li&gt;
&lt;li&gt;解决方法：  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.double-RTTI（书中没提到）&lt;br /&gt;
直接在processCollision里对两个参数都进行RTTI，即调用typeid确定实际类型，借助if-else或switch结构，进行&lt;code&gt;static_cast&lt;/code&gt;转型后，调用实际碰撞函数。&lt;br /&gt;
&lt;strong&gt;注意：因为typeid已经确定了对象的实际类型，用static_cast一定不会出错。如果不完全确定类型，用dynamic_cast转型，万一出错可以抛出异常。&lt;/strong&gt;&lt;br /&gt;
优点：&lt;br /&gt;
如果实际碰撞函数位于类外的话，这种方法不需要修改既有类的定义（SpaceShip等），也就不需要重新编译了.&lt;br /&gt;
缺点：&lt;br /&gt;
该函数看起来有点乱，随着GameObject子类的增加，函数会逐渐膨胀，假设该游戏是个大型网游，可能有几千几万的类型，函数简直无法维护.  &lt;/p&gt;
&lt;p&gt;2.虚函数+RTTI&lt;br /&gt;
碰撞第一个对象用虚函数实现虚化（动态绑定），第二个对象用typeid确定类型并调用类内函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;type_info&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;objectType&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;objectType&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//process...  &lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;&lt;span class="c1"&gt;//健壮程序都要考虑  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
利用虚函数代替了一个RTTI，代码较上一个简洁;&lt;br /&gt;
也不需要修改既有类的定义，只编译既有类对应的文件，而不需要编译使用既有类的文件（头文件没变）&lt;br /&gt;
缺点：&lt;br /&gt;
collide位于类内，每次新增一个GameObject子类，都要修改既有类的collide实现;&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道;&lt;br /&gt;
collide也会膨胀，虽然没0方案这么厉害，仍然不好维护;  &lt;/p&gt;
&lt;p&gt;3.double虚函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;SpaceShip:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//step1  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//step2  &lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//step2  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//第一步动态调用的函数  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//第二步根据参数动态调用  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
充分利用虚函数来去掉手动使用RTTI，代码简洁&lt;br /&gt;
缺点：&lt;br /&gt;
collide位于类内，每次新增一个GameObject子类，都要修改修改既有类的定义（增加一个collide函数），重新编译既有类和所有使用既有类的文件(头文件变了);&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道  &lt;/p&gt;
&lt;p&gt;4.自行仿真虚表(用映射来仿真，而不是vptr)，实质是虚函数+RTTI&lt;br /&gt;
第一步仍然用虚函数collide，第二步用预先定义好的map映射，根据参数的实际类型调用对应的函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;SpaceShip:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="c1"&gt;//用来仿真虚表的映射。因为C++标准没有定义type_info对象的name()成员函数返回的名字  &lt;/span&gt;
        &lt;span class="c1"&gt;//（可能是&amp;quot;SpaceShip&amp;quot;或&amp;quot;class SpaceShip&amp;quot;等），  &lt;/span&gt;
        &lt;span class="c1"&gt;//所以更好的做法是map&amp;lt;const type_info*,HitFuncPtr&amp;gt;，  &lt;/span&gt;
        &lt;span class="c1"&gt;//因为每一个类型只有一个type_info对象被构造，地址唯一。  &lt;/span&gt;
        &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="nf"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//类属函数，所以声明static  &lt;/span&gt;

        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hitSpaceShip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;spaceShip&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
        &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;collide&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;otherObejct&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//健壮程序都要考虑  &lt;/span&gt;
    &lt;span class="p"&gt;{(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;hfp&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt;  
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;CollisionWithUnknownObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;otherObject&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//用static是保证该函数在使用前先初始化了，在main结束后才销毁  &lt;/span&gt;
    &lt;span class="c1"&gt;//用auto_ptr是因为动态分配的HitMap，所以销毁的时间跟static应该一样  &lt;/span&gt;
    &lt;span class="c1"&gt;//如果initializeCollisionMap使用局部static，返回一个有引用给collisionMap，就不需要auto_ptr包裹了  &lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;autp_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;collisionMap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//!!!只能把初始化语句放到一个函数中，实现只执行一次的目的  &lt;/span&gt;
&lt;span class="n"&gt;SpaceShip&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;HitMap&lt;/span&gt; &lt;span class="n"&gt;initializeCollisionMap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitMap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phm&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HitMap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;phm&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SpaceShip&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hitSpaceShip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意：不要将void func(Derived&amp;amp;)函数用reinterpret_cast强制类型转换成void func(Base&amp;amp;)之后调用。&lt;br /&gt;
多继承(包括菱形继承)情况下，基类引用（实质：指针）和派生类引用不一定相等，实际传入的地址是派生对象中某个基类的地址，但是函数中却认为这个地址是派生类的地址，所以之后取得的任何成员都有错误，因为成员是通过基地址的偏移取得的。&lt;/strong&gt;&lt;br /&gt;
优点：&lt;br /&gt;
虽然同第2种解法一样：结合虚函数和RTTI.但是RTTI是用映射完成的，代码简洁如第3种解法&lt;br /&gt;
缺点：&lt;br /&gt;
hitXXX位于类内，每次新增一个GameObject子类，都要修改修改既有类的定义（增加一个hitXXX函数），重新编译既有类和所有使用既有类的文件(头文件变了);&lt;br /&gt;
失去封装性，每个兄弟类都要相互知道;  &lt;/p&gt;
&lt;p&gt;5.仿真虚表，完全使用非成员函数&lt;br /&gt;
用两个类型名的pair映射实际碰撞函数，实质是double-RTTI，只是用映射的方法使代码的维护更加方便  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//匿名namespace的每样东西对起所在编译单元（文件）而言都是私有的，相当于所有函数声明为static  &lt;/span&gt;
&lt;span class="c1"&gt;//如果在匿名namespace中声明但没有定义一个函数，需要在同一编译单元中另一个匿名namespace中给予实现  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//所有碰撞函数，lookup和initializeCollisionMap函数都在这里  &lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;processCollision&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;GameObject&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;obj2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;HitFuncPtr&lt;/span&gt; &lt;span class="n"&gt;phf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;typeid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj2&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;优点：&lt;br /&gt;
不需要重新编译既有文件，只需要修改processCollision定义所在的文件;&lt;br /&gt;
速度比方法1快，由线性探查(if-else或switch)改为map形式查找（二叉树之类的）&lt;br /&gt;
PS:&lt;br /&gt;
如果想要动态登记和撤销实际碰撞函数的映射，可以再定义一个CollisionMap类，里面包含&lt;code&gt;addEntry(const string&amp;amp; type1,const string&amp;amp; type2,HitFuncPtr func)&lt;/code&gt;和&lt;code&gt;removeEntry(...)&lt;/code&gt;等函数，就可以更加灵活的修改映射，而不需要去动processCollision定义所在文件内函数的代码。  &lt;/p&gt;</summary><category term="cpp"></category><category term="MoreEffectiveCpp"></category></entry><entry><title>C++中指向成员函数的指针</title><link href="http://particle128.com/posts/2013/11/pointer-to-member-func.html" rel="alternate"></link><updated>2013-11-28T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-28:posts/2013/11/pointer-to-member-func.html</id><summary type="html">&lt;p&gt;在C++中，类的非静态成员函数因为含有隐含的this指针，不同于普通函数。所以C++引入了一个新的指针类型：指向成员函数的指针。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;：类的static成员函数和普通函数的指针是一样的。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通函数指针：可以通过直接调用  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//the type is &amp;quot;int (*)(int)&amp;quot;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;非静态成员函数指针：只能通过类对象调用  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//the type is &amp;quot;int (Mat::*)(int)&amp;quot;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;指向成员函数的指针和普通指针，是两种不同类型指针，C++实现机制是不一样的（例如成员函数指针不一定包含具体函数的内存地址），如果强制进行两者之间的转换，结果是未定义的&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;使用方法如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="c1"&gt;//定义指向成员函数的指针类型  &lt;/span&gt;
        &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  

        &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
            &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 用类成员函数给指针赋值  &lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt; &lt;span class="c1"&gt;// 类内调用  &lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
            &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A::foo&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;global::foo&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt;  
    &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//或者 method pf=&amp;amp;foo;  &lt;/span&gt;
    &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//或者(*pf)();  &lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)();&lt;/span&gt; &lt;span class="c1"&gt;// 类外调用  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:普通函数，和指向普通函数的指针，可以隐式互相转换；但是非静态成员函数和其指针之间不能进行任何转换，所以*和&amp;amp;符号不能省略。  &lt;/p&gt;</summary><category term="cpp"></category></entry><entry><title>C++中名字查找</title><link href="http://particle128.com/posts/2013/11/name-lookup.html" rel="alternate"></link><updated>2013-11-05T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-05:posts/2013/11/name-lookup.html</id><summary type="html">&lt;p&gt;今天被C++的名字查找和using语句折磨了一天，记录下来最终的理解，还有一些未解的问题，以后有时间再研究。  &lt;/p&gt;
&lt;h2&gt;名字查找&lt;/h2&gt;
&lt;p&gt;这个&lt;a href="http://blog.csdn.net/xtyyumi301/article/details/662639"&gt;链接&lt;/a&gt;对我帮助很大，此外还参考了一些SO上的解答，和&lt;a href="http://en.wikipedia.org/wiki/Argument-dependent_name_lookup"&gt;wiki&lt;/a&gt;&lt;br /&gt;
C++的名字查找(name lookup)，作为重载确定(overload resolution)的第一步，具有举足轻重的作用。很可能存在一个合适的函数，因为被内层作用域的同名变量或函数屏蔽，而不能被调用。但这仅仅是名字查找的一方面，因为名字查找包括两个方面：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常规查找（normal lookup）  &lt;/li&gt;
&lt;li&gt;实参决定的查找（argument-dependent lookup）  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有函数调用，都会进行常规查找；只有函数的实参包括 类类型对象 或 指向类类型对象的指针/引用 的时候，才会进行实参确定的查找。&lt;br /&gt;
分别解释如下：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;normal lookup&lt;br /&gt;
从函数被调用的局部作用域开始，逐渐向上层寻找被调用的名字，一旦找到就停止向上寻找。此外，using语句可以将其他作用域的名字引用到当前作用域。  &lt;/li&gt;
&lt;li&gt;argument-dependent lookup(ADL)&lt;br /&gt;
从第一个类类型参数开始，依次遍历所有类类型参数。&lt;br /&gt;
对于每一个参数，进入其类型定义所在的作用域（类内友元函数也包括在内），并依次进入其基类、间接基类……定义所在的作用域，查找同名函数。&lt;br /&gt;
&lt;strong&gt;注意&lt;/strong&gt;:在继承体系中上升的过程中，不会因为找到同名函数就停止上升。这不同于normal lookup  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码，&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;就是调用&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;，ADL根据第一个参数std::cout（std::ostream类型）去std命名空间寻找&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;函数，最后匹配到&lt;code&gt;std::ostream&amp;amp; std::operator&amp;lt;&amp;lt;(std::ostream&amp;amp;, const char*)&lt;/code&gt;  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include&amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
  &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello World, where did operator&amp;lt;&amp;lt;() come from?&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例代码帮助理解，注意其中的注释：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//1  &lt;/span&gt;
&lt;span class="c1"&gt;//第一个实参所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="c1"&gt;//友元函数定义在T内，但是在T外层的作用域中可见，即Name1中  &lt;/span&gt;
        &lt;span class="c1"&gt;//using Name1::func的话，不会引入T内友元  &lt;/span&gt;
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//2  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="c1"&gt;//不能和T内的friend函数有相同的参数列表，否则重定义错误  &lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//3  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//实参的间接父类所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//4  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//5  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//实参父类所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name0&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Name00&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T00&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//6  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;&lt;span class="c1"&gt;//7  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//第二个实参所在命名空间  &lt;/span&gt;
&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;Name2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Name0&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T0&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//8  &lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;&lt;span class="c1"&gt;//9  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Name1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Name2&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="c1"&gt;//9个函数全是候选函数  &lt;/span&gt;
    &lt;span class="c1"&gt;//第1个函数是normal lookup找到的  &lt;/span&gt;
    &lt;span class="c1"&gt;//后8个函数全是argument-dependent lookup找到的  &lt;/span&gt;
    &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;using语句&lt;/h2&gt;
&lt;p&gt;using语句包括两种：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using directive&lt;br /&gt;
语法格式为：using namespace XXX;&lt;br /&gt;
没看懂C++标准里写的这一块，但是测试发现，使用这种方法不能将XXX中的func加入重载函数的候选函数，如果当前作用域找不到func，normal lookup会继续向上层寻找。  &lt;/li&gt;
&lt;li&gt;using declaration&lt;br /&gt;
语法格式为：using XXX::func;&lt;br /&gt;
可以使用该方法将func函数加入候选函数集合，且这种方法会阻止normal lookup向外层作用域寻找func。  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="cpp"></category><category term="name-lookup"></category></entry><entry><title>Headache</title><link href="http://particle128.com/posts/2013/11/headache.html" rel="alternate"></link><updated>2013-11-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-04:posts/2013/11/headache.html</id><summary type="html">&lt;p&gt;Today I encountered bad headache again. Although I had made up mind to overcome this disaster without the help of any medicine, I failed. After taking two cold capsules, hurt is fading away.&lt;br /&gt;
Headache is not a big deal, but it troubles me a lot. So, I'm going to make a list of &lt;em&gt;the cause&lt;/em&gt;, &lt;em&gt;how to avoid &lt;/em&gt;and &lt;em&gt;what to do if it has already happened&lt;/em&gt;.  &lt;/p&gt;
&lt;h3&gt;The Cause:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;excessive drink  &lt;/li&gt;
&lt;li&gt;afternoon nap not on time  &lt;/li&gt;
&lt;li&gt;have a cold  &lt;/li&gt;
&lt;li&gt;two many [secret]  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;How to Avoid:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Don't drink unless it is a must. Learn to say no when others propose you a toast. &lt;strong&gt;Remember that a true hero is not evaluated according to his behavior on the table&lt;/strong&gt;.  &lt;/li&gt;
&lt;li&gt;Never destroy the routine whatever happens.  &lt;/li&gt;
&lt;li&gt;Hard to avoid.  &lt;/li&gt;
&lt;li&gt;Minimize the frequency of it.  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;What to do if it has already happened:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;If it is serious, don't hesitate to take some pills and go to bed for a rest. Don't &lt;strong&gt;bite the bullet&lt;/strong&gt; in this case.  &lt;/li&gt;
&lt;li&gt;If not, just return to normal and watch the situation. When the situation keeps the same or turns bad, take some medicine.  &lt;/li&gt;
&lt;li&gt;Last but not least, don't waste too much time under the circumstance. Although it's uncomfortable, it's not such unbearable.  &lt;/li&gt;
&lt;/ul&gt;</summary><category term="headache"></category><category term="health"></category></entry><entry><title>继承层次中的重载、重写的函数调用和this指针的关系</title><link href="http://particle128.com/posts/2013/11/Overwrite-Overload.html" rel="alternate"></link><updated>2013-11-02T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-11-02:posts/2013/11/Overwrite-Overload.html</id><summary type="html">&lt;p&gt;例子如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;  &lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
        &lt;span class="c1"&gt;//Base中函数的重写  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="c1"&gt;//Base中函数的重载  &lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
        &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Derived  &lt;/span&gt;
    &lt;span class="c1"&gt;//解释：重写的情况形参列表相同，考虑this指针，最佳匹配是Derived中的func  &lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Base  &lt;/span&gt;
    &lt;span class="c1"&gt;//解释：重载的情况，不考虑this指针，最佳匹配是Base中func1  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：上面的解释，是我根据实验结果的推测，翻阅了几本C++的书籍也没找到合理的答案。如果之后遇到合理的解释，我会再更新在这里  &lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;加上virtual函数后，可能更容易混淆。C++继承层次中确定函数调用的步骤:&lt;br /&gt;
1.确定调用者的静态类型（指针、引用或对象本身）&lt;br /&gt;
2.在其类的作用域中查找名字（只看名字），如果找不到就沿着继承链向上找。找不到名字就报错。&lt;br /&gt;
3.找到名字后，确定函数参数是否匹配，并寻找最佳匹配。找不到最佳匹配就报错。&lt;br /&gt;
4.如果最佳匹配是虚函数，查看调用者的动态类型(引用、指针的情况)，确定应该调用的函数位于哪个类的作用域中，并调用之；否则，直接调用该最佳匹配的函数。&lt;br /&gt;
例子如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;non-virtual Base int&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;virtual Base double&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived double&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Derived int&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;12.5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出Derived double&lt;/span&gt;
    &lt;span class="c1"&gt;//解释：静态类型获得最佳匹配是virtual函数，所以第4步根据动态类型调用派生类的虚函数&lt;/span&gt;
    &lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//输出non-virtual Base int&lt;/span&gt;
    &lt;span class="c1"&gt;//解释：静态类型最佳匹配是non-virtual函数，所以直接调用&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category></entry><entry><title>EffectiveC++笔记汇总</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp.html" rel="alternate"></link><updated>2013-10-31T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-31:posts/2013/10/EffectiveCpp.html</id><summary type="html">&lt;p&gt;笔记汇总：  &lt;/p&gt;
&lt;p&gt;&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html"&gt;EffectiveC++(1)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html"&gt;EffectiveC++(2)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html"&gt;EffectiveC++(3)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html"&gt;EffectiveC++(4)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html"&gt;EffectiveC++(5)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(6).html"&gt;EffectiveC++(6)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html"&gt;EffectiveC++(7)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html"&gt;EffectiveC++(8)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html"&gt;EffectiveC++(9)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html"&gt;EffectiveC++(10)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html"&gt;EffectiveC++(11)&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html"&gt;EffectiveC++(12)&lt;/a&gt;  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(2)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(2).html" rel="alternate"></link><updated>2013-10-18T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-18:posts/2013/10/EffectiveCpp(2).html</id><summary type="html">&lt;h2&gt;Item 05: Know what functions C++ silently writes and calls&lt;/h2&gt;
&lt;p&gt;1.默认生成的4种函数，都是public+inline类型的。  &lt;br /&gt;
2.复制构造函数原型：&lt;code&gt;Empty(const Empty&amp;amp;);&lt;/code&gt; 赋值操作符原型：&lt;code&gt;Empty&amp;amp; operator=(const Empty&amp;amp;);&lt;/code&gt; 为了和内置类型的赋值操作意义相同，返回左值的引用  &lt;br /&gt;
3.唯有这4个函数被调用时，才被产生出来。  &lt;br /&gt;
4.默认产生的析构函数是non-virtual的，除非base class是virtual的。  &lt;br /&gt;
5.3种情况下，赋值操作符不会自动生成：含有const成员，含有ref成员，base class的赋值操作符号是private（这时候，子类无法调用父类的赋值操作符）。    &lt;/p&gt;
&lt;h2&gt;Item 06: Explicitly disallow the use of compiler-generated functions you do not want&lt;/h2&gt;
&lt;p&gt;1.使拷贝构造函数和赋值操作符不可用，两种方式：&lt;br /&gt;
(1)声明为private，且不给予实现。 不论类外（编译错误），还是类内或友元（链接错误），都不能访问这些函数。&lt;br /&gt;
注：此方法可以让任何类成员函数，不能被访问。如果是构造函数，则不能构造对象。&lt;br /&gt;
(2)父类的成员函数是private的。  不论什么继承方式，都在子类中不可见。而拷贝构造和赋值操作都需要调用父类的同类方法，此时编译器无能为力只能不自动生成。访问这些函数将导致编译错误。&lt;br /&gt;
注：同上一item的第5点  &lt;/p&gt;
&lt;h2&gt;Item 07： Declare destructors virtual in polymorphic base classes&lt;/h2&gt;
&lt;p&gt;1.delete父类指针或引用的时候，如果不是virtual析构函数，结果是未定义的。很可能的结果是，只调用了父类的析构函数，对象局部销毁，会造成内存泄露。&lt;br /&gt;
因此，多态基类，一定要定义虚析构函数。&lt;br /&gt;
2.不用于多态基类时，最好不要加上virtual属性，否则会增加一个指针的大小。&lt;br /&gt;
为实现virtual机制，对象需要携带一个vptr(虚表指针)，指向vtbl（虚表，函数指针的数组），用来在运行期间动态确定哪个virtual函数被真正调用。&lt;br /&gt;
3.C++不提供“禁止继承”的机制，Java中final class，或C#中sealed class提供此机制。&lt;br /&gt;
4.尽量不要继承STL容器等包含non-virtual析构函数的类，因为一旦使用多态机制，结果未定义或内存泄露。&lt;br /&gt;
5.需要抽象基类，并且手头没有纯虚函数时，定义纯虚析构函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//声明  &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="c1"&gt;//定义  &lt;/span&gt;
&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt; &lt;span class="c1"&gt;//之所以需要这个，是因为子类析构时需要调用父类析构函数，不定义会链接错误  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 08: Prevent exceptions from leaving destructors&lt;/h2&gt;
&lt;p&gt;1.析构函数抛出2个异常，可能导致程序终止，或未定义行为。使用标准库容器（set,list）或数组，很容易造成这种情况。所以一定不要让析构函数抛出异常。&lt;br /&gt;
2.正确的做法：提供用户调用可能抛出异常的函数，同时在析构函数里调用该函数，但是捕获其异常。这样用户不仅可以自己捕获异常，也能享受万一忘记调用close，析构函数帮助其close的好处。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;  
     &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;DBConn&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
          &lt;span class="n"&gt;try&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;  
          &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="p"&gt;(...)&lt;/span&gt;  
          &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="cm"&gt;/*记录该事件；要么结束程序要么吞下异常*/&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(1)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(1).html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/EffectiveCpp(1).html</id><summary type="html">&lt;p&gt;&lt;strong&gt;【补充概念】&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;类型安全&lt;/strong&gt;：&lt;br /&gt;
&lt;em&gt;MSDN上的权威解释&lt;/em&gt;：类型安全，意味着每个变量、函数参数和函数返回值存储到可接受的数据，并且，涉及不同类型的值“的操作有意义”和不导致数据丢失、位组合的解释不正确或内存损坏。&lt;br /&gt;
&lt;em&gt;简单理解&lt;/em&gt;：编译器会帮助程序员检查程序中是否使用了合适的类型，即如果程序员使用了不正确的类型，编译器会报错，而不会把错误留到运行时。&lt;br /&gt;
printf，memcpy，#define 宏定义函数就不是类型安全的。&lt;br /&gt;
(1) printf("The meaning of life is %s",42);  》》》类型安全的cout&lt;br /&gt;
(2) SomeClass a;AnotherClass b;&lt;br /&gt;
   memcpy((void&lt;em&gt;)&amp;amp;a,(void&lt;/em&gt;)&amp;amp;b,sizeof(b)); 》》》类型安全的copy constructor&lt;br /&gt;
(3) #define max(a,b) ((a)&amp;gt;(b)?(a):(b))  &lt;br /&gt;
   max(15,"abc");max(a++,b); 》》》类型安全的template inline函数（同样效率，函数可预料行为，类型安全）  &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Item 02: Prefer const, enum, and inline to #define&lt;/h2&gt;
&lt;p&gt;1.除非我有一个很好的理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。&lt;br /&gt;
2.头文件里定义字符串常量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//或 char const * const str=&amp;quot;hello&amp;quot;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;缺第1个const，&lt;code&gt;warning： deprecated conversion from string constant to ‘char*’&lt;/code&gt; 
缺第2个const，如果两个源文件引用该头文件，会&lt;code&gt;multiple definition&lt;/code&gt;的错误&lt;br /&gt;
3.类关键字：&lt;br /&gt;
一般情况，只允许声明处出现一次：explicit,static,virtual,默认实参&lt;br /&gt;
特殊的2个，inline：出现在任一处都行，一般写在定义处；const：两处都要出现。&lt;br /&gt;
4.&lt;code&gt;#define&lt;/code&gt;宏定义完全可以被代替。const代替常量宏，template inline函数代替函数宏。&lt;br /&gt;
此外，static const可以定义类属常量，这是#define做不到的。&lt;br /&gt;
5.static const类属常量，如果是整数类型（char，short，int，bool等），可以在声明时直接赋值，只要不取地址都可以直接使用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果非整数类型（如double），如果需要取地址，如果编译器比较旧，需要在源文件中定义，给初值。&lt;br /&gt;
如果非要在编译时使用，编译器还不允许，可以使用enum hack的方法  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;c&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6.需要一组常量的时候，可以使用枚举，用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Feb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;March&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;April&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; 
&lt;span class="n"&gt;Month&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//枚举类型可以被枚举值赋值&lt;/span&gt;
&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;Third&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;First&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//整数类型也可以被枚举值赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 03: Use const whenever possible&lt;/h2&gt;
&lt;p&gt;1.const可作用于任何作用域范围的对象、函数参数、函数返回类型、成员函数本身。&lt;br /&gt;
2.函数返回类型+const的意义，限制返回值再被赋值：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;防止  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过编译&lt;br /&gt;
3.将const作用于成员函数，保证该成员函数可以被const对象调用。&lt;br /&gt;
4.const成员函数可以"重载"非const成员函数。虽然const成员函数也可以被non-const对象调用，但是重载后，定义const和non-const对象，调用的同一个函数原型，效果就不一样了。如果返回引用类型或非内置类型，一个可以被赋值，一个不可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原理：&lt;br /&gt;
重载函数的确定，先找到candidate函数（名字相同），再找到viable函数（参数列表符合），再确定best match。&lt;br /&gt;
const成员函数内隐藏的this指针是&lt;code&gt;const type *&lt;/code&gt; 类型，而非const成员函数的则是&lt;code&gt;type *&lt;/code&gt; 。因此，const重载的实质是参数类型不同。&lt;br /&gt;
所以，非const对象优先调用非const函数（最佳匹配），没有的时候才调用const函数。&lt;br /&gt;
5.函数返回内置类型，不能做左值；函数返回自定义类型，或引用类型（内置或自定义），可以做左值。&lt;br /&gt;
6.被mutable声明的变量，即使在const成员函数内，也可以修改。这样可以实现概念上的const函数，而不是bitwise上的const函数。&lt;br /&gt;
举例：类里保存cache缓冲区的指针。每次调用length()函数读取cache缓冲区大小的时候，都要重新计算一下。
7.重复代码：编译时间、维护、代码臃肿问题。&lt;br /&gt;
在operator[]函数里调用const operator[]函数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;                      &lt;span class="c1"&gt;//C++中仅有这一种方式  &lt;/span&gt;
     &lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TextBlock&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="n"&gt;position&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;//也可以用const_cast代替,不转换成const对象会无限递归调用自己，段错误~  &lt;/span&gt;
     &lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 04: Make sure that objects are initialized before they're used.&lt;/h2&gt;
&lt;p&gt;1.类成员变量中的自定义类型，在构造函数语句执行之前，已经调用过默认构造函数初始化自身了。所以，为了效率，应该使用初始化列表，然后构造函数语句体为空。代价（默认构造函数+赋值操作）&amp;gt;代价（1个构造函数）。&lt;br /&gt;
类成员变量中的内置类型，构造函数语句执行之前一般不会初始化，而且初始化和赋值效率相同，所以放在哪里一样。代价（1次初始化）=代价（1次赋值）。&lt;br /&gt;
2.内置类型为const或引用，必须初始化，不能赋值。&lt;br /&gt;
3.static对象，包括global对象，namespace作用域内对象，类内静态对象，函数内静态对象（local static对象）。&lt;br /&gt;
寿命：从运行中被构造出来，直到main()结束自动调用析构。&lt;br /&gt;
4.&lt;br /&gt;
原理：C++对定义于不同编译单元内的non-local static对象的初始化相对次序，没有明确定义。&lt;br /&gt;
导致的问题：先构造的对象，在构造函数中引用了后构造的对象，此时该对象还没有初始化。&lt;br /&gt;
解决：以函数调用（返回local static对象的引用），替代直接访问non-local static对象。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;C1&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;getobj&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;C1&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++保证，函数内local static 对象会在该函数被调用期间，首次遇上该对象的定义式时被初始化。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>core dump相关</title><link href="http://particle128.com/posts/2013/10/core-dump.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/core-dump.html</id><summary type="html">&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;当程序异常退出（接受到内核或其他程序的某种信号，比如SIGTERM，SIGKILL等）的时候，一般会将出错时候的内存状况保存到core file中，以帮助开发者了解程序崩溃的原因。&lt;br /&gt;
即core memory（内存最开始使用线圈做的），其实就是内存。core dump就是内存倾倒的意思。  &lt;/p&gt;
&lt;h3&gt;ubuntu下使能core dump功能&lt;/h3&gt;
&lt;p&gt;ubuntu下默认core文件的大小限制是0（执行ulimit -c查看），即不允许core文件产生。&lt;br /&gt;
解除限制：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited &lt;span class="c"&gt;#设置core file的限制  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -a &lt;span class="c"&gt;#查看所有限制（包括栈大小、cpu时间、虚拟内存、文件大小等）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;core文件的默认位置&lt;/h3&gt;
&lt;p&gt;查看core文件存储格式，以及ubuntu下输出结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cat /proc/sys/kernel/core_pattern   
|/usr/share/apport/apport %p %s %c  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;意思是：core file文件通过管道，变做apport程序的输入。&lt;br /&gt;
后面的参数解释如下（man core）：&lt;br /&gt;
%p - insert pid into filename 添加pid&lt;br /&gt;
%u - insert current uid into filename 添加当前uid&lt;br /&gt;
%g - insert current gid into filename 添加当前gid&lt;br /&gt;
%s - insert signal that caused the coredump into the filename 添加导致产生core的信号&lt;br /&gt;
%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间&lt;br /&gt;
%h - insert hostname where the coredump happened into filename 添加主机名&lt;br /&gt;
%e - insert coredumping executable name into filename 添加命令名&lt;br /&gt;
%c - core  file  size soft resource limit of crashing process 添加core文件大小限制  &lt;/p&gt;
&lt;h3&gt;apport&lt;/h3&gt;
&lt;p&gt;介绍它的页面：&lt;a href="https://wiki.ubuntu.com/Apport"&gt;link&lt;/a&gt;&lt;br /&gt;
需要注意的地方：&lt;br /&gt;
1. apport把core file保存在 /var/crash/ 目录下&lt;br /&gt;
2. ubuntu12.04之后，apport才默认开启。之前的版本都需要设置 /etc/default/apport 文件&lt;br /&gt;
3. apport的日志文件保存在 /var/log/apport.log 一般日志文件都放置于此，例如syslog，redis&lt;br /&gt;
4. 自己的程序，只有打包成.deb文件，并被安装之后，apport才会保存其core file到/var/crash。否则不生成core file，log文件里会报错如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;executable does not belong to a package, ignoring  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;重定向core file&lt;/h3&gt;
&lt;p&gt;既然apport只能处理ubuntu下的包程序，那么我们就不让apport干涉core file的产生了。&lt;br /&gt;
执行如下命令：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;ulimit&lt;/span&gt; -c unlimited  
&lt;span class="c"&gt;# echo &amp;quot;core.%e.%p&amp;quot; &amp;gt; /proc/sys/kernel/core_pattern  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样，每次core file都会在当前目录下保存了。  &lt;/p&gt;
&lt;h3&gt;gdb定位错误位置&lt;/h3&gt;
&lt;p&gt;产生core file之后（姑且命名为core.a.out.11111），直接vi查看其内容会一头雾水。&lt;br /&gt;
执行如下命令，定位程序崩溃的位置：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;gdb -c core.a.out.11111  
&lt;span class="o"&gt;(&lt;/span&gt;gdb&lt;span class="o"&gt;)&lt;/span&gt; where  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;程序中捕捉崩溃事件&lt;/h3&gt;
&lt;p&gt;sigaction()函数指定信号的处理函数（比如SIGSEGV），然后在处理函数中打log，发送错误报告之类的。  &lt;/p&gt;</summary><category term="core dump"></category></entry><entry><title>两个类定义相互转换时的二义性</title><link href="http://particle128.com/posts/2013/10/inter-convert.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/inter-convert.html</id><summary type="html">&lt;p&gt;两个类，分别定义了到对方的转换，隐式使用这种转换的时候，一般会出现二义性。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例子：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;converting constructor&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;conversion function&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据C++Primer P460的讲解，很显然这段代码在编译时会报二义性（ambiguous）的错误。原因在于：conversion constructor和conversion operator并没有高下之分，所以在Y类型转换成X类型的时候，出现了二义。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果X的构造函数和Y的转换操作符变成如下声明形式：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;X&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认operator X()是最佳匹配。原因在于：如果要调用X的构造函数，那么需要首先进行标准转换（Y-&amp;gt;const Y）；而如果调用operator X则免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果声明式改成：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不会出现二义性，编译器直接确认X(Y&amp;amp;)是最佳匹配。原因在于：const函数的this指针是const Y &lt;em&gt;const，因此首先需要一个标准转换（Y &lt;/em&gt;-&amp;gt;const Y *）；而如果调用前者，免去了标准转换。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;诡异的事情来了，如果声明式是：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们按照前面的推理过程，应该的得这是一个二义性的代码，因为都需要一个标准转换在调用类类型转换之前。但是g++神奇的没有报错就选择了X(const Y&amp;amp;)这个函数作为转换函数。百撕不得骑姐，甚至怀疑刚才我的推理都错了，终于在stackoverflow上找到了解答，&lt;a href="http://stackoverflow.com/questions/1384007/conversion-constructor-vs-conversion-operator-precedence"&gt;链接&lt;/a&gt; &lt;br /&gt;
这应该是g++不符合C++标准的地方，是它的一个策略：在这个都需要const转换的"二义性"情况下，默默吞掉二义性而选择conversion constructor作为最佳匹配。如果想看到二义性错误，只要使用&lt;code&gt;g++ -pedantic&lt;/code&gt;命令，pedantic的意思是迂腐的,学究式的。  &lt;/p&gt;
&lt;h3&gt;之前讨论的是隐式转换，如果是强制类型转换呢？&lt;/h3&gt;
&lt;p&gt;在测试的时候发现：如果既有构造函数，又有转换操作符，使A类对象转化为B类对象，如下3种强制类型转换方法都偏向于构造函数，除非构造函数不存在的时候，才调用转换操作符进行转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B(A)&lt;/li&gt;
&lt;li&gt;(B)A&lt;/li&gt;
&lt;li&gt;static_cast&lt;B&gt;(A)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：强制类型转换不看最佳匹配，所以即使构造函数的代价比转换操作符代价大，比如const constructor和non-const operator，也是如此。&lt;/p&gt;
&lt;p&gt;花了好久才涨了这点姿势，不过得出一个结论：&lt;strong&gt;纸上得来终觉浅，绝知此事要躬行&lt;/strong&gt;。  &lt;/p&gt;</summary><category term="conversion"></category><category term="cpp"></category></entry><entry><title>Python学习笔记-subprocess模块</title><link href="http://particle128.com/posts/2013/10/py-subprocess.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/py-subprocess.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;subprocess是python的一个内置模块，用来产生子进程，和子进程通过pipe通信。&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;3个便捷函数&lt;/h3&gt;
&lt;p&gt;如果仅仅想要调用一个子进程完成一个任务，不需要父进程与其通信，并且等待子进程退出的话，选择便捷函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 返回returncode，0成功，非0出错。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 返回0或引发CalledProcessError异常。不同于`check_all`的唯一一点是，异常的output属性是子进程的输出，`check_all`引发的异常的output属性则是None。因为子进程的output被放到异常对象的output里，所以参数没有stdout。  &lt;/span&gt;
&lt;span class="n"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;check_output&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;args是调用的命令和参数，可以是字符串，或字符串列表（带参数）。  &lt;/li&gt;
&lt;li&gt;是省略的一些关键字参数，不常用。  &lt;/li&gt;
&lt;li&gt;stdin,stdout,stderr是标准io，默认不重定向，可以给他们重定向到subprocess.PIPE，或文件对象（open函数的返回），或文件描述符。&lt;br /&gt;
注意：需要和子进程进行PIPE通信，不要用这三个函数。因为父进程在调用这三个函数的时候会阻塞，所以没法去都去PIPE里的信息或向管道传递信息。  &lt;/li&gt;
&lt;li&gt;shell设置为True的话，args指定的字符串将作为shell的参数，调用shell。  &lt;/li&gt;
&lt;li&gt;universal_newlines如果设置为True，那么stdout和stderr都会使用统一的换行符\n，而不区分操作系统。  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Popen类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;subprocess&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bufsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;preexec_fn&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;close_fds&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;env&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;universal_newlines&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;startupinfo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;creationflags&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数：&lt;br /&gt;
bufsize设置缓冲区大小，默认是0表示无缓冲，即每次write都直接执行io操作，而不是先放到缓冲区里，等待某个时机（换行符，或缓冲区满时才执行真正的io）&lt;br /&gt;
方法： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 检查进程是否中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;poll&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 等待进程中止，返回returncode属性  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="c"&gt;# 和进程交互，发送数据到stdin，在stdout和stderr接收数据。前提是构造函数中对应io设置成PIPE  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;communicate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;input&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# returns a tuple (stdoutdata, stderrdata)  &lt;/span&gt;
&lt;span class="c"&gt;# 发送信号给进程  &lt;/span&gt;
&lt;span class="n"&gt;Popen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此外还有terminate（），kill（）函数&lt;br /&gt;
stdin，stdout，stderr，pid，returncode属性  &lt;/p&gt;</summary><category term="python"></category><category term="subprocess"></category></entry><entry><title>Python学习笔记-ConfigParser模块</title><link href="http://particle128.com/posts/2013/10/python-configparser.html" rel="alternate"></link><updated>2013-10-15T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-15:posts/2013/10/python-configparser.html</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;配置文件可以有很多种格式，windows下常用ini格式，网络上常用xml和json格式，分别可以调用的python模块如下：&lt;br /&gt;
ini——ConfigParser模块&lt;br /&gt;
xml——xml.etree.ElementTree模块&lt;br /&gt;
json——json模块  &lt;/p&gt;
&lt;h3&gt;参考文档&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://docs.python.org/2/library/configparser.html"&gt;link&lt;/a&gt;&lt;br /&gt;
点评：&lt;br /&gt;
前面的文字讲的很晕，没有上下文的情况下就各种说，还不如直接来几个例子。不过我还是硬着头皮看完了。  &lt;/p&gt;
&lt;h3&gt;ini文档的格式&lt;/h3&gt;
&lt;p&gt;1.注释的开始标记是semicolon 和 number sign。semicolon开头的注释可以嵌入在ini文件的行内（和其他文本用一个空白符隔开），number sign开头的注释只能用在单独的一行中。&lt;br /&gt;
2.[section]中可以使用option=value或option: value&lt;br /&gt;
3.可以在value中包含格式化字符串，来自同section，或DEFAULT section，或初始化的时候传入的内容。&lt;br /&gt;
示例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;[My&lt;/span&gt; &lt;span class="err"&gt;Section]&lt;/span&gt;  
&lt;span class="err"&gt;foodir:&lt;/span&gt; &lt;span class="err"&gt;%(dir)s/whatever&lt;/span&gt;  
&lt;span class="na"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;frob  &lt;/span&gt;
&lt;span class="err"&gt;long:&lt;/span&gt; &lt;span class="err"&gt;this&lt;/span&gt; &lt;span class="err"&gt;value&lt;/span&gt; &lt;span class="err"&gt;continues&lt;/span&gt;  
   &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;the&lt;/span&gt; &lt;span class="err"&gt;next&lt;/span&gt; &lt;span class="err"&gt;line&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类层次关系&lt;/h3&gt;
&lt;p&gt;import ConfigParser&lt;br /&gt;
class ConfigParser.RawConfigParser([defaults[, dict_type[, allow_no_value]]])&lt;br /&gt;
——》ConfigParser （增加value中格式化字符串）&lt;br /&gt;
——》 SafeConfigParser（更加健全的格式化字符串）&lt;br /&gt;
符号——》表示派生出。  &lt;/p&gt;
&lt;h3&gt;成员方法&lt;/h3&gt;
&lt;p&gt;示例： config=ConfigParser.SafeConfigParser()&lt;br /&gt;
读写配置文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;expanduser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;~/.myapp.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt; &lt;span class="c"&gt;#打开多个文件，忽略打开失败的文件，返回打开成功的文件列表  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;site.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readfp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c"&gt;#打开一个文件  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;defaults.cfg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
&lt;span class="c"&gt;# 判断配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="c"&gt;# 读取配置文件内容：  &lt;/span&gt;
&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;MySection&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;带类型判断的变种，类型不对会抛出异常：&lt;/span&gt;&lt;span class="n"&gt;getint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getfloat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;getboolean&lt;/span&gt;  
&lt;span class="n"&gt;sections&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c"&gt;#返回section列表  &lt;/span&gt;
&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回option列表  &lt;/span&gt;
&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;#返回(option，value)列表  &lt;/span&gt;
&lt;span class="c"&gt;# 修改配置文件内容：  &lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;frob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_section&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="n"&gt;remove_option&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;My Section&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;dir&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;遇到的问题&lt;/h3&gt;
&lt;p&gt;问题：&lt;br /&gt;
配置文件中有一行 XL=10101。但是，get函数返回的option总是xl&lt;br /&gt;
原因：&lt;br /&gt;
&lt;a href="http://docs.python.org/2/library/configparser.html#ConfigParser.RawConfigParser.optionxform"&gt;link&lt;/a&gt;&lt;br /&gt;
RawConfigParser有一个成员方法：optionxform(option)&lt;br /&gt;
Transforms the option name option as found in an input file or as passed in by client code to the form that should be used in the internal structures.The default implementation returns a lower-case version of option.&lt;br /&gt;
意思是，ConfigParser会自动调用optionxform函数，处理输入文件中的选项字段，或输出时指定的选项字段，默认是将其转变成小写。&lt;br /&gt;
文档中的解决方案是  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cfgparser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="o"&gt;...&lt;/span&gt;  
&lt;span class="n"&gt;cf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;optionxform&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt; &lt;span class="c"&gt;#直接改成str，意味着不区分大小写。但是这对于含有中文option的配置文件并不合适。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#调用的时候转换成小写  &lt;/span&gt;
&lt;span class="n"&gt;new_url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;originUrl&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;?q=0|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;|&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TYPE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()],&lt;/span&gt;&lt;span class="n"&gt;EMPTY&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;SORT&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Sort&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="ConfigParser"></category><category term="python"></category></entry><entry><title>C++提供的数据封装，只是访问控制，而不是信息隐藏</title><link href="http://particle128.com/posts/2013/10/cpp-encapsulation.html" rel="alternate"></link><updated>2013-10-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/cpp-encapsulation.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;C++通过private，protected和public提供的encapsulation并不是information hiding，而是access specifier。因为C++中类的定义比如放在头文件中，所有private数据类型也都暴露在用户下了。  &lt;/li&gt;
&lt;li&gt;C#，Java中类的定义（private数据成员）在源文件里，因此用户如果要访问这个类，using 对应的namespace，只能接触到public成员，private里有什么根本无从知晓。&lt;br /&gt;
甚至C语言的struct，如果把实现放在源文件，也让结构体访问者无法得知其实现，只能通过一些API来访问。例子来自wiki百科&lt;a href="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)"&gt;Encapsulation词条&lt;/a&gt;。  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Header file &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// Opaque structure with hidden members  &lt;/span&gt;
&lt;span class="c1"&gt;// API functions that operate on &amp;#39;Entity&amp;#39; objects  &lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  



&lt;span class="c1"&gt;// Implementation file &amp;quot;api.c&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;api.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ent_id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// ID number  &lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;ent_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Name  &lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;members&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;// API function implementations  &lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;open_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;process_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;close_entity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Entity&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="cpp"></category><category term="encapsulation"></category></entry><entry><title>程序员的自我修养 笔记</title><link href="http://particle128.com/posts/2013/10/ziwoxiuyang.html" rel="alternate"></link><updated>2013-10-14T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-14:posts/2013/10/ziwoxiuyang.html</id><summary type="html">&lt;h2&gt;Chapter 2&lt;/h2&gt;
&lt;p&gt;所谓“编译”（gcc 1.cpp），实际上包括预处理，编译，汇编，链接。&lt;br /&gt;
gcc命令实际是后台程序的包装，包装了cc1预处理，as汇编，ld链接器&lt;br /&gt;
[1]预处理   主要处理预处理指令（#开头的），主要工作如下：&lt;br /&gt;
宏展开; 头文件插入 ; 删除注释 ； 添加行号和文件标识 。 &lt;br /&gt;
gcc -E 1.cpp -o 1.i             阅读.i文件，可以查看宏展开是否正确&lt;br /&gt;
[2]编译  把源文件生成汇编代码 (调用cc1)&lt;br /&gt;
gcc -S 1.i -o 1.s   或直接gcc -S 1.cpp -o 1.s&lt;br /&gt;
[3]汇编   把汇编代码转化成机器指令，即目标文件 (调用as)&lt;br /&gt;
gcc -c 1.s -o 1.o  或直接 gcc -c 1.cpp -o 1.o&lt;br /&gt;
[4]链接  把目标文件、库链接起来，生成可执行文件（调用ld）&lt;br /&gt;
gcc 1.o -o 1  或直接 gcc 1.cpp -o 1&lt;br /&gt;
简记：ESc   iso  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编译过程&lt;/strong&gt;：&lt;br /&gt;
前端：跟机器无关&lt;br /&gt;
词法分析、语法分析、语义分析（给语法树的节点添加类型，主要工作是：声明和类型的匹配，类型的转换）、中间语言生成（包含优化，比如生成三地址码）&lt;br /&gt;
后端：跟机器有关&lt;br /&gt;
目标代码生成、优化  &lt;/p&gt;
&lt;h2&gt;Chapter 3       目标文件（统称）&lt;/h2&gt;
&lt;p&gt;[1] linux下目标文件和可执行文件的格式均为ELF格式。具体分类：&lt;br /&gt;
relocatable file：目标文件（.o）、静态链接库（.a）&lt;br /&gt;
executable file：可执行文件（无后缀）&lt;br /&gt;
shared object file：动态链接库（.so）&lt;br /&gt;
[2] ELF文件中数据和指令分别存放在不同的段里。原因如下：&lt;br /&gt;
（1）程序被装载后，数据和指令被映射到两个不同的虚存区域（一个可读写，一个只读），这样可以防止修改指令。&lt;br /&gt;
（2）现代cpu的cache分为指令缓存和数据缓存，提高cpu缓存命中率。&lt;br /&gt;
（3）系统中运行同一个程序的多个副本时，可以共享指令部分，但是数据部分必须一个副本拥有一份。&lt;br /&gt;
[3] 程序的指令部分放在.text段中，初始化的全局数据和局部i静态数据放在.data段中，未初始化的全局数据和局部静态数据放在.bss段中（虚拟的，不占用空间）。&lt;br /&gt;
[4] 查看目标文件中各种信息的方式：&lt;br /&gt;
objdump -h  显示各个段的基本信息&lt;br /&gt;
objdump -x  显示各个段的基本信息，显示符号表、重定位表的信息&lt;br /&gt;
objdump -s  将段的内容以16进制打印，   -d  显示指令段反汇编之后的汇编代码&lt;br /&gt;
readelf -h  查看ELF文件头 &lt;br /&gt;
readelf -S  查看段表（section header）&lt;br /&gt;
readelf -s  查看符号表&lt;br /&gt;
[5] 文件头&lt;br /&gt;
包含段表地址（相对于文件头）、段表大小、段表字符串表的索引（所有段从0开始编辑索引）&lt;br /&gt;
[5] 符号表&lt;br /&gt;
在链接中，函数和变量统称为符号（symbol），函数名和变量名就是符号名。&lt;br /&gt;
符号表中存在 定义在本目标文件中的全局符号(&lt;code&gt;global_var&lt;/code&gt;)，以及，在本目标文件中引用的全局符号(printf,&lt;code&gt;extern_var&lt;/code&gt;)。&lt;br /&gt;
[6] 字符串表（包括字符串表strtab和段表字符串表shstrtab）&lt;br /&gt;
表中就是一个接一个的存放字符串（以\0结尾），在符号表和段表中的某些需要用字符串来表示的信息（比如符号名、段名），是通过字符串在字符串表中的偏移来引用的。&lt;br /&gt;
[7] C++支持函数重载，即相同函数名的函数，可以根据参数列表（个数、类型）来区分。C++支持命名空间（类也属于），在不同命名空间可以有同样名字的符号。为了支持这一点，C++中的符号名（函数、全局变量）需要进行“名称修饰”，修饰后的名称叫“修饰后名称”（Decorated Name）。目标文件中的符号名即为修饰后名称。&lt;br /&gt;
&lt;code&gt;int N::C::func(int)&lt;/code&gt; 在gcc下的修饰后名称为&lt;code&gt;_ZN1N1C4funcEi&lt;/code&gt;，&lt;code&gt;_Z&lt;/code&gt;开头，N和E标识命名空间开始和结尾，i是参数&lt;br /&gt;
断开方式为：&lt;code&gt;_Z N 1N 1C 4func E i&lt;/code&gt;。数字标识后面的命名空间有几个字符。&lt;br /&gt;
在VC++下的修饰后名称为&lt;code&gt;?func@C@N@@AAEHH@Z&lt;/code&gt;。&lt;br /&gt;
函数返回的变量类型，并没有加入符号的修饰后名称中，所以，不能通过函数返回类型进行重载。&lt;br /&gt;
[8] C中没有名称修饰（name mangling）的概念，所有符号定义的名称（func）即为目标文件中的符号名称（func）。&lt;br /&gt;
C++中为了兼容使用C的库，头文件需要添加&lt;code&gt;extern "C" { void *memset(void*, int , size_t); }&lt;/code&gt;。&lt;br /&gt;
该关键字表明，后面的符号不使用“名称修饰”。这样，在C++中调用C的库memset可以正常使用，否则修饰后的名称和C语言库中未修饰的名称不一致，会提示链接错误。&lt;br /&gt;
[9] 强符号：函数、初始化的全局变量                 弱符号：未初始化的全局变量、用&lt;code&gt;__attribute__((weak))&lt;/code&gt;修饰的变量/函数&lt;br /&gt;
选择多次定义的全局符号    规则如下：&lt;br /&gt;
（1）不允许强符号多次定义&lt;br /&gt;
（2）多个文件中只有一个强符号，则选择强符号&lt;br /&gt;
（3）都是弱符号，选择空间最大的&lt;br /&gt;
[10] 强引用：默认             弱引用：用&lt;code&gt;__attribute__((weakref))&lt;/code&gt;修饰的引用&lt;br /&gt;
强引用的符号，链接时找不到，报链接错误;&lt;br /&gt;
弱引用的则不报错，使用地址0给那个未找到的符号赋值，运行时调用的话会出错。&lt;br /&gt;
[11] 调试信息在目标文件中占的空间（多了需要.debug开头的段），往往比代码和数据大的多，发布之前去除：strip  a.out  &lt;/p&gt;
&lt;h2&gt;Chapter4     静态链接&lt;/h2&gt;
&lt;p&gt;[1] .bss段在可执行文件中不占用空间，但是在装载后，要占用虚拟地址空间。&lt;br /&gt;
.bss段内的数据起初都是0,所以文件不必分配空间，但是运行中可能赋值，所以内存中需要空间。&lt;br /&gt;
[2] &lt;code&gt;ld a.o b.o -e main -o ab&lt;/code&gt;，-e参数表明main函数作为程序入口，否则ld链接器默认&lt;code&gt;_start&lt;/code&gt;作为入口。&lt;br /&gt;
[3] 链接两步：1.空间与地址的分配（合并目标文件[比如符号表合并成全局符号表]，分配虚拟地址）  2.符号解析与重定位（符号表中的und类型的符号在全局符号表中查找，修正代码中的地址）&lt;br /&gt;
第一步：链接之后，段表中各个段的属性VMA（Virtual Memory Address）被分配了虚拟内存地址。链接之前该属性均为0.链接之后，符号表中符号的value值变为虚拟内存地址。链接之前为想对于段的偏移。&lt;br /&gt;
第二步：链接之后，代码中的地址（外部函数和变量的引用）由默认值（0之类的）修正为实际的虚拟内存地址。&lt;br /&gt;
[4] 静态库，即目标文件的打包。ar -t libc.a可以查看包含的目标文件&lt;br /&gt;
链接库的过程：搜索库（xx.a）中所有目标文件（xx.o）的符号表，把被引用的符号存在的那个目标文件包含进可执行文件。如果被引用目标文件，还引用了其他目标文件的符号，再递归包含其他目标文件。&lt;br /&gt;
[5] 静态运行库libc.a里面一个目标文件只包含一个函数，比如printf.o，strlen.o等。&lt;br /&gt;
原因：链接器在链接静态库的时候，是以目标文件为单位的，引用了哪些目标文件中的符号（当然包括间接引用的符号），就链接哪些目标文件，库中其余的目标文件都丢弃。函数独立成目标文件，有利于减少目标文件的大小。  &lt;/p&gt;
&lt;h2&gt;Chapter7     动态链接&lt;/h2&gt;
&lt;p&gt;[1] dl好处：节省磁盘和内存空间（多个可执行文件都引用同一个模块的话，内存和磁盘上只需要保留一份）; 使软件更新之后发布更加方便（只下载并覆盖更新了的模块，而不是整个软件）。&lt;br /&gt;
[2] 动态链接，是把链接的过程推迟到了程序装载的时候，但是性能的损失不大，利远大于弊。&lt;br /&gt;
[3] &lt;code&gt;gcc -fPIC -shared -o xxx.so xxx.c&lt;/code&gt;  其中-shared表示共享对象，-fPIC（position independent code）表示地址无关代码，这是动态链接中的一种机制。&lt;br /&gt;
[4] &lt;code&gt;gcc -o -L/path/to/libyyy.so Program Program1.c ./xxx.so -lyyy&lt;/code&gt; &lt;br /&gt;
注意，动态链接库xxx.so，libyyy.so也要作为输入文件之一。这样链接器对Program1.c中引用的外部符号，就可以进行特殊处理，使它成为一个对动态符号的引用。否则ld会报错：未定义的引用。&lt;br /&gt;
gcc或ld，如果显示加上-static参数，-lyyy会查找libyyy.a，属于静态链接。ld如果使用-dynamic-linker参数（默认），-lyyy会查找最新版本的libyyy.so.x.y.z，属于动态链接。（静、动态链接查找目录包括：标准库目录，-L参数指定的目录，&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录）&lt;br /&gt;
注意：：但是编译动态库的时候，可以不加它所依赖的共享库，因为动态库不会直接执行。但是所有调用该动态库的程序，在编译的时候都要加上动态库所依赖的库。最标准的做法是，编译动态库的时候，也加上它所依赖的库。&lt;br /&gt;
[6] ldd xxx.so  查看共享对象的依赖&lt;br /&gt;
[7] 显式运行时链接，即调用动态链接器提供的api在程序中进行链接装载。好处是，减少程序的启动时间，支持插件的动态加载、删除和更新等。&lt;br /&gt;
api：dlopen（可以通过参数设置延迟绑定，当通过dlsym加载的函数第一次被使用时才进行绑定，而不是当模块被加载时就完成所有函数的绑定）,dlsym,dlclose,dlerror  &lt;/p&gt;
&lt;h2&gt;Chapter8    linux共享库的组织&lt;/h2&gt;
&lt;p&gt;[1] 共享库，动态链接库，共享对象，可以看作是同一个概念&lt;br /&gt;
[2] 版本命名：libname.so.x.y.z。&lt;br /&gt;
主版本号x表示库的重大升级，不同主版本号的库之间不兼容。&lt;br /&gt;
次版本号y表示库的增量升级，增加一些新的接口符号，但是原符号保持不变，向后兼容。&lt;br /&gt;
发布版本号z表示库的一些错误修正和性能改进，接口符号完全保持不变，互相兼容。&lt;br /&gt;
[3] Linux和Solaris系统中，采用SO-NAME的命名机制。每个共享库都对应一个SO-NAME，即共享库名去掉次版本和发表版本号之后的名字（xx.2.1.12 -&amp;gt; xx.2）。&lt;br /&gt;
共享库管理程序ldconfig，会自动在标准库目录（/usr/lib,/lib）和/etc/ld.so.conf配置文件中制定的目录（包括/usr/local/lib）下搜索，建立以"SO-NAME"为名的软链接，指向目录中主版本号相同、其他版本号最新的共享库。&lt;br /&gt;
当系统中安装或更新一个共享库时，需要运行ldconfig一下，以便更新"SO-NAME"的软链接，指向最新版本的共享库。&lt;br /&gt;
[4] 动态链接的模块所依赖的模块的路径保存在.dynamic段里面（编译的时候写入的，所以编译需要把共享库也作为输入文件）。.dynamic里如果保存的模块路径是绝对路径，动态链接器直接去加载即可。如果保存的是相对路径，依次搜索下面几个目录：&lt;br /&gt;
0)  传递给ld的参数-rpath指定的目录&lt;br /&gt;
1）&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;指定的目录  &lt;br /&gt;
2）/etc/ld.so.cache指定的库路径（ldconfig执行的时候，除了建立SO-NAME软链接外，还在ld.so.cache中保存这些软链接的信息，方便动态链接器查找共享库）。（包括/usr/local/lib目录下的库）&lt;br /&gt;
3）/usr/lib，/lib。&lt;br /&gt;
[5] 环境变量&lt;code&gt;LD_PRELOAD&lt;/code&gt;里指定的文件会在动态链接器按照固定规则搜索共享库之前装载，无论程序是否依赖他们。由于“全局符号介入”机制，这里面的库中定义的符号，会让后来再加载的库中定义的同名符号失效。&lt;br /&gt;
[6] &lt;code&gt;gcc -W1,-soname,my_soname&lt;/code&gt;，-W1参数表示将指定参数传递给链接器。-soname参数指定共享库的SO-NAME，否则建立的共享库没有SO-NAME，ldconfig不会理睬这个库。  &lt;/p&gt;</summary><category term="link"></category><category term="load"></category></entry><entry><title>Effective C++学习笔记(10)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(10).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(10).html</id><summary type="html">&lt;h2&gt;Item 39: Use private inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.私有继承和复合(composition)意义相同：根据某物实现出（is-implemented-in-terms-of）。&lt;br /&gt;
2.除非必要，尽量用复合实现这种语义。&lt;br /&gt;
3.可以考虑使用private继承的情况：&lt;br /&gt;
（1）需要需要访问protected成员&lt;br /&gt;
（2）需要重写virtual函数。（替代策略:可以派生一个类，重写virtual函数。然后包含这个类的对象）&lt;br /&gt;
（3）如果需要包含的是一个空类对象，用private继承，节省空间。&lt;br /&gt;
Empty Class是指，只包含typedef，enum，statice成员变量和non-virtual函数的类。因为不含非静态成员变量和虚函数，所以一般不需要内存空间。&lt;br /&gt;
注：&lt;br /&gt;
1)类中包含一个空类对象的时候，大多数编译器至少需要1个字节的内存空间。&lt;br /&gt;
2)继承自空类对象，不需要任何内存空间。&lt;br /&gt;
4.尽量复用已有代码，所以平时注意积累自己的工具箱，设计的越通用越好，随时可以拿来复用。  &lt;/p&gt;
&lt;h2&gt;Item 40: Use multiple inheritance judiciously&lt;/h2&gt;
&lt;p&gt;1.多重继承尽量不用，因为它比单一继承复杂，比如引起二义性（ambiguity），还有可能需要虚继承（虚基类）&lt;br /&gt;
合理用途：&lt;br /&gt;
public继承一个接口类，private继承一个协助实现的类（需要复用它的一些成员，但是需要重写virtual）。&lt;br /&gt;
2.二义性例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base1:public&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Base2:private&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base2&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
          &lt;span class="c1"&gt;//using Base1::checkOut;  //解决二义性的方法1  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

     &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;checkOut&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
      &lt;span class="c1"&gt;//d.Base1::checkOut();  //解决二义性的方法2  &lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：C++首选确定对调用而言的最佳匹配（此处两个checkOut都是最佳匹配），之后才检查其可取用性。&lt;br /&gt;
所以，虽然private明显不能用，编译器还是返回错误：request for member 'checkOut' is ambigous。&lt;br /&gt;
解决：见程序注释。&lt;br /&gt;
3.钻石型多重继承，如果不希望最上层基类的成员在下层派生类中有多个副本，需要使用虚继承。&lt;br /&gt;
虚基类：所有派生自基类的类都采用virtual继承，该基类就被成为virtual base class&lt;br /&gt;
例子：STL中basic_ios ——&amp;gt;basic_istrem，basic_ostrem——&amp;gt;basic_iostrem&lt;br /&gt;
4.虚基类的初始化责任由继承体系的最底层（most derived）类负责。这样才可以避免虚基类被初始化多次。&lt;br /&gt;
5.虚继承有代价，所以一般不要用：虚继承的派生类占内存多，虚基类访问速度慢。&lt;br /&gt;
6.如果非要使用虚基类，尽量不要在里面放置数据，做一个接口类。类似与C#和Java中的Interfaces。  &lt;/p&gt;
&lt;h2&gt;Item 41: Understand implicit interfaces and compile-time-polymorphism&lt;/h2&gt;
&lt;p&gt;1.OOP的世界，显式接口（类的public接口，函数原型）和运行期多态 （virtual调用）。&lt;br /&gt;
Generic Programming，除了上面两者之外，还有隐式接口（typename需要支持的操作），和编译期多态（具现化）。&lt;br /&gt;
2.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;someWidget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;隐式接口是：w.size()&amp;gt;10 &amp;amp;&amp;amp; w!=someWidget返回bool类型。&lt;br /&gt;
可能w.size()返回数值型，或w有operator&amp;gt;成员，或opeartor&amp;gt;函数第一个参数接受T类型（或隐式转化成T类型），&lt;br /&gt;
可能operator&amp;amp;&amp;amp;被重载，返回一个bool类型。。。  &lt;/p&gt;
&lt;h2&gt;Item 42: Understand the two meaning of typename.&lt;/h2&gt;
&lt;p&gt;1.嵌套从属类型名称(nested dependent type name)需要在前面加typename，以表明它是类型名，否则编译器会假设它不是类型，而是一个变量。&lt;br /&gt;
举例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译期默认const_iterator是T中的静态变量，x可能全局变量之类的，它们做相乘。。。&lt;br /&gt;
声明其为类型：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//函数模版  &lt;/span&gt;
&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;Nested&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//类模版  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.两个特例不能加typename：&lt;br /&gt;
（1）继承的基类列表（base class list）&lt;br /&gt;
（2）构造函数成员初始化列表（member initialization list）  &lt;/p&gt;
&lt;h2&gt;Item 43: Know how to access names in templatized base classes&lt;/h2&gt;
&lt;p&gt;1.跟模版没关的一个话题：&lt;br /&gt;
当需要在派生类定义一个函数，是对基类函数的扩充，但是基类函数是non-virtual函数，这时候就用一个不同的名字。比如Base::sendClear()，Derived::sendClearMsg()&lt;br /&gt;
2.模版派生类，调用模版基类的函数时，不能不加任何修饰符的调用，因为编译期拒绝向模版基类的定义中寻找这个函数的声明。否则会在编译期"解析该模版类的定义式"时就报错。&lt;br /&gt;
原因：模版基类（templatized base class）可能存在特化版本，而这个特化版本中没有定义模版派生类要调用的那个函数。编译期在检查模版定义式的时候，没法确定具体是什么类型来具现化这个模版派生类。&lt;br /&gt;
解决：&lt;br /&gt;
（1）this-&amp;gt;修饰函数&lt;br /&gt;
（2）using Base&lt;T&gt;:: 引入相应名字&lt;br /&gt;
（3）Base&lt;T&gt;::修饰函数（最差的解决方法，因为会关闭virtual绑定行为）&lt;br /&gt;
3.编译器诊断模版相关的东西，分两个阶段&lt;br /&gt;
（1）解析模版的定义式。如上一条所列，可能报错。&lt;br /&gt;
（2）用实参具现化模版。如果this引入了基类的函数，但是基类相应特化版本的确不含有那个函数，这时候报错。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(11)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(11).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(11).html</id><summary type="html">&lt;h2&gt;Item 44: Factor parameter-independent code out of templates&lt;/h2&gt;
&lt;p&gt;1.类模版成员函数函数，只有被使用时才被具现化。类似类的合成版本的构造/复制构造/赋值操作符/析构函数。&lt;br /&gt;
2.模版的时候减少了源代码量，但是可能导致目标代码增加，因为每具现化一个版本，就多一份目标码。&lt;br /&gt;
策略：把与模版参数（类型参数或非类型参数）无关的代码，剥离出模版类。&lt;br /&gt;
（1）非类型参数&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SquareMatrix&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//方形矩阵  &lt;/span&gt;
  &lt;span class="nl"&gt;public:&lt;/span&gt;  
          &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;SquareMatrix&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;sm1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化一次invert  &lt;/span&gt;
&lt;span class="n"&gt;sm2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invert&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//具现化第二次invert，内容和第一次的代码重复了（只是把10换成5）  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;定义一个不含有非类型参数的基类SquareMatrixBase，含有invert函数。SquareMatrix只要调用基类invert即可。这样上面的例子就会只有1个版本的invert（基类的invert函数）。&lt;br /&gt;
（2）类型参数&lt;br /&gt;
例如：大多数平台，所有指针类型都有相同的二进制表述，模版的类型参数是指针类型的（比如vector&lt;char*&gt;，vector&lt;Date*&gt;），其成员函数应该调用唯一一份底层实现（操作void*指针的函数）。  &lt;/p&gt;
&lt;h2&gt;Item 45: Use member function templates to accept all compatible types&lt;/h2&gt;
&lt;p&gt;1.以TR1::shared_ptr为例：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;//由“内置指针类型”构造，但是不能隐式转换，只能通过C-style类型转换或reinterpret_cast转换（尚未验证？？？）  &lt;/span&gt;
         &lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
          &lt;span class="p"&gt;{...}&lt;/span&gt; &lt;span class="c1"&gt;//由“任意兼容类型的shared_ptr指针”构造，可以隐式转换。如果Y和U不兼容，成员初始化列表会报错  &lt;/span&gt;
         &lt;span class="c1"&gt;//赋值操作符也要定义成员函数模版，略  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本，而不是调用上面的构造函数模版  &lt;/span&gt;
         &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//需要显示定义。否则编译期会合成一个版本。  &lt;/span&gt;
         &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 46: Define non-member functions inside templates when type conversions are desired&lt;/h2&gt;
&lt;p&gt;1.希望函数所有实参接受隐式类型转换，需要定义成非成员函数；希望模版函数被自动具现化，需要声明在类内。所以需要友元函数，且定义在类内。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;oneHalf&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//需要实现这个  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="c1"&gt;//如果定义在类外的话，不能通过编译。因为“模版实参推导过程中不进行隐式类型转换”，所以int不会通过non-explicit构造函数，隐式转换成Ratioanl&amp;lt;int&amp;gt;，使模版函数operator*以int为实参具现出来。函数在类内则不同：oneHalf的定义，以int具现出来一个Rational类，编译器产生了该友元函数的声明，且该函数不是模版函数，所以接受隐式类型转换。  &lt;/span&gt;
    &lt;span class="k"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//在类模版内，可以把Rational&amp;lt;T&amp;gt;（模版名+参数名）简写成Rational（模版名）   &lt;/span&gt;
   &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="c1"&gt;//如果实现在外面的话，会链接错误。  &lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.很多编译期强迫把所有模版的定义式放进头文件里，比如模版函数的实现。  &lt;/p&gt;
&lt;h2&gt;Item 47: Use traits classes for information about types&lt;/h2&gt;
&lt;p&gt;1.STL迭代器分类&lt;br /&gt;
（1）input：istream_iterator&lt;br /&gt;
（2）output：ostream_iterator&lt;br /&gt;
（3）forward：slist（单链表，STL不包含该结构）&lt;br /&gt;
（4）bidirectional：set，multiset，map，multimap，list（双向链表）&lt;br /&gt;
（5）random_access：vector，deque，string&lt;br /&gt;
2.typeid确定一个变量的类型是运行期行为，“重载函数的最佳匹配”相当于编译期的类型确定，而且有if-else功能。&lt;br /&gt;
3.例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;deque&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//定义类型  &lt;/span&gt;
     &lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//引用T定义的类型  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//对指针的特化版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;   
    &lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//随即访问指针的重载版本  &lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;random_access_iterator_tag&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数不需要形参，因为没有用到  &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  

&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;DistT&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="n"&gt;advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterT&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;DistT&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="n"&gt;do_advance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator_category&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//第三个参数传入一个未命名对象，类型后跟一对括号  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 48: Be aware of template metaprogramming&lt;/h2&gt;
&lt;p&gt;1.TMP的主要意义：（1）完成一些其他方法没法实现的功能（2）将运行期的工作转移到编译期，可以提高程序执行效率。&lt;br /&gt;
2.##Item47中提到的do_advance方法，就是模版元编程里的if-else用法。用typeid没法实现（非random access iterator 没法编译通过iter+=d这句话）。&lt;br /&gt;
3.循环的用法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//变量在enum里，递归调用自身  &lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//循环结束条件：特化模版  &lt;/span&gt;
    &lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;  
&lt;span class="c1"&gt;//使用：  &lt;/span&gt;
&lt;span class="n"&gt;Factorial&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(12)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(12).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(12).html</id><summary type="html">&lt;p&gt;关于new和delete的东西，笔记不够详尽，因为新知识比较多，不太方便记录笔记。发现相关知识漏洞的时候，再去查看Cpp Primer和Effective Cpp相关章节。  &lt;/p&gt;
&lt;h2&gt;Item 49: Understand the behavior of the new-handler&lt;/h2&gt;
&lt;p&gt;1.&lt;code&gt;std::set_new_handler()&lt;/code&gt;可以绑定一个&lt;code&gt;new_handler&lt;/code&gt;（类型为&lt;code&gt;void (*)()&lt;/code&gt;），即new获取不到所需内存时调用的客户定制函数。如果不设置函数，或设置null，直接抛出异常&lt;code&gt;std::bad_alloc&lt;/code&gt;。&lt;br /&gt;
2.获取&lt;code&gt;new_handler&lt;/code&gt;函数的方式：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="n"&gt;set_new_handler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.new_handler应该具备以下一种功能：&lt;br /&gt;
（1）让更多内存可被使用。否则::operator new会无限循环调用非空的new_handler。例如程序开始分配一个内存池，动态分配不到资源的时候释放一些资源出来。&lt;br /&gt;
（2）安装另一个可以释放更多内存的new_handler函数。&lt;br /&gt;
（3）卸除new_handler，这样::operator new就会直接throw std::bad_alloc()异常了。&lt;br /&gt;
（4）抛出bad_alloc异常。不等operator new抛，自己就抛了。&lt;br /&gt;
（5）调用exit或abort直接退出程序。  &lt;/p&gt;
&lt;h2&gt;Item 50: Understand when it makes sense to replace new and delete&lt;/h2&gt;
&lt;p&gt;重写operator new和operator delete的原因：&lt;br /&gt;
（1）检查所分配内存上的运用错误：每次new的时候，在要分配空间的前后多分配一段内存，存放签名。delete的时候检查签名是否正确。如果前面的签名错了，发生了underrun（数据写到分配内存的前面了）；如果后面的签名错了，发生了overrun（ditto）。&lt;br /&gt;
（2）收集动态分配内存的使用情况：每次new的时候都要统计一些信息，比如分配了多少，等等&lt;br /&gt;
（3）加快速度：定制版本处理的情况比通用版本少，所以速度往往更快。&lt;br /&gt;
（4）降低空间开销：通用版本往往会分配额外一些内存来保存一些信息。小型对象分配器：Boost的Pool&lt;br /&gt;
（5）弥补缺省allocator非最佳齐位（alignment）：好多编译器上的new都声称保证16bit齐位，double变量需要32bit齐位，才能获得最佳的访问速度。&lt;br /&gt;
（6）获得非传统的行为：比如delete释放的时候，空间覆盖为0.  &lt;/p&gt;
&lt;h2&gt;Item 51:Adhere to convention when writing new and deletes(固守常规)&lt;/h2&gt;
&lt;p&gt;1.自定义operator new的时候，需要注意的几点&lt;br /&gt;
（1）尽量和::operator new行为一致，即while(true)下循环尝试分配内存，如果new_handle非0就调用，否则bad_alloc&lt;br /&gt;
（2）用户分配大小为0的空间  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator new的参数  &lt;/span&gt;
     &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）基类的operator new，需要首先执行  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//如果new派生类的话，使用全局版本的operator new  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.自定义operator delete的时候，需要注意的几点&lt;br /&gt;
（1）用户delete一个空指针  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//ptr是operator delete的参数  &lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）基类的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;   &lt;span class="c1"&gt;//size是operator delete的第二个参数  &lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 52: Write placement delete if you write placement new.&lt;/h2&gt;
&lt;p&gt;1.placement new，C++ Primer上翻译为定位new，理解为：特定位置（第二个参数指定的指针位置）上的new比较好。&lt;br /&gt;
2.编写placement new的时候，也要编写对应版本的placement delete。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ostream&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;否则，可能内存泄露。&lt;br /&gt;
因为，new表达式执行中，如果第一步operator new分配内存成功，但是构造函数抛出异常，C++运行期系统需要保证内存不发生泄露，就会自动调用&lt;strong&gt;对应版本&lt;/strong&gt;的operator delete释放内存。如果找不到对应版本的operator delete，就会造成内存泄露。&lt;br /&gt;
3.global作用域定义了3种形式的operator new和对应3种形式的operator delete  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;nothrow_t&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应delete版本就是第一个参数换成void*，全部不抛出异常。&lt;br /&gt;
4.定义于类内的operator new，不管是placement还是非placement，都会掩盖全局的3个版本。如果需要使用，重写这6个函数：函数体只是调用全局作用域的版本。&lt;br /&gt;
例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="nf"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bad_alloc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：&lt;strong&gt;不能在类内简单的using ::operator new，否则报错using-declaration for non-member at class scope。&lt;/strong&gt;只能using基类的被覆盖的名字，不能using全局的，但是可以用作用域限定符(::)调用全局的函数。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(8)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(8).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(8).html</id><summary type="html">&lt;h2&gt;Item 30: Understand the ins and outs of inlining.&lt;/h2&gt;
&lt;p&gt;1.inline（函数体代替函数调用）的好处：&lt;br /&gt;
（1）没有函数调用的开销，速度快。&lt;br /&gt;
（2）使编译器能对起进行outlined的函数所不具备的优化，因为上下文更明显了。&lt;br /&gt;
坏处：&lt;br /&gt;
（1）可能导致代码膨胀，如果inline函数内语句比较多的话。&lt;br /&gt;
（2）如果inline函数是程序库的一部分，对它的改动，需要使用者重新编译。（outline的话，直接链接即可，动态链接的话，使用者甚至不知道函数库的修改）&lt;br /&gt;
（3）大部分调试器不能调试inline函数。&lt;br /&gt;
2.inline是对编译器的申请，不是强制。&lt;br /&gt;
如下情况编译器”可能“拒绝inline（gcc -Winline会发出不能inline的警告，但是我尝试了递归和循环，没有发出警告）：&lt;br /&gt;
（1）函数太过复杂（包含递归或循环）。&lt;br /&gt;
（2）函数中调用virtual函数，因为多态是运行期行为，而inline是编译期行为。&lt;br /&gt;
如下情况提供outline版本：&lt;br /&gt;
（1）通过函数指针调用inline函数。因为如果inline函数没有outline版本的话，就没有函数地址了。&lt;br /&gt;
3.除了显示inline，类成员函数和友元函数定义与class内，也是inline函数&lt;br /&gt;
4.inline函数的函数体，通常应定义于头文件内，保证编译时可以用函数体替换函数调用。因为大多数C++编译器实现中，inling行为是编译行为。&lt;br /&gt;
5.构造和析构不适合inline。因为里面有编译器加入的代码（比如构造数据成员，出错就析构之前构造的成员），往往代码量不小，导致代码膨胀。  &lt;/p&gt;
&lt;h2&gt;Item 31: Minimize compilation dependencies between files.&lt;/h2&gt;
&lt;p&gt;1.降低文件间的编译依赖性（低耦合）的好处：&lt;br /&gt;
实现有所改变的时候，如果接口（类的public成员）没有改变，那么客户代码不用重新编译。&lt;br /&gt;
2.C++中类的定义，并没有“将接口从实现中分离”做的很好。因为类定义中，私有成员也会出现在头文件中。&lt;br /&gt;
类定义的头文件中仅仅包括前置声明（class Date;），然后在源文件中定义（Date Person::theBirthDate;）是行不通的。因为编译时，需要知道一个类型占据多大的内存，而编译器不会去查看源文件中的具体实现，仅仅查看头文件的类定义，所以必须在类定义中出现。&lt;br /&gt;
3.编译依赖性比较大的例子：&lt;br /&gt;
（0）具象类（concrete class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;string&amp;gt;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Date.h&amp;quot; &lt;/span&gt;&lt;span class="c1"&gt;//引入类型定义式  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Address.h&amp;quot;  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;theName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;theBirthDate&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="n"&gt;theAddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：Date或Address的修改，Person需要重新编译，继而Person的客户也要重新编译。Person实现的修改（比如增加或减少了成员变量），Person客户要重新编译，即使接口没有改变。&lt;br /&gt;
两种解决办法：&lt;br /&gt;
（1）句柄类（handle class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：大部分都是前置声明  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//实现细节隔离到了PersonImpl中，所以PersonImpl的实现改变后，不影响Person的客户  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//类型声明式  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Address&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="nl"&gt;private:&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//使用对象的指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：需要引入一些头文件中的类型定义  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;Person.h&amp;quot;  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;PersonImpl&amp;quot;   &lt;/span&gt;
&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;PImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;PersonImpl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)){}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只靠"类型声明式"(class Date)就可以定义该类型的引用或指针；必须提供"类型定义式"(#include "Date.h")才可以定义该类型的对象。  &lt;/li&gt;
&lt;li&gt;声明一个函数，如果函数的参数或返回值是某自定义类型的（比如Date），只包含其类型声明式即可（class Date）。  &lt;/li&gt;
&lt;li&gt;程序库作者应该提供两种头文件：类型声明式(datefwd.h)和类型定义式(Date.h)。客户在声明包含该类型的函数时，只需包含datefwd.h即可。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（2）接口类（interface class）  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件：  &lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//抽象类   &lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="c1"&gt;//全部是纯虚函数  &lt;/span&gt;
    &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//工厂函数，返回智能指针  &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//源文件：  &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;quot;RealPerson.h&amp;quot;  &lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Address&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;RealPerson&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较（个人观点）：&lt;br /&gt;
（1）易用性&lt;br /&gt;
handle class更易用： Person p1(...); string name=p1.getName()&lt;br /&gt;
interface class不好用：std::tr1::shared_ptr&lt;Person&gt; pp(Person::create(...)); string name=pp-&amp;gt;getName();&lt;br /&gt;
（2）扩展性&lt;br /&gt;
handle class没法扩展。&lt;br /&gt;
interface class方便扩展，基类可以有多个相同接口的派生类。比如create中增加一个参数，可以选择create哪个派生类。&lt;br /&gt;
4.句柄和接口类，会速度降低、内存消耗增大，但是的确可以带来松耦合的好处。&lt;br /&gt;
原则：开发过程中，用句柄和接口类；当它们导致的性能损失比较严重时，改成具象类。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(9)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(9).html" rel="alternate"></link><updated>2013-10-13T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-13:posts/2013/10/EffectiveCpp(9).html</id><summary type="html">&lt;h2&gt;Item 32: Make sure public inheritance models "is-a"&lt;/h2&gt;
&lt;p&gt;1.C++OOP最重要的规则是：公有继承模型，建模的是‘is-a’关系，基类有的特性派生类一定具有。&lt;br /&gt;
2.没有通用的设计，有些地方看似很合理的设计，在一些情形下却不能使用：&lt;br /&gt;
企鹅是鸟，但是鸟可以飞；正方形是矩形，但是矩形可以在不改变宽的情况下修改高&lt;br /&gt;
3.修改”企鹅-&amp;gt;鸟“设计：&lt;br /&gt;
（1）class Bird; class Penguin :public Bird; class FlyingBird: public Bird; //在Bird里不定义fly()，在FlyingBird里定义&lt;br /&gt;
（2）class Bird; class Penguin :public Bird; //在Bird里定义fly()，但是在Penguin里实现fly()中导出一个错误。&lt;br /&gt;
比较：前者更优，编译期错误。  &lt;/p&gt;
&lt;h2&gt;Item 33: Avoid hiding inherited names.&lt;/h2&gt;
&lt;p&gt;1.派生类中的名字，会掩盖基类中的名字。即使派生类中的函数和基类的函数参数列表不同，不论函数是non-virtual或virtual或pure-virtual的，派生类对象也无法调用基类被掩盖的函数。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//错误！！！  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的目的，是防止派生类从遥远的基类中继承它并不清楚的同名重载函数。&lt;br /&gt;
2.一般公有继承，都要继承父类的所有成员，所以采取两种办法可以解决掩盖，实现重载：&lt;br /&gt;
（1）using声明式  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;  
         &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//引入base的所有func的名字，如果func函数包括多个重载版本，都引入派生类作用域  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）forwarding function  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//之所以private inheritance，是因为公有继承的设计原则就是派生类拥有基类的一切特征  &lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;  
         &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);}&lt;/span&gt; &lt;span class="c1"&gt;//只引入base中的一个版本的func(int)，一般设计成inline，毕竟就一句。  &lt;/span&gt;
          &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 34: Differentiate between inheritance of interface and inheritance of implementation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;class设计者，将接口函数设计成不同类型，就会限制派生类的行为：&lt;br /&gt;
（1）纯虚函数——&amp;gt;接口继承，希望只继承其接口。&lt;br /&gt;
注：纯虚函数也可以实现（在源文件中），除非要提供默认的行为供子类调用(Base::fly();)，否则一般不实现。&lt;br /&gt;
（2）虚函数——&amp;gt;接口和实现继承，提供默认实现，允许覆盖继承的实现。&lt;br /&gt;
派生类不重新定义，就默认使用的基类的版本；派生类重新定义，就可以实现多态。&lt;br /&gt;
（3）非虚函数——&amp;gt;接口和实现继承，不希望被覆盖。&lt;br /&gt;
非虚函数，应该在派生类和基类中有一致的行为，所以不应该被覆盖（名字掩盖的话，就using进来基类的名字）。&lt;br /&gt;
如果想覆盖基类，就把基类的函数定义成virtual。&lt;br /&gt;
2.任何类如果打算作为基类，都要拥有若干virtual函数（至少析构函数）。&lt;br /&gt;
3.任何函数如果不变性（invariant）大于特异性（specialization），就应该被定义成基类的非虚函数，不让子类覆盖（虽然遵守与否看子类守不守规矩）。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Item 35: Consider alternatives to virtual functions.&lt;/h2&gt;
&lt;p&gt;正如上一个item所讲，虚函数的目的：提供默认实现，允许派生类覆盖。&lt;br /&gt;
public virtual的可选替代方案如下，实现了上面的两个目的：&lt;br /&gt;
（1）Template Method模式：NVI（non-virtual interface）手法&lt;br /&gt;
基类定义non-virtual函数healthValue()，调用private/protected virtual函数doHealthValue（每个派生类可以包含各自的实现）。&lt;br /&gt;
因为healthValue()有隐式this指针参数，所以根据调用对象的类型，可以执行不同类中定义的doHealthValue。&lt;br /&gt;
优点：避免代码重复。&lt;br /&gt;
healthValue函数，在调用doHealthValue的前面做一些准备工作（锁），在后面做一些清理工作。如果用public virtual的方法，每个派生类的函数都要有重复的准备和清理代码。&lt;br /&gt;
缺点：增加一个函数调用的开销。&lt;br /&gt;
（2）Strategy模式：非成员函数指针&lt;br /&gt;
基类有函数指针成员（healthFunc），构造函数中传入函数指针，比如int (*)(const GameCharacter&amp;amp;)，默认实参是一个缺省函数的指针。&lt;br /&gt;
优点：同一类型不同对象，可以有不同health函数；同一对象的行为也可以在运行时改变（提供setHealth函数）&lt;br /&gt;
缺点：非成员函数只能访问public成员，除非降低封装性，将其定义为友元函数，或private成员提供public访问方法。 &lt;br /&gt;
（3）Strategy模式：tr1::function&lt;br /&gt;
typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;&lt;br /&gt;
同上，但是支持函数指针、函数对象，和成员函数，且不需要函数完全匹配，兼容（参数和返回类型可以隐式转换）即可。&lt;br /&gt;
（4）Strategy模式：对象指针&lt;br /&gt;
类中包含，指向另一个继承体系的对象（包含一个healthFunc的函数）的指针，构造的时候传入。  &lt;/p&gt;
&lt;h2&gt;Item37: Never redefine a function's inherited default parameter values.&lt;/h2&gt;
&lt;p&gt;1.虚函数是dynamically bound，而默认参数statically bound。所以通过基类指针或引用访问派生类对象的成员函数，使用的基类的默认参数，和派生类的具体实现。&lt;br /&gt;
2.仅仅改变默认实参，不够成重载&lt;br /&gt;
3.派生类和基类中声明同样的默认参数，遵循默认参数不变的原则。但是代码重复，且有相依性（with dependencies），意味着一处修改就要多处修改。PS：貌似重复的代码大多都有相依性，所以杜绝复制粘贴，避免重复。&lt;br /&gt;
解决办法：NVI，仅在 base's non-virtual function上声明默认参数。  &lt;/p&gt;
&lt;h2&gt;Item 38: Model 'has-a' or 'is-implemented-in-terms-of' through composition.&lt;/h2&gt;
&lt;p&gt;1.复合(composition)还有一些同义词（synonym）：内含（containment），聚合（aggregation），内嵌（embedding）&lt;br /&gt;
2.复合，即对象包含在对象里面的情况。塑模两种情况&lt;br /&gt;
（1）has-a（包含）关系：应用域，比如人包含名字、地址&lt;br /&gt;
（2）is-implemented-in-terms-of（根据某物实现出）关系：实现域，比如set是根据linked list实现出的。&lt;br /&gt;
3.区分is-a和is-implemented-in-terms-of：&lt;br /&gt;
is-a的话，对基类为真的每一件事，对派生类也为真。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(7)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(7).html" rel="alternate"></link><updated>2013-10-12T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-12:posts/2013/10/EffectiveCpp(7).html</id><summary type="html">&lt;h2&gt;Item 26: Postpone variable definitions as long as possible.&lt;/h2&gt;
&lt;p&gt;1.延后变量定义的意义是，有可能变量定义后，出现异常导致变量用不到，这样变量的构造和析构函数就白费了。所以，只在使用这个变量的代码之前定义它。&lt;br /&gt;
2.循环内变量的使用，是个特殊情况。但是仍然鼓励在循环内，变量使用前才定义变量。除非满足下面两点&lt;br /&gt;
(1)赋值成本比构造+析构成本低 (2)该段代码是效率敏感（performance-sensitive）的部分&lt;br /&gt;
因为：缩小变量的作用域，对于程序的可理解性和易维护性好。  &lt;/p&gt;
&lt;h2&gt;Item 27:Minimizing casting&lt;/h2&gt;
&lt;p&gt;1.C++风格类型转换中，&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;(expr)&lt;/code&gt;是唯一一个无法用旧式语法（C风格，函数风格）执行的动作，用来将基类的指针或引用转化为子类的指针或引用。&lt;br /&gt;
2.能用C++风格转型，就不用旧式语法。因为它们容易在代码中被辨识出来，因为简化了"找出类型系统在哪个地点被破坏"的过程。&lt;br /&gt;
3.显示构造：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//func的调用方式，包括3种强制类型转换的方式：  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle函数式类型转换，也理解为构造一个临时的Widget对象&lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//Cstyle标准类型转换  &lt;/span&gt;
&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//C++style类型转换  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.单一对象可能有一个以上的地址。Base&lt;em&gt;指向它和Derived&lt;/em&gt;指向它时的地址可能不同，这依赖于编译器将C++的对象如何布局。&lt;br /&gt;
而且，一旦多重继承，多个基类的指针指向同一个对象，地址一定是不一样的。&lt;br /&gt;
5.以上例子表明，类型转换并不仅仅是让编译器把某种类型视为另一种类型，其他什么也没做。&lt;br /&gt;
6.派生类虚函数中调用基类的版本，错误做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//调用onResize的不是this的base部分，而是强制类型转换所建立的临时对象  &lt;/span&gt;
&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//因为是虚函数，且是基类的引用，会调用自己，无穷递归。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确做法：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WIndow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;onResize&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7.应该尽量避免dynamic_cast，因为很多实现版本效率很低（比如调用多个strcmp，逐层比较class name）。&lt;br /&gt;
办法是，让父类定义空virtual函数，运用多态自动调用派生类的相应函数。&lt;br /&gt;
8.来自Cpp Primer：&lt;br /&gt;
dynamic_cast（成功返回相应指针或引用，失败返回NULL或抛出异常）：处理含有virtual函数的基类引用或指针，返回动态类型。&lt;br /&gt;
typeid（返回type_info对象，支持相等比较运算和name()方法）：处理含有virtual函数的基类，返回动态类型。  &lt;/p&gt;
&lt;h2&gt;Item 28:Avoid returning handles to object internals&lt;/h2&gt;
&lt;p&gt;1.以下句子编译可以通过，但是是错误的，因为这样的话外部就可以修改内部数据了，与const矛盾了。这是因为const成员函数实现的是bitwise const，而不是logical const  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;span class="c1"&gt;//修改成：  &lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;upperLeft&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;ulhc&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.引用、指针和迭代器都是所谓的handle，返回一个指向内部数据的handle，降低封装性，而且可能导致悬垂handle（即handle所指向的对象被销毁了，因为handle生存期可能比对象长）。&lt;br /&gt;
因此，尽量避免返回指向内部对象的handle，除非像string和vector的operator[]方法，不得不做的时候。  &lt;/p&gt;
&lt;h2&gt;Item 29: Strive for exception-safe code.&lt;/h2&gt;
&lt;p&gt;错误例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1.“异常安全”两个条件：&lt;br /&gt;
（1）不泄露任何资源&lt;br /&gt;
（2）不允许数据败坏&lt;br /&gt;
例子中，如果new出错（时刻注意，new分配内存的时候可能因为内存不足而抛出异常），mutex资源泄露，bgImage指针悬空。&lt;br /&gt;
“异常安全的函数”满足两个条件后，还分3个等级：&lt;br /&gt;
（1）基本承诺，即保证：任何事物在有效状态下，只是调用者不确切知道处于哪种状态。&lt;br /&gt;
（2）强烈保证，即保证：函数成功就完全成功；失败，就回到调用前的状态。&lt;br /&gt;
（3）不抛异常保证，即保证：只成功不失败，不抛出异常。&lt;br /&gt;
2.不抛出异常：只能靠程序保证。如下声明：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只是告诉调用者，不打算抛出异常。但是“完全可能”抛出异常，那时候会有一个函数被调用（std::set_unexpected函数的参数绑定的异常处理函数，该函数会在抛出非声明的类型的异常时执行）。&lt;br /&gt;
3.强烈保证：&lt;br /&gt;
变换语句顺序有时候可以做到；copy-and-swap一般可以做到。&lt;br /&gt;
（1）变换语句顺序：delete 和 ++放到new后面。当然用对象管理资源更安全和简洁  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;ml&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;bgImage&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;imgSrc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//reset的过程中，原image会delete  &lt;/span&gt;
     &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;imageChanges&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="c1"&gt;//函数退出后，Lock析构会释放mutex  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）copy-and-swap：把打算修改的对象复制一份，然后修改副本，再把副本和原对象交换。&lt;br /&gt;
4.尽量让函数等级更高，但是不抛出异常很难保证，因为很多库函数都可能抛出异常；强烈保证可能耗费很大的代价，比如copy and swap方法，复制构造和赋值操作的代价。&lt;br /&gt;
权衡的过程：tradeoff。&lt;br /&gt;
但是，要在文档上说明清楚可能抛出的异常等，以及为什么没有实现安全级别更高的代码。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(5)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(5).html" rel="alternate"></link><updated>2013-10-11T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-11:posts/2013/10/EffectiveCpp(5).html</id><summary type="html">&lt;h2&gt;Item18:  Make interfaces easy to use correctly and hard to use incorrectly&lt;/h2&gt;
&lt;p&gt;1.促进接口被正确使用：&lt;br /&gt;
（1）接口一致性：stl中所有容器都具有size() 函数，而不像Java和.Net。&lt;br /&gt;
（2）与内置类型行为兼容：想想和int类比。&lt;br /&gt;
2.阻止接口被误用（！！！不正确的行为，编译都不能通过）：&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Date&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;month&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;year&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）建立新类型，防止调用顺序错乱，比如(2013,1,10)。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//定义Month,Day,Year类型（struct，只含一个val变量和一个explicit单个参数构造函数即可）  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）束缚对象值，防止无意义的值，比如(Month(13),Day(1),Year(2013))。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//Date类中私有化构造函数。  &lt;/span&gt;
&lt;span class="c1"&gt;//只提供一系列静态函数供调用。static Month Jan() {return Month(1);}  &lt;/span&gt;
&lt;span class="c1"&gt;//不能定义static Month Jan(1);因为 非局部静态对象的初始化顺序未定义，万一d是全局的对象，构造时可能Jan对象尚未初始化。  &lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="nf"&gt;d&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Month&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Jan&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;Day&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;Year&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2013&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）消除对象的资源管理责任，防止忘记释放资源。&lt;br /&gt;
//提供智能指针对象，而不是原始资源&lt;br /&gt;
总结：C++中为了保证接口不被误用，可能会增加很多C语言程序员看起来感觉冗余的代码，比如增加Month，Day，Year 3个类，比如定义Month::Jan()等静态函数。但是的确起到了C语言没法起到的作用：&lt;br /&gt;
（1）没法，只能认真看接口原型。&lt;br /&gt;
（2）可以通过函数内语句判断合法性，但是就将错误推迟到了运行时。&lt;br /&gt;
（3）没法，只能提醒自己释放。  &lt;/p&gt;
&lt;h2&gt;Item19: Treat class design as type design&lt;/h2&gt;
&lt;p&gt;1.应该带着和“语言设计者当初设计语言内置类型时”一样的谨慎来研究class的设计。&lt;br /&gt;
2.允许T1类型被隐式转换成T2类型：&lt;br /&gt;
（1）T1类内定义operator T2()函数。&lt;br /&gt;
（2）T2含有非explicit的构造函数，且函数参数只有一个T1类型的对象。&lt;br /&gt;
3.设计类时遵循的准则略，需要设计类时查阅该书。  &lt;/p&gt;
&lt;h2&gt;Item20: Prefer pass-by-reference-to-const to pass-by-value&lt;/h2&gt;
&lt;p&gt;1.传递对象的引用，好处：&lt;br /&gt;
（1）效率高。值传递会调用参数的复制构造函数（同时调用其基类和成员变量的复制构造函数），函数退出时还要调用它们的析构函数。&lt;br /&gt;
（2）易于优化。常量引用的实现是指针，编译器通常更愿意将其放入缓存器。即使class尽含有一个double变量，编译器也不视其为内置类型，拒绝将其放入缓存器。&lt;br /&gt;
2.传递“常量”引用，好处：&lt;br /&gt;
（1）调用者不必担心传入的实参被改变。&lt;br /&gt;
（2）const或non-const对象都可以传入，适用范围更广。&lt;br /&gt;
3.小型自定义类型也不要值传递，原因：&lt;br /&gt;
（1）复制构造函数不一定小型（比如可能要deep-copy）。&lt;br /&gt;
（2）不易于被编译器优化，放入缓存器。&lt;br /&gt;
（3）该自定义类型可能在之后的更新中，体积变大。&lt;br /&gt;
4.不适合引用传递的情况：&lt;br /&gt;
（1）内置类型：效率更高，见下图&lt;br /&gt;
&lt;img alt="ec5" src="http://particle128.com/images/ec5.png" /&gt;
（2）STL迭代器：类似指针，STL会保证其复制构造效率高，习惯值传递&lt;br /&gt;
（3）函数对象：实质是指针  &lt;/p&gt;
&lt;h2&gt;Item21: Don't try to return a reference when you must return an object.&lt;/h2&gt;
&lt;p&gt;函数返回对象的时候，也会执行一次构造和析构函数。为了减少这次的构造和析构，可能考虑返回引用。问题：&lt;br /&gt;
（1）指向局部变量：显而易见不行。&lt;br /&gt;
（2）指向动态分配的堆上的对象：内存泄露。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//两个new出来的对象都没有办法释放，因为接触不到new出的指针。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）指向静态变量：多线程问题，还有语义上瑕疵。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//假设友元函数operator *返回Rational&amp;amp;  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;//总是返回true，因为返回的都是同一个static对象  &lt;/span&gt;
&lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(6)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(6).html" rel="alternate"></link><updated>2013-10-10T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-10:posts/2013/10/EffectiveCpp(6).html</id><summary type="html">&lt;h2&gt;Item 22: Declare data members private&lt;/h2&gt;
&lt;p&gt;1.把变量声明成private，然后通过public函数访问。好处：&lt;br /&gt;
（1）语法一致性。public里都是函数，不用考虑是否需要加括号。&lt;br /&gt;
（2）更精确的访问控制。可以通过get和set设置变量的可都写属性。&lt;br /&gt;
（3）封装。对底层的机制提供很大的弹性，成员变量的修改，不影响客户的使用。（比如averageSoFar()函数，可以返回average变量，也可以直接计算平均值再返回。一个占空间，一个费时间，在不同环境可以选择不同的实现）&lt;br /&gt;
2.只有private有封装性，protected和public都没有封装性。&lt;br /&gt;
因为封装性与“当其内容改变时可能造成的代码破坏量”成反比，内容改变可以理解成把它从class中移除。&lt;br /&gt;
（1）public变量移除，所有使用它的客户代码都会破坏。&lt;br /&gt;
（2）protected变量移除，所有继承自该类的派生类都会破坏。  &lt;/p&gt;
&lt;h2&gt;Item 23: Prefer non-member non-friend functions to member functions.&lt;/h2&gt;
&lt;p&gt;1.正如上一个条款所述，越多代码可以访问一个数据，数据的封装性就越差。因为越多代码访问它，它改变时造成的破坏越大，导致数据的实现弹性变小。&lt;br /&gt;
2.成员函数，友元函数可以访问类内的private成员，enum和typedef等，而非成员函数都不能访问。所以，使用非成员函数，类内私有数据的封装性更好。&lt;br /&gt;
所以，对于只"调用一个类的public成员的函数"，让其在该类的同名命名空间（可以同该类的定义不在一个文件内）下，作为非成员函数较好。&lt;br /&gt;
3.标准库STL的组织方式：namespace std跨越多个文件，需要使用的机能只要添加相应的头文件（比如#include &lt;vector&gt;）即可。  &lt;/p&gt;
&lt;h2&gt;Item 24: Declare non-member functions when type conversions should apply to all parameters&lt;/h2&gt;
&lt;p&gt;隐式类型转换，只能作用在参数上，所以成员函数的调用者（*this）作为调用者不能转换。&lt;br /&gt;
例子：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Rational&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="n"&gt;Rational&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;  
    &lt;span class="p"&gt;...&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="c1"&gt;//支持以下操作：  &lt;/span&gt;
&lt;span class="n"&gt;Rational&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//explicit构造函数不具备的  &lt;/span&gt;
&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt; &lt;span class="c1"&gt;//operator*作为成员函数不具备的  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Item 25: Consider support for a non-throwing swap.&lt;/h2&gt;
&lt;p&gt;1.关于修改std：&lt;br /&gt;
不能修改std命令空间内的任何东西，也不能添加新的函数、类或模版等新的东西到std内，std的内容由C++标准委员会决定。&lt;br /&gt;
虽然添加东西进std仍可以编译和执行，但是行为没有明确定义。所以要杜绝。&lt;br /&gt;
唯一可以在std内做的事情是:全特化std命名空间下已存在的模版。不能偏特化，因为偏特化相当于在std内增加模版。&lt;br /&gt;
2.类模版可以偏特化(partially specialize)或全特化(totally specialize)；函数模版只能全特化。&lt;br /&gt;
偏特化指的是只特化一部分模版参数，而不是全部。&lt;br /&gt;
3.std内有一个swap模版函数，实现如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用1次拷贝构造，两次赋值操作符。&lt;br /&gt;
对于一种类型的对象而言，这个swap函数代价太大：对象内含指针，指针指向真正存放数据的对象(pimpl技术)。&lt;br /&gt;
因为对这类对象而言，交换指针即可。但是其实现必须保证复制构造和赋值操作符都是深复制（当然也可以用智能指针代替，这里不考虑），所以直接在Widget上调用swap会非常低效。&lt;br /&gt;
例如：&lt;br /&gt;
WidgetImpl类：int a,b,c; double d1,d2;&lt;br /&gt;
Widget类：WidgetImpl *pImpl;&lt;br /&gt;
解决，两步：&lt;br /&gt;
【1】Widget内提供成员函数  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//使用using std::swap,而不是直接在下面的句子调用std::swap(...)&lt;/span&gt;
    &lt;span class="c1"&gt;//这样给编译器一个选择的余地，它会在WidgetImpl类所在命名空间(argument-dependent lookup)，&lt;/span&gt;
    &lt;span class="c1"&gt;//和当前命名空间或上层(normal lookup)，上分别进行名字查找来确定候选函数。&lt;/span&gt;
    &lt;span class="c1"&gt;//然后调用最合适的swap版本。最合适的版本是依据转换代价最小来确定的，而跟位于哪个作用域没有关系。  &lt;/span&gt;
    &lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//在这里是调用了stl中的swap（normal lookup的结果），因为WidgetImpl所在命名空间内没有&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;【2】 std内特化swap  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;  
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:如果Widget是模版类，不能在std空间下定义swap，因为不支持偏特化函数，即使支持也不能添加到std里。这时候，在Widget定义所在的命名空间内定义一个模版swap函数&lt;code&gt;template&amp;lt;typename T&amp;gt;void swap(Widget&amp;lt;T&amp;gt;&amp;amp;a,Widget&amp;lt;T&amp;gt;&amp;amp;b){...}&lt;/code&gt;，可以保证在使用swap(w1,w2)的时候，至少候选函数中会包含这个版本，这得益于argument-dependent lookup。
4.下面来自CppPrimer的内容(第4中文版：P232和P571)：&lt;br /&gt;
重载函数中既有普通函数，又有函数模版，确定具体哪个函数被调用的过程：&lt;br /&gt;
(1)确定候选函数（candidate functions），即调用点声明可见的同名普通函数，和可实例化模板函数。&lt;br /&gt;
(2)确定可行函数（viable functions），排除普通函数中没法匹配的函数。&lt;br /&gt;
(3)寻找实参和形参的最佳匹配，即转换代价最小的匹配。&lt;br /&gt;
(4)如果上面寻找到的最佳匹配有二义，去掉模版函数再寻找最佳匹配。&lt;br /&gt;
转换代价由低到高：&lt;br /&gt;
(1)exact match精确匹配（类型一致，比如形参和实参都是int）&lt;br /&gt;
(2)promotion整型提升（比如short转化成int）&lt;br /&gt;
(3)standard conversion标准转换（除类型提升外的隐式转换，比如bool转化成int，short转换成long）&lt;br /&gt;
(4)class-type conversion类类型转换（含有one-parameter-non-explicit构造函数的类，用构造函数参数类型转化成类类型）  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(3)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(3).html" rel="alternate"></link><updated>2013-10-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(3).html</id><summary type="html">&lt;h2&gt;Item 09: Never call virtual functions in constructions and destructions&lt;/h2&gt;
&lt;p&gt;1.derived class对象构造时，base class构造函数先被调用，在其中调用/间接调用的虚函数是是父类的版本。原因有二：&lt;br /&gt;
（1）父类构造时，子类成员变量尚未初始化，处于未定义状态，C++不允许调用子类virtual函数（几乎必然会访问成员变量）&lt;br /&gt;
（2）父类构造函数执行时，动态类型是父类。&lt;br /&gt;
同理，析构函数。&lt;br /&gt;
2.替代策略：对于每个子类都要调用的函数，不声明virtual&lt;br /&gt;
（1）每个子类构造函数分别调用相应函数。例如logTransaction()&lt;br /&gt;
（2）子类构造函数显示调用父类构造函数，传递参数上去。例如&lt;code&gt;BaseClass(createLogString(para))&lt;/code&gt;，其中createLogString是static成员，保证不会访问子类对象的成员变量。  &lt;/p&gt;
&lt;h2&gt;Item 11: Handle assignment to self in operator=&lt;/h2&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
     &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
         &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
         &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;问题：自我赋值安全性，异常安全性。&lt;br /&gt;
解决：&lt;br /&gt;
（1）证同测试 identity test  -》解决了自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;==&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;  &lt;span class="c1"&gt;//测试是否是自我赋值  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//异常可能发生，比如内存不足，复制构造函数有异常抛出。如果外面捕获了该异常，并继续执行程序，那么pb将指向被释放了的空间，之后任何操作都会引起未定义行为。  &lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）调整语句顺序 -》解决异常安全性，同时解决自我赋值安全性  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="p"&gt;{&lt;/span&gt;  
     &lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pb&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//先构造，后删除  &lt;/span&gt;
     &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;pOrig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）copy and swap -》解决异常安全性，同时解决自我赋值安全性&lt;br /&gt;
思想就是用参数构造一个临时对象，然后和类内对象交换。具体代码略。  &lt;/p&gt;
&lt;h2&gt;Item 12： Copy all parts of an object&lt;/h2&gt;
&lt;p&gt;1.如果类中新增了一个成员变量，一定记得同时修改构造函数、复制构造函数和赋值操作符，确保新成员变量被合理的初始化和赋值。&lt;br /&gt;
2.派生类定义的复制构造函数，和赋值操作符，需要调用基类的相应函数，否则前者隐式调用基类的默认构造函数，后者则不会调用基类的赋值操作符。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;),...&lt;/span&gt; &lt;span class="p"&gt;{...}&lt;/span&gt;  
&lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Derived&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//也可以使用if(this==&amp;amp;rhs)包裹函数体，跳过自我赋值。这需要权衡自我赋值的次数，以及增加这一条判断语句的代价。一般可以不加这句话。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：编译器合成的版本，会自动调用基类的复制构造和赋值操作，就像上面实现的一样。&lt;br /&gt;
3.重复代码放到私有函数init里，不要复制构造调用赋值操作符，或反过来。  &lt;/p&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Effective C++学习笔记(4)</title><link href="http://particle128.com/posts/2013/10/EffectiveCpp(4).html" rel="alternate"></link><updated>2013-10-04T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-10-04:posts/2013/10/EffectiveCpp(4).html</id><summary type="html">&lt;h2&gt;Item 13: Use objects to manage resources&lt;/h2&gt;
&lt;p&gt;1.资源是指，使用完之后需要归还系统的东西。比如动态分配的内存，文件描述符，互斥锁，数据库连接，sockets。&lt;br /&gt;
2.尽管可以手动释放资源（比如delete），但是程序的修改（delete之前返回了），或客户的忘记，可能导致资源释放不了。&lt;br /&gt;
解决办法：用对象管理资源，利用对象在作用域范围之外会自动调用析构函数的机制，释放资源。&lt;br /&gt;
对于heap-based资源（资源new出来的，通过指针访问），有如下两种智能指针可用：&lt;br /&gt;
（1）std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); &lt;br /&gt;
缺点：指向同一对象的auto_ptr，进行赋值或拷贝构造，会导致原ptr变成null。这样的目的，释放多次同一个资源。&lt;br /&gt;
（2）std::tr1::shared_ptr&lt;Investment&gt; pInv(createInvestment());&lt;br /&gt;
注意：不存在上面的问题，因为是RCSP(引用计数智能指针)。&lt;br /&gt;
3.以上两种指针，都是在析构函数中使用delete，动态数组元素放入上面两个智能指针中，会导致释放不完全。&lt;br /&gt;
解决：&lt;br /&gt;
（1）使用vector代替动态数组。&lt;br /&gt;
（2）仍然使用动态数组，那么使用&lt;code&gt;boost::scoped_array&lt;/code&gt;，&lt;code&gt;boost::shared_array&lt;/code&gt;。  &lt;/p&gt;
&lt;h2&gt;Item 14: Think carefully about copying behavior in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.不是heap-based的资源，需要自己建立资源管理类。然后将需要管理的资源类放在一个大括号内，退出大括号析构函数负责释放资源。&lt;br /&gt;
2.资源管理类的复制行为：&lt;br /&gt;
（1）不希望复制：&lt;br /&gt;
private继承Uncopyable&lt;br /&gt;
（2）资源一个副本，引用计数：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
&lt;span class="nl"&gt;public:&lt;/span&gt;  
    &lt;span class="k"&gt;explicit&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Mutex&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;mutexPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//第二个参数是删除器，引用计数为0时调用的函数。不带此参数默认行为是delete  &lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;  
         &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;  
     &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tr1&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Mutext&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;mutextPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（3）资源多个副本：&lt;br /&gt;
每次复制资源都深拷贝。&lt;br /&gt;
（4）转移资源拥有权：&lt;br /&gt;
使用std::auto_ptr。  &lt;/p&gt;
&lt;h2&gt;Item 15: Provide access to raw resources in resource-managing classes&lt;/h2&gt;
&lt;p&gt;1.API往往访问原始资源，所以资源管理类要提供取得原始资源的办法。&lt;br /&gt;
2.标准库中两个智能指针的做法：&lt;br /&gt;
（1）显式访问：get()&lt;br /&gt;
（2）隐式访问：成员访问操作符 -&amp;gt; 和 .可以访问到原始资源的成员&lt;br /&gt;
3.自定义资源管理类的做法：&lt;br /&gt;
（1）显式访问：定义get() ，更安全&lt;br /&gt;
&lt;code&gt;FontHandle get() const {return f;}&lt;/code&gt;&lt;br /&gt;
（2）隐式访问：定义隐式转换函数 ，更方便&lt;br /&gt;
&lt;code&gt;operator FontHandle() const {return f;}&lt;/code&gt;  &lt;/p&gt;
&lt;h2&gt;Item16: Use the same form in corresponding uses of new and delete&lt;/h2&gt;
&lt;p&gt;1.new执行过程：通过名为operator new的函数分配内存；在该块内存有一个或多个（new string[4]）构造函数被调用。&lt;br /&gt;
delete执行过程：在该内存有一个或多个（delete [] arr）析构函数被调用；通过名为operator delete的函数释放内存。&lt;br /&gt;
2.delete []一个对象，和delete一个数组，结果都未定义。因为数组在内存的布局可能是：起始地址放置数组大小（4B），之后是数组内容。&lt;br /&gt;
3.注意typedef定义的数组类型的释放:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StrArr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非常容易引起混淆，所以最好不好定义数组类型，vector代替。  &lt;/p&gt;
&lt;h2&gt;Item17: Store newed object in smart pointers in standalone statements(standalone 独立的)&lt;/h2&gt;
&lt;p&gt;1.例子：&lt;br /&gt;
&lt;code&gt;processWidget(std::tr1::shared_ptr&amp;lt;Widget&amp;gt;(new Widget),priority());&lt;/code&gt; &lt;br /&gt;
问题：编译器的优化可能导致这种顺序的调用。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Widget&lt;/span&gt;  
&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//如果抛出异常，new的资源就泄露了，因为没有指针指向它，没法释放  std::tr1::shared_ptr&amp;lt;Widget&amp;gt;构造函数  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决办法：独立语句中将动态分配的对象存入智能指针。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;tr1&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nl"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Widget&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="nx"&gt;processWidget&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;</summary><category term="EffectiveCpp"></category></entry><entry><title>Python学习笔记-字符串</title><link href="http://particle128.com/posts/2013/09/python-str.html" rel="alternate"></link><updated>2013-09-22T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-22:posts/2013/09/python-str.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;注意：str支持的操作，基本上unicode也支持。此外unicode还多两个函数unicode.isnumeric() unicode.isdecimal()&lt;/strong&gt;  &lt;/p&gt;
&lt;h3&gt;（一） 具备的操作&lt;/h3&gt;
&lt;p&gt;str作为序列元素，包含其他序列共同的操作：&lt;br /&gt;
1. “hello” [not] in "hello world"&lt;br /&gt;
2. "hello" + " world"&lt;br /&gt;
3. 5*"hello" 或 “hello”*5&lt;br /&gt;
4. "hello"[3]  "hello"[1:2]  "hello"[1:2:2]&lt;br /&gt;
5. len("hello")  min("hello")  max("hello")&lt;br /&gt;
6. "hello".index('o')   "hello".count('l')  &lt;/p&gt;
&lt;h3&gt;（二） 不具备的操作&lt;/h3&gt;
&lt;p&gt;str同tuple一样，属于不可变序列。可变序列包括list和bytearray。因此str不具备可变序列的操作：&lt;br /&gt;
1. s[i] = x    s[i:j] = t 【t是任何可迭代对象】 s[i:j:k] = t 【t需要和s[i:j:k]有相同数量的元素】&lt;br /&gt;
2. del s[i:j]    del s[i:j:k]   s.remove(x) =&amp;gt; del s[x]&lt;br /&gt;
3. s.insert(i, x)  s.append(x)  s.extend(t) 【t是任何可迭代对象】&lt;br /&gt;
4. s.reverse()    s.sort([cmp[, key[, reverse]]])&lt;br /&gt;
5. s.pop([i]) =&amp;gt; x = s[i]; del s[i]; return x  &lt;/p&gt;
&lt;h3&gt;（三） 字符串方法&lt;/h3&gt;
&lt;p&gt;str.capitalize()第一个字母大写 str.title() 每一个单词首字母大写&lt;br /&gt;
str.count(sub[, start[, end]])&lt;br /&gt;
str.endswith(suffix[, start[, end]])返回True或False 同理str.startswith&lt;br /&gt;
str.find(sub[, start[, end]]) 找不到返回-1 同理str.rfind&lt;br /&gt;
str.index(sub[, start[, end]])找不到raise ValueError 同理str.rindex&lt;br /&gt;
str.format(*args, **kwargs) 同格式化字符串&lt;br /&gt;
islower isupper isspace isdigit isalpha isalnum&lt;br /&gt;
str.ljust(width[, fillchar])左对齐，可以选择填充字节，默认空格。 同理str.rjust，str.zfill(width)相当于str.rjust(width,'0')&lt;br /&gt;
str.lower() str.upper() str.swapcase()交换大小写&lt;br /&gt;
str.partition(sep) 划分 'what the fuck'.partition('the') =&amp;gt; ('what ','the',' fuck') 同理rpartition&lt;br /&gt;
str.join(iterable) 把可迭代对象（比如序列）拼接成字符串，用str隔开每一个可迭代对象中的元素&lt;br /&gt;
str.translate(string.maketrans(from,to) [,deletechars]) 要么进行字母的替换，要么进行字母的删除（第一个参数为None），要么同时进行&lt;br /&gt;
str.strip([chars]) 默认去掉whitespace 同理str.lstrip str.rstrip &lt;br /&gt;
str.split([sep]) 默认whitespace作为分隔符  &lt;/p&gt;
&lt;h3&gt;（四） string方法&lt;/h3&gt;
&lt;p&gt;string.maketrans(from,to) 返回translation table（from中的字符被to中同一位置的字符替换），from和to长度要相同&lt;br /&gt;
string.capwords(s[,sep]) 比titile更加准确的首字母大写函数。先split([sep])，再capitalize()，再join()  &lt;/p&gt;
&lt;h3&gt;（五） 格式化字符串&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%(language)s&lt;/span&gt;&lt;span class="s"&gt; has &lt;/span&gt;&lt;span class="si"&gt;%(number)03d&lt;/span&gt;&lt;span class="s"&gt; quote types.&amp;quot;&lt;/span&gt;  &lt;span class="o"&gt;%&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;（六）字符串常量&lt;/h3&gt;
&lt;p&gt;string.digits&lt;br /&gt;
string.hexdigits&lt;br /&gt;
string.octdigits&lt;br /&gt;
string.lowercase&lt;br /&gt;
string.uppercase&lt;br /&gt;
string.whitespace&lt;br /&gt;
string.punctuation  &lt;/p&gt;</summary><category term="python"></category><category term="str"></category></entry><entry><title>Linux下使用Github Pages搭建博客</title><link href="http://particle128.com/posts/2013/09/blog-build.html" rel="alternate"></link><updated>2013-09-20T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-20:posts/2013/09/blog-build.html</id><summary type="html">&lt;h2&gt;环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ubuntu12.04LTS(自带python2.7)  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;前期准备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;注册&lt;a href="https://github.com"&gt;github&lt;/a&gt;，建立一个名为{yourusername}.github.io的repository（不知道咋翻译,数据仓库？）  &lt;/li&gt;
&lt;li&gt;安装pelican和markdown  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install markdown &lt;span class="c"&gt;#linux下的markdown软件  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install python-pip &lt;span class="c"&gt;#安装pip&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install markdown &lt;span class="c"&gt;#python的markdown包  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;sudo pip install pelican &lt;span class="c"&gt;#python的pelican包  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果没有安装markdown或python的markdown包，会出现如下错误：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;WARNING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Could&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="sr"&gt;/path/to/&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;md&lt;/span&gt;  
&lt;span class="s1"&gt;&amp;#39;bool&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;object&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;callable&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;搭建pelican环境&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具体pelican的操作，可以查看&lt;a href="http://docs.getpelican.com/en/3.3.0/"&gt;文档&lt;/a&gt;&lt;br /&gt;
搭建命令如下：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /path/to/blog&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;s/container  
&lt;span class="nv"&gt;$ &lt;/span&gt;mkdir blog &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nb"&gt;cd &lt;/span&gt;blog  
&lt;span class="nv"&gt;$ &lt;/span&gt;pelican-quickstart &lt;span class="c"&gt;#进行相应配置  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;output &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; git clone &lt;span class="o"&gt;{&lt;/span&gt;clone URL of your github.io repository&lt;span class="o"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;修改&lt;br /&gt;
对MakeFile文件进行如下修改：  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nf"&gt;github&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;publish  &lt;/span&gt;
&lt;span class="err"&gt;cd&lt;/span&gt; &lt;span class="err"&gt;OUTPUTDIR&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;add&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt;  &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;commit&lt;/span&gt; &lt;span class="err"&gt;-am&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;your comments&amp;#39;&lt;/span&gt; &lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;git&lt;/span&gt; &lt;span class="err"&gt;push&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次在blog/content里写markdown格式的文档，执行&lt;code&gt;make devserver&lt;/code&gt;，查看http://localhost:8000，并随时修改md文件。确认无误后，执行&lt;code&gt;make github&lt;/code&gt;一键生成网站与上传github。上传成功后，等待up to 10minutes就可以通过http://{yourusername}.github.io访问新修改的博客了。&lt;br /&gt;
markdown语法很简单，不清楚的可以查看&lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;markdown语法&lt;/a&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载pelican主题和插件  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;blog  
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/getpelican/pelican-themes.git &lt;span class="c"&gt;#getpelican提供的好多主题  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/duilio/pelican-octopress-theme.git &lt;span class="c"&gt;#pelican下octopress的主题  &lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/getpelican/pelican-plugins.git &lt;span class="c"&gt;#getpelican提供的一些插件  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使用插件和主题，需要修改配置文件，见后。&lt;br /&gt;
PS：默认代码高亮部分不太喜欢，所以我进行了如下修改，把灰黑色的背景改成了白色。  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sed -i &lt;span class="s1"&gt;&amp;#39;s/002b36/ffffff/g&amp;#39;&lt;/span&gt; pelican-octopress-theme/static/css/main.css  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用disqus评论系统&lt;br /&gt;
注册&lt;a href="https://disqus.com/admin/signup/"&gt;Disqus&lt;/a&gt;，然后在配置文件里添加新注册的Disqus的Site short name，具体配置文件见后面。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Google站长工具，以便能被Google收录&lt;br /&gt;
用谷歌账户登陆&lt;a href="https://www.google.com/webmasters/"&gt;Google Webmaster Tools&lt;/a&gt;，添加自己的站点，比如particle128.com，然后可以选择提交sitemap，或者替google手动抓取页面。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Baidu站长工具，以便能被Baidu收录&lt;br /&gt;
用百度账户登陆&lt;a href="http://zhanzhang.baidu.com/"&gt;Baidu Webmaster Tools&lt;/a&gt;，添加自己的站点，比如particle128.com。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Google的Custom Search Engine，可以站内搜索&lt;br /&gt;
使用谷歌账户登陆&lt;a href="https://www.google.com/cse/"&gt;CSE&lt;/a&gt;，添加自己的站点，比如particle128.com。&lt;br /&gt;
然后在content/pages/里建一个search.md文件，除了开头的&lt;code&gt;title:Search slug:search&lt;/code&gt;元数据外，其余内容复制cse里的代码。pages里的文件自动会加载到标题栏。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置文件&lt;br /&gt;
配置文件pelicanconf.py的内容  &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/usr/bin/env python  &lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8 -*- #  &lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;  

&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;particle128&amp;#39;&lt;/span&gt;  
&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;particle128&amp;#39;s Blog&amp;quot;&lt;/span&gt;  
&lt;span class="c"&gt;# 点击标题进入的页面  &lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://localhost:8000&amp;#39;&lt;/span&gt;  
&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;  
&lt;span class="n"&gt;DEFAULT_LANG&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;zh&amp;#39;&lt;/span&gt;  

&lt;span class="c"&gt;# 分页  &lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;  
&lt;span class="c"&gt;# 默认日期是markdown文件的修改日期  &lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;fs&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;# 博文上显示的日期格式  &lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE_FORMAT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;%Y-%m-&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;  

&lt;span class="c"&gt;# !!!点击文件标题进入的文件  &lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;# 由markdown保存的文件结构  &lt;/span&gt;
&lt;span class="n"&gt;ARTICLE_SAVE_AS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;posts/{date:%Y}/{date:%m}/{slug}.html&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;# !!!archives文件的位置  &lt;/span&gt;
&lt;span class="n"&gt;ARCHIVES_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;archives.html&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;# 订阅  &lt;/span&gt;
&lt;span class="n"&gt;FEED_ALL_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;  
&lt;span class="n"&gt;CATEGORY_FEED_ATOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.rss.xml&amp;#39;&lt;/span&gt;  

&lt;span class="n"&gt;THEME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;/home/mashu/Dropbox/Practice/Blog/pelican-octopress-theme&amp;#39;&lt;/span&gt;  

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;  
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Boost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.boost.org/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://python.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
        &lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;  
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;https://github.com/particle128&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
        &lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="c"&gt;#顶部菜单项  &lt;/span&gt;
&lt;span class="n"&gt;MENUITEMS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;archives&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/archives.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cpp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/cpp.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linux&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/linux.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/python.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;others&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/others.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;life&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/life.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;]&lt;/span&gt;  

&lt;span class="c"&gt;# disqus评论  &lt;/span&gt;
&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;particle128&amp;quot;&lt;/span&gt;  

&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;pelican-plugins&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 设置插件路径  &lt;/span&gt;
&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;related_posts&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;random_article&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;neighbors&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;sitemap&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c"&gt;# 设置启用的插件  &lt;/span&gt;
&lt;span class="c"&gt;# 随机跳转到某日志  &lt;/span&gt;
&lt;span class="n"&gt;RANDOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;random.html&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;# 相关文章  &lt;/span&gt;
&lt;span class="n"&gt;RELATED_POSTS_MAX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;  
&lt;span class="c"&gt;# sitemap  &lt;/span&gt;
&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
        &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
        &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="p"&gt;},&lt;/span&gt;  
        &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  
            &lt;span class="p"&gt;}&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置文件publishconf.py内容如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;  
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;  
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;  
&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;curdir&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pelicanconf&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;  

&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://particle128.com&amp;#39;&lt;/span&gt;  
&lt;span class="c"&gt;#顶部菜单项  &lt;/span&gt;
&lt;span class="n"&gt;MENUITEMS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;archives&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/archives.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;cpp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/cpp.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linux&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/linux.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/python.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;others&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/others.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;life&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;SITEURL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/category/life.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  
            &lt;span class="p"&gt;]&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;vim配置  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s2"&gt;&amp;quot; markdown设置  &lt;/span&gt;
&lt;span class="s2"&gt;au BufRead,BufNewFile,FileReadPre *.md set filetype=markdown  &lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;换行、添加元数据&lt;/span&gt;  
&lt;span class="nx"&gt;au&lt;/span&gt; &lt;span class="nx"&gt;FileType&lt;/span&gt; &lt;span class="nx"&gt;markdown&lt;/span&gt; &lt;span class="kt"&gt;map&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;F12&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/\&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;  &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;ggOtitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;xxx&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;slug&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;xxx&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nb"&gt;tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;xx&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;CR&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;ESC&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1.用vim编辑markdown文件的时候，首先写正文，不需要注意两个空格的换行。写完正文后，按F12键生成换行的两空格和正文前的元数据（title,slug,tags）&lt;br /&gt;
2.如果是用vim修改已经写好并且执行过F12的markdown文件，修改完成后，F12，然后删除前面多添加的元数据。  &lt;/p&gt;
&lt;p&gt;到此，环境就算搭建完毕。不明白的地方，还是查看pelican的文档。  &lt;/p&gt;
&lt;h2&gt;独立域名&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;a href="http://www.goyouhuima.com/"&gt;GoDaddy优惠码网站&lt;/a&gt;选择一个链接，进入，购买一年的域名，比如particle128.com，55元左右,可以用支付宝购买。  &lt;/li&gt;
&lt;li&gt;在&lt;a href="https://www.dnspod.cn/"&gt;DNSPOD&lt;/a&gt;上注册，然后建立一条A记录，一条CNAME记录，将购买的域名particle128.com绑定到Github Pages的ip地址（注意不是独立ip），将www.particle128.com重定向到particle128.com&lt;br /&gt;
截图：&lt;br /&gt;
&lt;img alt="dnspod_screenshot" src="http://particle128.com/images/DNSPod.png" /&gt;  &lt;/li&gt;
&lt;li&gt;重新登陆GoDaddy，添加DNSPod的name server&lt;br /&gt;
f1g1ns1.dnspod.net&lt;br /&gt;
f1g1ns2.dnspod.net  &lt;/li&gt;
&lt;li&gt;Github Pages使用自定义域名&lt;br /&gt;
参考：https://help.github.com/articles/setting-up-a-custom-domain-with-pages&lt;br /&gt;
执行:  &lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;blog/output  
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;particle128.com&amp;#39;&lt;/span&gt; &amp;gt; CNAME  
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="pelican"></category><category term="blog"></category></entry><entry><title>Linux权限小结</title><link href="http://particle128.com/posts/2013/09/authority.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/authority.html</id><summary type="html">&lt;h4&gt;1、文件权限：针对文件的实际数据（data block中的内容）&lt;/h4&gt;
&lt;p&gt;r：可以查看文件内容&lt;br /&gt;
w：可以修改文件内容&lt;br /&gt;
x：可以执行文件内容  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt; &lt;br /&gt;
一个文件可以仅有r权限，修改需要强制写入，比如vim下:w!，然后再:q。&lt;/p&gt;
&lt;h4&gt;2、目录权限：针对目录的结构，实际也是目录的实际数据（data block里存的就是目录里的文件列表&amp;lt;文件名，inode号&amp;gt;）&lt;/h4&gt;
&lt;p&gt;r：可以查看目录结构（ls）&lt;br /&gt;
w：可以修改目录结构（如touch新文件，rm文件，其他无出其右：mv重命名是先删再增）&lt;br /&gt;
x：可以把目录当作工作目录（cd。即使不cd进去，在目录下进行各种操作比如读、修改文件也要有目录的x权限）  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
一个目录开放浏览，需要r+x权限。&lt;br /&gt;
有r没x，ls可以看到文件名，不能cd进入，ls -l看到其他属性都是问号；&lt;br /&gt;
有x没r，可以cd进去，不能ls查看内容。【所谓不能，是指执行该操作会返回“Permission denied”】&lt;br /&gt;
仅有w，无法修改目录结构，因为命令进入不进去这个目录，需要x权限配合w才能完成修改目录的作用。&lt;/p&gt;
&lt;h4&gt;3、umask：初始权限中需要屏蔽的部分，ubuntu12.04下默认是0002，去掉其他用户的写权限。&lt;/h4&gt;
&lt;p&gt;文件初始权限：-rw-rw-rw- （0666）&lt;br /&gt;
文件默认权限：初始-umask。0666-0002=0664，即-rw-rw-r--&lt;br /&gt;
文件夹初始权限：drwxrwxrwx（0777）&lt;br /&gt;
文件夹默认权限：初始-umask。0777-0002=0775，即drwxrwxr-x  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note：&lt;/strong&gt;&lt;br /&gt;
所有者和同组用户权限相同，其他用户剥夺写权限。&lt;br /&gt;
命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="mo"&gt;022&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;修改&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;默认值&lt;/span&gt;
&lt;span class="n"&gt;umask&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;以字符的形式显示&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="err"&gt;之后的效果，&lt;/span&gt;&lt;span class="mo"&gt;0002&lt;/span&gt;&lt;span class="err"&gt;对应&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rwx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rx&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4、三个特殊权限：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;SUID（SetUID）&lt;/strong&gt;：ls-l显示所有者权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/passwd。普通用户可以执行passwd修改自己的密码，执行该程序后默认UID变为root（passwd的所有者），因此可以修改仅仅root可读的/etc/shadow&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SGID（SetGID）&lt;/strong&gt;：ls-l显示组权限x-&amp;gt;s&lt;br /&gt;
例子：/usr/bin/locate。普通用户执行locate定位文件，执行该程序后默认GID变为slocate（locate的所属用户组），因此可以查询仅仅mlocate组内用户可以访问的mlocate.db&lt;br /&gt;
另：作用于目录时，相当于用户cd进该目录后有效用户组就变成该目录的用户组了，影响此后新建的文件的所属用户组。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SBIT（Sticky Bit）&lt;/strong&gt;：ls-l显示其他权限x-&amp;gt;t&lt;br /&gt;
例子：/tmp。用户进入/tmp下新建的文件，只有root和文件所有者可以删除，其他用户即使对/tmp有w权限也没用。&lt;/p&gt;</summary><category term="linux"></category></entry><entry><title>Linux下的用户和用户组小结</title><link href="http://particle128.com/posts/2013/09/linux_user.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/linux_user.html</id><summary type="html">&lt;h3&gt;1. 修改文件的相应属性&lt;/h3&gt;
&lt;h4&gt;chown 修改文件所有者&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chown mashu:mashu aa.txt &lt;span class="c"&gt;# 或chown mashu.mashu aa.txt 同时修改所有者和组&lt;/span&gt;
chown mashu aa.txt &lt;span class="c"&gt;# 修改所有者&lt;/span&gt;
chown .mashu aa.txt &lt;span class="c"&gt;# 修改组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chgrp 修改文件所属用户组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chgrp mashu aa.txt 修改组
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;chmod 修改权限&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod 777 aa.txt   
chmod a+r aa.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 3个重要文件&lt;/h3&gt;
&lt;h4&gt;/etc/passwd&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的UID，初始用户组GID，说明，home dir，shell  &lt;/p&gt;
&lt;h4&gt;/etc/shadow&lt;/h4&gt;
&lt;p&gt;记录 用户名 对应的密码（加密后）  &lt;/p&gt;
&lt;h4&gt;/etc/group&lt;/h4&gt;
&lt;p&gt;记录 组名 对应的GID，组内用户（不包括初始用户组是该组的用户，因为/etc/passwd里有了）&lt;/p&gt;
&lt;h3&gt;3. 概念区分&lt;/h3&gt;
&lt;h4&gt;初始用户组：&lt;/h4&gt;
&lt;p&gt;useradd或usermod，-g参数后的组名。保存在/etc/passwd中。&lt;br /&gt;
实际意义是，/etc/group里少写一个用户名。。。  &lt;/p&gt;
&lt;h4&gt;有效用户组：&lt;/h4&gt;
&lt;p&gt;groups显示的第一用户组。可以通过newgrp重设。具体哪个文件保存不详。&lt;br /&gt;
实际意义是，用户新建文件时文件的所属用户组，就是有效用户组。&lt;/p&gt;
&lt;h3&gt;4. 用户分类&lt;/h3&gt;
&lt;p&gt;ubuntu12.04下，根据/etc/login.defs&lt;br /&gt;
UID=0  系统管理员&lt;br /&gt;
UID in {100,999} 系统用户  (SYS_UID_MIN - SYS_UID_MAX)&lt;br /&gt;
UID in {1000,60000} 可登录用户  (UID_MIN - UID_MAX)  &lt;/p&gt;
&lt;h3&gt;5. linux命令&lt;/h3&gt;
&lt;h4&gt;1) useradd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;useradd -u &lt;span class="o"&gt;[&lt;/span&gt;UID&lt;span class="o"&gt;]&lt;/span&gt; -g &lt;span class="o"&gt;[&lt;/span&gt;initial group name&lt;span class="o"&gt;]&lt;/span&gt; -G &lt;span class="o"&gt;[&lt;/span&gt;other group name&lt;span class="o"&gt;]&lt;/span&gt; -d &lt;span class="o"&gt;[&lt;/span&gt;home dir&lt;span class="o"&gt;]&lt;/span&gt; -s &lt;span class="o"&gt;[&lt;/span&gt;shell&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;没有参数，默认是可登录用户（有shell，有home dir），同名初始用户组。&lt;br /&gt;
-r 建立系统用户（不能登录，没有shell，默认没有home dir，除非修改/etc/login.defs文件）&lt;/p&gt;
&lt;h4&gt;2) usermod&lt;/h4&gt;
&lt;p&gt;同useradd&lt;/p&gt;
&lt;h4&gt;3) passwd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;passwd &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt; 
passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;无参数修改自己的密码&lt;/p&gt;
&lt;h4&gt;4) userdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;userdel -r &lt;span class="o"&gt;[&lt;/span&gt;用户名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加上-r，连同主文件夹也一同删除&lt;/p&gt;
&lt;h4&gt;5) groupadd&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupadd -g &lt;span class="o"&gt;[&lt;/span&gt;GID&lt;span class="o"&gt;]&lt;/span&gt; -r &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;-g 指定GID，-r 创建系统组&lt;/p&gt;
&lt;h4&gt;6) groupdel&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;groupdel &lt;span class="o"&gt;[&lt;/span&gt;组名&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="linux"></category><category term="user"></category></entry><entry><title>Python学习笔记-logging模块</title><link href="http://particle128.com/posts/2013/09/python-logging.html" rel="alternate"></link><updated>2013-09-08T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-08:posts/2013/09/python-logging.html</id><summary type="html">&lt;h4&gt;Logging is a means of tracking events that happen when some software runs.&lt;/h4&gt;
&lt;h3&gt;1、各种消息机制的使用场合&lt;/h3&gt;
&lt;p&gt;终端输出来显示一些信息：print()&lt;br /&gt;
报告软件常规运行中出现的一些事件，比如状态变化或错误调查：logging.info()，&lt;br /&gt;
logging.debug()用来诊断错误&lt;br /&gt;
发布一个警告：logging.warning()或warnings.warn()&lt;br /&gt;
报告一个错误：raise an exception&lt;br /&gt;
不抛出异常的出错：logging.error(), logging.exception(), logging.critical()  &lt;/p&gt;
&lt;p&gt;logging有一个属性叫level或severity，只有不低于它的事件才会被捕捉。&lt;/p&gt;
&lt;p&gt;level由低到高依次是：&lt;br /&gt;
DEBUG，INFO，WARNING（默认等级），ERROR，CRITICAL  &lt;/p&gt;
&lt;h3&gt;2、基础用法&lt;/h3&gt;
&lt;p&gt;默认日志消息会输出到终端（sys.stderr），用法为：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;  
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; before you &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Look&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;leap!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一次性配置日志消息，用法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;example.log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;filemode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(levelname)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;something happends.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;basicConfig参数：
filename指明日志消息输出到指定的文件中，默认输出到终端&lt;br /&gt;
filemode指明文件打开方式是只写，每次输出日志都会把原来的日志覆盖。默认是追加('a')&lt;br /&gt;
level指明追踪(track)的日志等级&lt;br /&gt;
format指明日志格式，里面的字典参数依次是：日期、等级名、日志消息。format里不支持：和\n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; basicConfig只能在调用logging.debug()等任意函数之前调用，否则无效。调用之后，所有的logging行为都按照配置，再次执行basicConfig也不能进一步修改配置。所以称之为one-off（一次性的）。&lt;/p&gt;
&lt;h3&gt;3、高级用法&lt;/h3&gt;
&lt;p&gt;比较好的习惯是logger=logging.getLogger(__name__) ，这样每个模块里logger的名字都是以自己模块的名字来命名的，从日志中可以看出是哪里导出的日志。&lt;/p&gt;
&lt;p&gt;logger=logging.getLogger()相当于获取根logger，即名字为root的logger  &lt;/p&gt;
&lt;p&gt;Logger常用方法：&lt;br /&gt;
setLevel()，addHandler()，removeHandler()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;Handler常用方法：&lt;br /&gt;
setLevel()，setFormatter()，addFilter()，removeFilter()&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;myFilter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Filter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;#其实可以不用继承，只要含有filter方法的类都可以&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;filter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;# record是LogRecord对象&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;record&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;test&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="c"&gt;#使用msg属性或getMessage()方法都可以&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# zero for not logging&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="c"&gt;# non-zero for logging&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;main.a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c"&gt;# main.a是该logger的name，即所有者，用点来分割命名空间。如果是main.a则是main的子类，继承关系影响level、handler，如果不设置level就按照父类的level进行设置，如果不设置handler，就由父类的handler捕获。&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 过滤该level以下的日志消息&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c"&gt;# 比level更细力度的过滤功能&lt;/span&gt;

&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;FileHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/home/mashu/log.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StreamHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;INFO&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 文件level是INFO&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setLevel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 终端level是DEBUG&lt;/span&gt;
&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Formatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)-15s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(name)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(levelname)-10s&lt;/span&gt;&lt;span class="s"&gt; - &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 设置日志消息的格式&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormatter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;form&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myFilter&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;addHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;first: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;second:test log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;third: log&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="python"></category><category term="logging"></category></entry><entry><title>android小工具-失败短信重新发送</title><link href="http://particle128.com/posts/2013/09/androidSMS.html" rel="alternate"></link><updated>2013-09-03T00:00:00+08:00</updated><author><name>particle128</name></author><id>tag:particle128.com,2013-09-03:posts/2013/09/androidSMS.html</id><summary type="html">&lt;h3&gt;由来&lt;/h3&gt;
&lt;p&gt;开学伊始，更换手机卡，群发260条短信，后察觉不对。只有一开始的100条左右的短信发送成功了，后面的短信都失败了。上网一查，是联通卡的一种限制，1h最多发送100条短信，超过就误认为你是在发送垃圾短信，自动锁住短信功能，发不出去任何短信了。&lt;br /&gt;
第二天经过10010报修，恢复短信功能。但是要一个一个的找哪些发送失败了，然后就只给那些人发送短信又不现实，因为有260个人失败了。。。给所有人都发一遍又觉得有点扰民。。。相关软件在安卓系统又找不到。。。干脆自己搞一个吧。  &lt;/p&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;代码如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ResendSms&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;  
&lt;span class="o"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//发件箱  &lt;/span&gt;
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;SMS_URI_SEND&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;content://sms/sent&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
    &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;因故手机换号，原号废弃，敬请惠存新号xxxxxxxxxxx，带来的不便敬请谅解。 署名&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  

    &lt;span class="n"&gt;StringBuilder&lt;/span&gt; &lt;span class="n"&gt;smsBuilder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;  

    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;ContentResolver&lt;/span&gt; &lt;span class="n"&gt;cr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getContentResolver&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;  
        &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;projection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_id&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;address&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;person&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;  
            &lt;span class="s"&gt;&amp;quot;body&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;status&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;  
        &lt;span class="n"&gt;Uri&lt;/span&gt; &lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Uri&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SMS_URI_SEND&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
        &lt;span class="n"&gt;Cursor&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;query&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;projection&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;date desc&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;moveToFirst&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;phoneNumber&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;smsbody&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  

            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nameColumn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getColumnIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;person&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;phoneNumberColumn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getColumnIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;address&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;smsbodyColumn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getColumnIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;body&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dateColumn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getColumnIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;date&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;typeColumn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getColumnIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;status&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;allPhone&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  
            &lt;span class="k"&gt;do&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;  
                &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nameColumn&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
                &lt;span class="n"&gt;phoneNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phoneNumberColumn&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
                &lt;span class="n"&gt;smsbody&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smsbodyColumn&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  

                &lt;span class="n"&gt;SimpleDateFormat&lt;/span&gt; &lt;span class="n"&gt;dateFormat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SimpleDateFormat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;  
                        &lt;span class="s"&gt;&amp;quot;yyyy-MM-dd hh:mm:ss&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
                &lt;span class="n"&gt;Date&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Long&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parseLong&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dateColumn&lt;/span&gt;&lt;span class="o"&gt;)));&lt;/span&gt;  
                &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dateFormat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  

                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;typeId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;typeColumn&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  

                &lt;span class="c1"&gt;// status不等于0的信息是发送出错的信息  &lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;typeId&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;))&lt;/span&gt;  
                    &lt;span class="n"&gt;allPhone&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;phoneNumber&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  

            &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cur&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;moveToNext&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;  
            &lt;span class="n"&gt;allPhone&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;substring&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;allPhone&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt;&lt;span class="o"&gt;()-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="c1"&gt;// 仅发送没有发送成功的号码  &lt;/span&gt;
            &lt;span class="n"&gt;Intent&lt;/span&gt; &lt;span class="n"&gt;intent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;Intent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ACTION_VIEW&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Uri&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sms:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;allPhone&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="n"&gt;intent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putExtra&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;sms_body&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;  
            &lt;span class="n"&gt;startActivity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;intent&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;  

        &lt;span class="o"&gt;}&lt;/span&gt;  

    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SQLiteException&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;  
        &lt;span class="n"&gt;Log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;d&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;SQLiteException in getSmsInPhone&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;  
    &lt;span class="o"&gt;}&lt;/span&gt;  
&lt;span class="o"&gt;}&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加权限如下：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;uses&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;permission&lt;/span&gt; &lt;span class="nl"&gt;android:&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.permission.SEND_SMS&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;uses&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;permission&lt;/span&gt; &lt;span class="nl"&gt;android:&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.permission.READ_SMS&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;uses&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;permission&lt;/span&gt; &lt;span class="nl"&gt;android:&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.permission.WRITE_SMS&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;uses&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;permission&lt;/span&gt; &lt;span class="nl"&gt;android:&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;android.permission.RECEIVE_SMS&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;p&gt;遍历短信：http://android.tgbus.com/Android/tutorial/201104/349808.shtml&lt;br /&gt;
状态码：http://www.proces-data.dk/6A/002J1EFSED/CDRVO-01/Description_ENG.htm&lt;br /&gt;
sms的属性：http://www.java2s.com/Open-Source/Android/SMS/smsselector/com/rudolfheszele/smsselector/model/SmsSelectorSmsMessage.java.htm&lt;br /&gt;
发送短信实现：http://stackoverflow.com/questions/4967448/send-sms-in-android  &lt;/p&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;p&gt;感谢欧阳师弟的鼎力支持，我没有安卓开发环境，也对安卓开发一窍不通，调试工作全靠他的帮助。&lt;br /&gt;
从打算自己解决，到最后解决完用了3h左右吧，记录下java零基础前提下用java解决问题的经历。  &lt;/p&gt;</summary><category term="android"></category></entry></feed>